/*
 *  Copyright (c) 2016-present, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 *
 */
#pragma once
#include <folly/File.h>
#include <folly/futures/Future.h>
#include <folly/futures/Promise.h>
#include <folly/io/async/EventBase.h>
#include <folly/io/async/Request.h>
#include <stdlib.h>
#include <sys/uio.h>
#include <condition_variable>
#include <memory>
#include <mutex>
#include <thread>
#include <unordered_map>
#include <vector>

#include "eden/fs/fuse/FuseTypes.h"
#include "eden/fs/utils/PathFuncs.h"

namespace facebook {
namespace eden {
namespace fusell {

class Dispatcher;

class FuseChannel {
 public:
  ~FuseChannel();

  /**
   * Construct the fuse channel and session structures that are
   * required by libfuse to communicate with the kernel using
   * a pre-existing fuseDevice descriptor.  The descriptor may
   * have been obtained via privilegedFuseMount() or may have
   * been passed to us as part of a graceful restart procedure.
   */
  FuseChannel(
      folly::File&& fuseDevice,
      AbsolutePathPiece mountPath,
      folly::EventBase* eventBase,
      size_t numThreads,
      Dispatcher* const dispatcher,
      fuse_init_out connInfo);

  // Forbidden copy constructor and assignment operator
  FuseChannel(FuseChannel const&) = delete;
  FuseChannel& operator=(FuseChannel const&) = delete;

  /**
   * Dispatches fuse requests until the session is torn down.
   * This function blocks until the fuse session is stopped.
   * The intent is that this is called from each of the
   * fuse worker threads provided by the MountPoint. */
  void processSession();

  /**
   * Requests that the worker threads terminate their processing loop.
   */
  void requestSessionExit();

  /**
   * When performing a graceful restart, extract the fuse device
   * descriptor from the channel, preventing it from being closed
   * when we destroy this channel instance.
   * Note that this method does not prevent the worker threads
   * from continuing to use the fuse session.
   */
  FuseChannelData stealFuseDevice();

  /**
   * Notify to invalidate cache for an inode
   *
   * @param ino the inode number
   * @param off the offset in the inode where to start invalidating
   *            or negative to invalidate attributes only
   * @param len the amount of cache to invalidate or 0 for all
   */
  void invalidateInode(fusell::InodeNumber ino, off_t off, off_t len);

  /**
   * Notify to invalidate parent attributes and the dentry matching
   * parent/name
   *
   * @param parent inode number
   * @param name file name
   */
  void invalidateEntry(fusell::InodeNumber parent, PathComponentPiece name);

  /**
   * Sends a reply to a kernel request that consists only of the error
   * status (no additional payload).
   * `err` may be 0 (indicating success) or a positive errno value.
   *
   * throws system_error if the write fails.  Writes can fail if the
   * data we send to the kernel is invalid.
   */
  void replyError(const fuse_in_header& request, int err);

  /**
   * Sends a raw data packet to the kernel.
   * The data may be scattered across a number of discrete buffers;
   * this method uses writev to send them to the kernel as a single unit.
   * The kernel, and thus this method, assumes that the start of this data
   * is a fuse_out_header instance.  This method will sum the iovec lengths
   * to compute the correct value to store into fuse_out_header::len.
   *
   * throws system_error if the write fails.  Writes can fail if the
   * data we send to the kernel is invalid.
   */
  void sendRawReply(const iovec iov[], size_t count) const;

  /**
   * Sends a range of contiguous bytes as a reply to the kernel.
   * request holds the context of the request to which we are replying.
   * `bytes` is the payload to send in addition to the successful status
   * header generated by this method.
   *
   * throws system_error if the write fails.  Writes can fail if the
   * data we send to the kernel is invalid.
   */
  void sendReply(const fuse_in_header& request, folly::ByteRange bytes) const;

  /**
   * Sends a reply to a kernel request, consisting of multiple parts.
   * The `vec` parameter holds an array of payload components and is moved
   * in to this method which then prepends a fuse_out_header and passes
   * control along to sendRawReply().
   *
   * throws system_error if the write fails.  Writes can fail if the
   * data we send to the kernel is invalid.
   */
  void sendReply(const fuse_in_header& request, folly::fbvector<iovec>&& vec)
      const;

  /**
   * Sends a reply to the kernel.
   * The payload parameter is typically a fuse_out_XXX struct as defined
   * in the appropriate fuse_kernel_XXX.h header file.
   *
   * throws system_error if the write fails.  Writes can fail if the
   * data we send to the kernel is invalid.
   */
  template <typename T>
  void sendReply(const fuse_in_header& request, const T& payload) const {
    sendReply(
        request,
        folly::ByteRange{reinterpret_cast<const uint8_t*>(&payload),
                         sizeof(T)});
  }

  void finishRequest(const fuse_in_header& header);

  folly::Future<folly::Unit> fuseRead(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseWrite(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseLookup(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseForget(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseGetAttr(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseSetAttr(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseReadLink(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseSymlink(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseMknod(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseMkdir(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseUnlink(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseRmdir(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseRename(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseLink(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseOpen(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseStatFs(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseRelease(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseFsync(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseSetXAttr(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseGetXAttr(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseListXAttr(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseRemoveXAttr(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseFlush(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseOpenDir(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseReadDir(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseReleaseDir(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseFsyncDir(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseAccess(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseCreate(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseBmap(
      const fuse_in_header* header,
      const uint8_t* arg);
  folly::Future<folly::Unit> fuseBatchForget(
      const fuse_in_header* header,
      const uint8_t* arg);

  /**
   * Returns a Future that will complete when all of the fuse
   * threads have been joined.
   * Will throw if called more than once.
   */
  folly::Future<folly::Unit> getThreadsFinishedFuture();

  /**
   * Returns a Future that will complete when the first fuse
   * thread has been joined; this marks the beginning of the
   * shutdown of the fuse dispatching performed by this class.
   * Will throw if called more than once.
   */
  folly::Future<folly::Unit> getThreadsStoppingFuture();

  /**
   * Returns a Future that will complete when all of the
   * fuse threads have been joined and when all pending
   * fuse requests initiated by the kernel have been
   * responded to.
   * Will throw if called more than once.
   */
  folly::Future<folly::Unit> getSessionCompleteFuture();

 private:
  void fuseWorkerThread(size_t threadNumber);
  void maybeDispatchSessionComplete();

  Dispatcher* const dispatcher_{nullptr};
  folly::File fuseDevice_;
  folly::EventBase* eventBase_;
  fuse_init_out connInfo_;
  std::atomic<bool> sessionFinished_{false};
  folly::Synchronized<
      std::unordered_map<uint64_t, std::weak_ptr<folly::RequestContext>>>
      requests_;
  std::vector<std::thread> workerThreads_;
  std::atomic<size_t> joinedThreads_{0};
  const size_t numThreads_;
  const AbsolutePath mountPath_;
  folly::Promise<folly::Unit> threadsFinishedPromise_;
  folly::Promise<folly::Unit> threadsStoppingPromise_;
  folly::Promise<folly::Unit> sessionCompletePromise_;

  // To prevent logging unsupported opcodes twice.
  folly::Synchronized<std::unordered_set<FuseOpcode>> unhandledOpcodes_;
};
} // namespace fusell
} // namespace eden
} // namespace facebook
