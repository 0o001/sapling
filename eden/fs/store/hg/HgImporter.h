/*
 *  Copyright (c) 2016-present, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 *
 */
#pragma once

#include <folly/Range.h>
#include <folly/Subprocess.h>

#include "eden/fs/utils/PathFuncs.h"

namespace folly {
class IOBuf;
namespace io {
class Cursor;
}
}

/* forward declare support classes from mercurial */
class DatapackStore;
class UnionDatapackStore;

namespace facebook {
namespace eden {

class Hash;
class HgManifestImporter;
class LocalStore;
class StoreResult;
class Tree;

/**
 * HgImporter provides an API for extracting data out of a mercurial
 * repository.
 *
 * Mercurial itself is in python, so some of the import logic runs as python
 * code.  HgImporter hides all of the interaction with the underlying python
 * code.
 *
 * HgImporter is not thread safe.  The external caller must provide their own
 * locking around each HgImporter object.  However, to achieve parallelism
 * multiple HgImporter objects can be created for the same repository and used
 * simultaneously.
 */
class HgImporter {
 public:
  /**
   * Create a new HgImporter object that will import data from the specified
   * repository into the given LocalStore.
   *
   * The caller is responsible for ensuring that the LocalStore object remains
   * valid for the lifetime of the HgImporter object.
   */
  HgImporter(AbsolutePathPiece repoPath, LocalStore* store);
  virtual ~HgImporter();

  /**
   * Import the manifest for the specified revision.
   *
   * Returns a Hash identifying the root Tree for the imported revision.
   */
  Hash importManifest(folly::StringPiece revName);

  /**
   * Import the tree with the specified tree manifest hash.
   *
   * Returns the Tree, or throws on error.
   * Requires that tree manifest data be available.
   */
  std::unique_ptr<Tree> importTree(const Hash& edenBlobHash);

  /**
   * Import file information
   *
   * Takes a hash identifying the requested blob.  (For instance, blob hashes
   * can be found in the TreeEntry objects generated by importManifest().)
   *
   * Returns an IOBuf containing the file contents.
   */
  folly::IOBuf importFileContents(Hash blobHash);

  /**
   * Resolve the manifest node for the specified revision.
   *
   * This is used to locate the mercurial tree manifest data for
   * the root tree of a given commit.
   *
   * Returns a Hash identifying the manifest node for the revision.
   */
  Hash resolveManifestNode(folly::StringPiece revName);

 private:
  /**
   * Chunk header flags.
   *
   * These are flag values, designed to be bitwise ORed with each other.
   */
  enum : uint32_t {
    FLAG_ERROR = 0x01,
    FLAG_MORE_CHUNKS = 0x02,
  };
  /**
   * Command type values.
   *
   * See hg_import_helper.py for a more complete description of the
   * request/response formats.
   */
  enum : uint32_t {
    CMD_STARTED = 0,
    CMD_RESPONSE = 1,
    CMD_MANIFEST = 2,
    CMD_CAT_FILE = 3,
    CMD_MANIFEST_NODE_FOR_COMMIT = 4,
    CMD_GET_CACHE_PATH = 5,
  };
  struct ChunkHeader {
    uint32_t requestID;
    uint32_t command;
    uint32_t flags;
    uint32_t dataLength;
  };

  // Forbidden copy constructor and assignment operator
  HgImporter(const HgImporter&) = delete;
  HgImporter& operator=(const HgImporter&) = delete;

  /**
   * Read a single manifest entry from a manifest response chunk,
   * and give it to the HgManifestImporter for processing.
   *
   * The cursor argument points to the start of the manifest entry in the
   * response chunk received from the helper process.  readManifestEntry() is
   * responsible for updating the cursor to point to the next manifest entry.
   */
  void readManifestEntry(
      HgManifestImporter& importer,
      folly::io::Cursor& cursor);
  /**
   * Read a response chunk header from the helper process
   *
   * If the header indicates an error, this will read the full error message
   * and throw a std::runtime_error.
   */
  ChunkHeader readChunkHeader();
  /**
   * Send a request to the helper process, asking it to send us the manifest
   * for the specified revision.
   */
  void sendManifestRequest(folly::StringPiece revName);
  /**
   * Send a request to the helper process, asking it to send us the contents
   * of the given file at the specified file revision.
   */
  void sendFileRequest(RelativePathPiece path, Hash fileRevHash);
  /**
   * Send a request to the helper process, asking it to send us the
   * manifest node (NOT the full manifest!) for the specified revision.
   */
  void sendManifestNodeRequest(folly::StringPiece revName);
  /**
   * Determine the shared tree manifest pack location associated with
   * this repo.
   */
  std::string getCachePath();
  /**
   * Send a request to the helper process, asking it to send us the
   * tree manifest pack location.
   */
  void sendGetCachePathRequest();

  std::unique_ptr<Tree> importTreeImpl(
      const Hash& manifestNode,
      const Hash& edenBlobHash,
      RelativePathPiece path);
  Hash importTreeManifest(folly::StringPiece revName);
  Hash importFlatManifest(folly::StringPiece revName);

  folly::Subprocess helper_;
  LocalStore* store_{nullptr};
  uint32_t nextRequestID_{0};
  /**
   * The input and output file descriptors to the helper subprocess.
   * We don't own these FDs, and don't need to close them--they will be closed
   * automatically by the Subprocess object.
   *
   * We simply cache them as member variables to avoid having to look them up
   * via helper_.parentFd() each time we need to use them.
   */
  int helperIn_{-1};
  int helperOut_{-1};

  std::vector<std::unique_ptr<DatapackStore>> dataPackStores_;
  std::unique_ptr<UnionDatapackStore> unionStore_;
};
}
} // facebook::eden
