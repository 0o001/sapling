// @generated by Thrift for fb303/thrift/fb303_core.thrift
// This file is probably not the place you want to edit!

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

extern crate serde;
pub use self::errors::*;
pub use self::types::*;

/// Thrift type definitions for `fb303_core`.
pub mod types {
    #![allow(clippy::redundant_closure)]


    #[doc = "Common status reporting mechanism across all services"]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct fb303_status(pub ::std::primitive::i32);

    impl fb303_status {
        pub const DEAD: Self = fb303_status(0i32);
        pub const STARTING: Self = fb303_status(1i32);
        pub const ALIVE: Self = fb303_status(2i32);
        pub const STOPPING: Self = fb303_status(3i32);
        pub const STOPPED: Self = fb303_status(4i32);
        pub const WARNING: Self = fb303_status(5i32);
    }

    impl ::fbthrift::ThriftEnum for fb303_status {
        fn enumerate() -> &'static [(fb303_status, &'static str)] {
            &[
                (fb303_status::DEAD, "DEAD"),
                (fb303_status::STARTING, "STARTING"),
                (fb303_status::ALIVE, "ALIVE"),
                (fb303_status::STOPPING, "STOPPING"),
                (fb303_status::STOPPED, "STOPPED"),
                (fb303_status::WARNING, "WARNING"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "DEAD",
                "STARTING",
                "ALIVE",
                "STOPPING",
                "STOPPED",
                "WARNING",
            ]
        }

        fn variant_values() -> &'static [fb303_status] {
            &[
                fb303_status::DEAD,
                fb303_status::STARTING,
                fb303_status::ALIVE,
                fb303_status::STOPPING,
                fb303_status::STOPPED,
                fb303_status::WARNING,
            ]
        }
    }

    impl ::std::default::Default for fb303_status {
        fn default() -> Self {
            fb303_status(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a fb303_status> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a fb303_status) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<fb303_status> for ::std::primitive::i32 {
        #[inline]
        fn from(x: fb303_status) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for fb303_status {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for fb303_status {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("DEAD", 0),
                ("STARTING", 1),
                ("ALIVE", 2),
                ("STOPPING", 3),
                ("STOPPED", 4),
                ("WARNING", 5),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for fb303_status {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "fb303_status::{}", self)
        }
    }

    impl ::std::str::FromStr for fb303_status {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ALIVE", 2),
                ("DEAD", 0),
                ("STARTING", 1),
                ("STOPPED", 4),
                ("STOPPING", 3),
                ("WARNING", 5),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "fb303_status").map(fb303_status)
        }
    }

    impl ::fbthrift::GetTType for fb303_status {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for fb303_status
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for fb303_status
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(fb303_status::from(p.read_i32()?))
        }
    }
}

#[doc(hidden)]
pub mod dependencies {
}

pub mod services {
    pub mod base_service {
        #![doc = "Standard base service interface.\n\nThis interface provides methods to get some service metadata that is common\nacross many services."]


        #[derive(Clone, Debug)]
        pub enum GetStatusExn {
            Success(crate::types::fb303_status),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetStatusExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetStatusExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetStatusExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetStatusExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetStatus");
                match self {
                    GetStatusExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I32,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetStatusExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetStatusExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::I32, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I32, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetStatusExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetNameExn {
            Success(::std::string::String),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetNameExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetNameExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetNameExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetNameExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetName");
                match self {
                    GetNameExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetNameExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetNameExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::String, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetNameExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetNameExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetNameExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetVersionExn {
            Success(::std::string::String),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetVersionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetVersionExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetVersionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetVersionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetVersion");
                match self {
                    GetVersionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetVersionExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetVersionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::String, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetVersionExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetVersionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetVersionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetStatusDetailsExn {
            Success(::std::string::String),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetStatusDetailsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetStatusDetailsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetStatusDetailsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetStatusDetailsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetStatusDetails");
                match self {
                    GetStatusDetailsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetStatusDetailsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetStatusDetailsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::String, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetStatusDetailsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetStatusDetailsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetStatusDetailsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetCountersExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetCountersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetCountersExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetCountersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetCountersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetCounters");
                match self {
                    GetCountersExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetCountersExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetCountersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Map, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetCountersExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetCountersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetCountersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetRegexCountersExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetRegexCountersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetRegexCountersExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetRegexCountersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetRegexCountersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetRegexCounters");
                match self {
                    GetRegexCountersExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetRegexCountersExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetRegexCountersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Map, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetRegexCountersExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetRegexCountersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetRegexCountersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSelectedCountersExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetSelectedCountersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetSelectedCountersExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetSelectedCountersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetSelectedCountersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetSelectedCounters");
                match self {
                    GetSelectedCountersExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSelectedCountersExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetSelectedCountersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Map, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetSelectedCountersExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSelectedCountersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSelectedCountersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetCounterExn {
            Success(::std::primitive::i64),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetCounterExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetCounterExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetCounterExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetCounterExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetCounter");
                match self {
                    GetCounterExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetCounterExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetCounterExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::I64, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I64, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetCounterExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetCounterExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetCounterExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetExportedValuesExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::string::String>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetExportedValuesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetExportedValuesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetExportedValuesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetExportedValuesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetExportedValues");
                match self {
                    GetExportedValuesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetExportedValuesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetExportedValuesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Map, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetExportedValuesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetExportedValuesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetExportedValuesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSelectedExportedValuesExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::string::String>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetSelectedExportedValuesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetSelectedExportedValuesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetSelectedExportedValuesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetSelectedExportedValuesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetSelectedExportedValues");
                match self {
                    GetSelectedExportedValuesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSelectedExportedValuesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetSelectedExportedValuesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Map, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetSelectedExportedValuesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSelectedExportedValuesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSelectedExportedValuesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetRegexExportedValuesExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::string::String>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetRegexExportedValuesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetRegexExportedValuesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetRegexExportedValuesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetRegexExportedValuesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetRegexExportedValues");
                match self {
                    GetRegexExportedValuesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetRegexExportedValuesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetRegexExportedValuesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Map, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetRegexExportedValuesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetRegexExportedValuesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetRegexExportedValuesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetExportedValueExn {
            Success(::std::string::String),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetExportedValueExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetExportedValueExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetExportedValueExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetExportedValueExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetExportedValue");
                match self {
                    GetExportedValueExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetExportedValueExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetExportedValueExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::String, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetExportedValueExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetExportedValueExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetExportedValueExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SetOptionExn {
            Success(()),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SetOptionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                SetOptionExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for SetOptionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for SetOptionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("SetOption");
                match self {
                    SetOptionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SetOptionExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for SetOptionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = SetOptionExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = SetOptionExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SetOptionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetOptionExn {
            Success(::std::string::String),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetOptionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetOptionExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetOptionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetOptionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetOption");
                match self {
                    GetOptionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetOptionExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetOptionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::String, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetOptionExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetOptionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetOptionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetOptionsExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::string::String>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetOptionsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetOptionsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetOptionsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetOptionsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetOptions");
                match self {
                    GetOptionsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetOptionsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetOptionsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Map, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetOptionsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetOptionsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetOptionsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AliveSinceExn {
            Success(::std::primitive::i64),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AliveSinceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AliveSinceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AliveSinceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AliveSinceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AliveSince");
                match self {
                    AliveSinceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AliveSinceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AliveSinceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::I64, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I64, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AliveSinceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AliveSinceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AliveSinceExn"),
                    )
                    .into(),
                )
            }
        }
    }
}

/// Client implementation for each service in `fb303_core`.
pub mod client {

    pub struct BaseServiceImpl<P, T> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> P>,
    }

    impl<P, T> BaseServiceImpl<P, T> {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }
    }

    #[doc = "Standard base service interface.\n\nThis interface provides methods to get some service metadata that is common\nacross many services."]
    pub trait BaseService: ::std::marker::Send {
        #[doc = "Gets the status of this service"]
        fn getStatus(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::fb303_status, crate::errors::base_service::GetStatusError>> + ::std::marker::Send + 'static>>;
        #[doc = "Returns a descriptive name of the service"]
        fn getName(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetNameError>> + ::std::marker::Send + 'static>>;
        #[doc = "Returns the version of the service"]
        fn getVersion(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetVersionError>> + ::std::marker::Send + 'static>>;
        #[doc = "User friendly description of status, such as why the service is in\nthe dead or warning state, or what is being started or stopped."]
        fn getStatusDetails(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetStatusDetailsError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets the counters for this service"]
        fn getCounters(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetCountersError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets a subset of counters which match a\nPerl Compatible Regular Expression for this service"]
        fn getRegexCounters(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetRegexCountersError>> + ::std::marker::Send + 'static>>;
        #[doc = "Get counter values for a specific list of keys.  Returns a map from\nkey to counter value; if a requested counter doesn't exist, it won't\nbe in the returned map."]
        fn getSelectedCounters(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetSelectedCountersError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets the value of a single counter"]
        fn getCounter(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::GetCounterError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets the exported string values for this service"]
        fn getExportedValues(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetExportedValuesError>> + ::std::marker::Send + 'static>>;
        #[doc = "Get exported strings for a specific list of keys.  Returns a map from\nkey to string value; if a requested key doesn't exist, it won't\nbe in the returned map."]
        fn getSelectedExportedValues(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetSelectedExportedValuesError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets a subset of exported values which match a\nPerl Compatible Regular Expression for this service"]
        fn getRegexExportedValues(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetRegexExportedValuesError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets the value of a single exported string"]
        fn getExportedValue(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetExportedValueError>> + ::std::marker::Send + 'static>>;
        #[doc = "Sets an option"]
        fn setOption(
            &self,
            arg_key: &::std::primitive::str,
            arg_value: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::base_service::SetOptionError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets an option"]
        fn getOption(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetOptionError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets all options"]
        fn getOptions(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetOptionsError>> + ::std::marker::Send + 'static>>;
        #[doc = "Returns the unix time that the server has been running since"]
        fn aliveSince(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::AliveSinceError>> + ::std::marker::Send + 'static>>;
    }

    impl<P, T> BaseService for BaseServiceImpl<P, T>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
    {        fn getStatus(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::fb303_status, crate::errors::base_service::GetStatusError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getStatus";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getStatus",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(SERVICE_NAME, METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| {
                    let de = P::deserializer(reply);
                    (move |mut p: P::Deserializer| {
                        use ::fbthrift::{ProtocolReader as _};
                        let (_, message_type, _) = match p.read_message_begin(|_| ()) {
                            Ok(res) => res,
                            Err(e) => return ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ::std::result::Result::Err(e.into())
                                    )
                                )
                        };
                        match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: ::tokio_shim::task::JoinHandle<(Result<crate::services::base_service::GetStatusExn, _>, _)> = ::tokio_shim::task::spawn_blocking(move || {
                                  (::fbthrift::Deserialize::read(&mut p), p)
                                });
                                ::futures::future::Either::Right(exn.then(
                                    |exn| {
                                        let result = (move || {
                                            let (exn, mut p) = match exn {
                                                Ok(res) => res,
                                                Err(e) => {
                                                    // spawn_blocking threads can't be cancelled, so any
                                                    // error is a panic. This shouldn't happen, but we propagate if it does
                                                    ::std::panic::resume_unwind(e.into_panic())
                                                }
                                            };
                                            let exn = exn?;
                                            let result = match exn {
                                                crate::services::base_service::GetStatusExn::Success(x) => ::std::result::Result::Ok(x),
                                                crate::services::base_service::GetStatusExn::ApplicationException(ae) => {
                                                    ::std::result::Result::Err(crate::errors::base_service::GetStatusError::ApplicationException(ae))
                                                }
                                            };
                                            p.read_message_end()?;
                                            result
                                        })();
                                        ::futures::future::ready(result)
                                    }
                                ))
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::std::result::Result<::fbthrift::ApplicationException, _> = ::fbthrift::Deserialize::read(&mut p);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ae.map_err(|e| e.into()).and_then(|ae| {
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                              ::std::result::Result::Err(crate::errors::base_service::GetStatusError::ApplicationException(ae))
                                          }
                                        )
                                        })
                                    )
                                )
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                            ::std::result::Result::Err(crate::errors::base_service::GetStatusError::ThriftError(err))
                                          }
                                        )
                                    )
                                )
                            }
                        }
                    })(de)
                })
                .boxed()
        }
        fn getName(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetNameError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getName";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getName",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(SERVICE_NAME, METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| {
                    let de = P::deserializer(reply);
                    (move |mut p: P::Deserializer| {
                        use ::fbthrift::{ProtocolReader as _};
                        let (_, message_type, _) = match p.read_message_begin(|_| ()) {
                            Ok(res) => res,
                            Err(e) => return ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ::std::result::Result::Err(e.into())
                                    )
                                )
                        };
                        match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: ::tokio_shim::task::JoinHandle<(Result<crate::services::base_service::GetNameExn, _>, _)> = ::tokio_shim::task::spawn_blocking(move || {
                                  (::fbthrift::Deserialize::read(&mut p), p)
                                });
                                ::futures::future::Either::Right(exn.then(
                                    |exn| {
                                        let result = (move || {
                                            let (exn, mut p) = match exn {
                                                Ok(res) => res,
                                                Err(e) => {
                                                    // spawn_blocking threads can't be cancelled, so any
                                                    // error is a panic. This shouldn't happen, but we propagate if it does
                                                    ::std::panic::resume_unwind(e.into_panic())
                                                }
                                            };
                                            let exn = exn?;
                                            let result = match exn {
                                                crate::services::base_service::GetNameExn::Success(x) => ::std::result::Result::Ok(x),
                                                crate::services::base_service::GetNameExn::ApplicationException(ae) => {
                                                    ::std::result::Result::Err(crate::errors::base_service::GetNameError::ApplicationException(ae))
                                                }
                                            };
                                            p.read_message_end()?;
                                            result
                                        })();
                                        ::futures::future::ready(result)
                                    }
                                ))
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::std::result::Result<::fbthrift::ApplicationException, _> = ::fbthrift::Deserialize::read(&mut p);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ae.map_err(|e| e.into()).and_then(|ae| {
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                              ::std::result::Result::Err(crate::errors::base_service::GetNameError::ApplicationException(ae))
                                          }
                                        )
                                        })
                                    )
                                )
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                            ::std::result::Result::Err(crate::errors::base_service::GetNameError::ThriftError(err))
                                          }
                                        )
                                    )
                                )
                            }
                        }
                    })(de)
                })
                .boxed()
        }
        fn getVersion(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetVersionError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getVersion";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getVersion",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(SERVICE_NAME, METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| {
                    let de = P::deserializer(reply);
                    (move |mut p: P::Deserializer| {
                        use ::fbthrift::{ProtocolReader as _};
                        let (_, message_type, _) = match p.read_message_begin(|_| ()) {
                            Ok(res) => res,
                            Err(e) => return ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ::std::result::Result::Err(e.into())
                                    )
                                )
                        };
                        match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: ::tokio_shim::task::JoinHandle<(Result<crate::services::base_service::GetVersionExn, _>, _)> = ::tokio_shim::task::spawn_blocking(move || {
                                  (::fbthrift::Deserialize::read(&mut p), p)
                                });
                                ::futures::future::Either::Right(exn.then(
                                    |exn| {
                                        let result = (move || {
                                            let (exn, mut p) = match exn {
                                                Ok(res) => res,
                                                Err(e) => {
                                                    // spawn_blocking threads can't be cancelled, so any
                                                    // error is a panic. This shouldn't happen, but we propagate if it does
                                                    ::std::panic::resume_unwind(e.into_panic())
                                                }
                                            };
                                            let exn = exn?;
                                            let result = match exn {
                                                crate::services::base_service::GetVersionExn::Success(x) => ::std::result::Result::Ok(x),
                                                crate::services::base_service::GetVersionExn::ApplicationException(ae) => {
                                                    ::std::result::Result::Err(crate::errors::base_service::GetVersionError::ApplicationException(ae))
                                                }
                                            };
                                            p.read_message_end()?;
                                            result
                                        })();
                                        ::futures::future::ready(result)
                                    }
                                ))
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::std::result::Result<::fbthrift::ApplicationException, _> = ::fbthrift::Deserialize::read(&mut p);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ae.map_err(|e| e.into()).and_then(|ae| {
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                              ::std::result::Result::Err(crate::errors::base_service::GetVersionError::ApplicationException(ae))
                                          }
                                        )
                                        })
                                    )
                                )
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                            ::std::result::Result::Err(crate::errors::base_service::GetVersionError::ThriftError(err))
                                          }
                                        )
                                    )
                                )
                            }
                        }
                    })(de)
                })
                .boxed()
        }
        fn getStatusDetails(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetStatusDetailsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getStatusDetails";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getStatusDetails",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(SERVICE_NAME, METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| {
                    let de = P::deserializer(reply);
                    (move |mut p: P::Deserializer| {
                        use ::fbthrift::{ProtocolReader as _};
                        let (_, message_type, _) = match p.read_message_begin(|_| ()) {
                            Ok(res) => res,
                            Err(e) => return ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ::std::result::Result::Err(e.into())
                                    )
                                )
                        };
                        match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: ::tokio_shim::task::JoinHandle<(Result<crate::services::base_service::GetStatusDetailsExn, _>, _)> = ::tokio_shim::task::spawn_blocking(move || {
                                  (::fbthrift::Deserialize::read(&mut p), p)
                                });
                                ::futures::future::Either::Right(exn.then(
                                    |exn| {
                                        let result = (move || {
                                            let (exn, mut p) = match exn {
                                                Ok(res) => res,
                                                Err(e) => {
                                                    // spawn_blocking threads can't be cancelled, so any
                                                    // error is a panic. This shouldn't happen, but we propagate if it does
                                                    ::std::panic::resume_unwind(e.into_panic())
                                                }
                                            };
                                            let exn = exn?;
                                            let result = match exn {
                                                crate::services::base_service::GetStatusDetailsExn::Success(x) => ::std::result::Result::Ok(x),
                                                crate::services::base_service::GetStatusDetailsExn::ApplicationException(ae) => {
                                                    ::std::result::Result::Err(crate::errors::base_service::GetStatusDetailsError::ApplicationException(ae))
                                                }
                                            };
                                            p.read_message_end()?;
                                            result
                                        })();
                                        ::futures::future::ready(result)
                                    }
                                ))
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::std::result::Result<::fbthrift::ApplicationException, _> = ::fbthrift::Deserialize::read(&mut p);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ae.map_err(|e| e.into()).and_then(|ae| {
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                              ::std::result::Result::Err(crate::errors::base_service::GetStatusDetailsError::ApplicationException(ae))
                                          }
                                        )
                                        })
                                    )
                                )
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                            ::std::result::Result::Err(crate::errors::base_service::GetStatusDetailsError::ThriftError(err))
                                          }
                                        )
                                    )
                                )
                            }
                        }
                    })(de)
                })
                .boxed()
        }
        fn getCounters(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetCountersError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getCounters";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getCounters",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(SERVICE_NAME, METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| {
                    let de = P::deserializer(reply);
                    (move |mut p: P::Deserializer| {
                        use ::fbthrift::{ProtocolReader as _};
                        let (_, message_type, _) = match p.read_message_begin(|_| ()) {
                            Ok(res) => res,
                            Err(e) => return ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ::std::result::Result::Err(e.into())
                                    )
                                )
                        };
                        match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: ::tokio_shim::task::JoinHandle<(Result<crate::services::base_service::GetCountersExn, _>, _)> = ::tokio_shim::task::spawn_blocking(move || {
                                  (::fbthrift::Deserialize::read(&mut p), p)
                                });
                                ::futures::future::Either::Right(exn.then(
                                    |exn| {
                                        let result = (move || {
                                            let (exn, mut p) = match exn {
                                                Ok(res) => res,
                                                Err(e) => {
                                                    // spawn_blocking threads can't be cancelled, so any
                                                    // error is a panic. This shouldn't happen, but we propagate if it does
                                                    ::std::panic::resume_unwind(e.into_panic())
                                                }
                                            };
                                            let exn = exn?;
                                            let result = match exn {
                                                crate::services::base_service::GetCountersExn::Success(x) => ::std::result::Result::Ok(x),
                                                crate::services::base_service::GetCountersExn::ApplicationException(ae) => {
                                                    ::std::result::Result::Err(crate::errors::base_service::GetCountersError::ApplicationException(ae))
                                                }
                                            };
                                            p.read_message_end()?;
                                            result
                                        })();
                                        ::futures::future::ready(result)
                                    }
                                ))
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::std::result::Result<::fbthrift::ApplicationException, _> = ::fbthrift::Deserialize::read(&mut p);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ae.map_err(|e| e.into()).and_then(|ae| {
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                              ::std::result::Result::Err(crate::errors::base_service::GetCountersError::ApplicationException(ae))
                                          }
                                        )
                                        })
                                    )
                                )
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                            ::std::result::Result::Err(crate::errors::base_service::GetCountersError::ThriftError(err))
                                          }
                                        )
                                    )
                                )
                            }
                        }
                    })(de)
                })
                .boxed()
        }
        fn getRegexCounters(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetRegexCountersError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getRegexCounters";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getRegexCounters",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_regex", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_regex, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(SERVICE_NAME, METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| {
                    let de = P::deserializer(reply);
                    (move |mut p: P::Deserializer| {
                        use ::fbthrift::{ProtocolReader as _};
                        let (_, message_type, _) = match p.read_message_begin(|_| ()) {
                            Ok(res) => res,
                            Err(e) => return ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ::std::result::Result::Err(e.into())
                                    )
                                )
                        };
                        match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: ::tokio_shim::task::JoinHandle<(Result<crate::services::base_service::GetRegexCountersExn, _>, _)> = ::tokio_shim::task::spawn_blocking(move || {
                                  (::fbthrift::Deserialize::read(&mut p), p)
                                });
                                ::futures::future::Either::Right(exn.then(
                                    |exn| {
                                        let result = (move || {
                                            let (exn, mut p) = match exn {
                                                Ok(res) => res,
                                                Err(e) => {
                                                    // spawn_blocking threads can't be cancelled, so any
                                                    // error is a panic. This shouldn't happen, but we propagate if it does
                                                    ::std::panic::resume_unwind(e.into_panic())
                                                }
                                            };
                                            let exn = exn?;
                                            let result = match exn {
                                                crate::services::base_service::GetRegexCountersExn::Success(x) => ::std::result::Result::Ok(x),
                                                crate::services::base_service::GetRegexCountersExn::ApplicationException(ae) => {
                                                    ::std::result::Result::Err(crate::errors::base_service::GetRegexCountersError::ApplicationException(ae))
                                                }
                                            };
                                            p.read_message_end()?;
                                            result
                                        })();
                                        ::futures::future::ready(result)
                                    }
                                ))
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::std::result::Result<::fbthrift::ApplicationException, _> = ::fbthrift::Deserialize::read(&mut p);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ae.map_err(|e| e.into()).and_then(|ae| {
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                              ::std::result::Result::Err(crate::errors::base_service::GetRegexCountersError::ApplicationException(ae))
                                          }
                                        )
                                        })
                                    )
                                )
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                            ::std::result::Result::Err(crate::errors::base_service::GetRegexCountersError::ThriftError(err))
                                          }
                                        )
                                    )
                                )
                            }
                        }
                    })(de)
                })
                .boxed()
        }
        fn getSelectedCounters(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetSelectedCountersError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getSelectedCounters";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getSelectedCounters",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_keys", ::fbthrift::TType::List, 1i16);
                    ::fbthrift::Serialize::write(&arg_keys, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(SERVICE_NAME, METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| {
                    let de = P::deserializer(reply);
                    (move |mut p: P::Deserializer| {
                        use ::fbthrift::{ProtocolReader as _};
                        let (_, message_type, _) = match p.read_message_begin(|_| ()) {
                            Ok(res) => res,
                            Err(e) => return ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ::std::result::Result::Err(e.into())
                                    )
                                )
                        };
                        match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: ::tokio_shim::task::JoinHandle<(Result<crate::services::base_service::GetSelectedCountersExn, _>, _)> = ::tokio_shim::task::spawn_blocking(move || {
                                  (::fbthrift::Deserialize::read(&mut p), p)
                                });
                                ::futures::future::Either::Right(exn.then(
                                    |exn| {
                                        let result = (move || {
                                            let (exn, mut p) = match exn {
                                                Ok(res) => res,
                                                Err(e) => {
                                                    // spawn_blocking threads can't be cancelled, so any
                                                    // error is a panic. This shouldn't happen, but we propagate if it does
                                                    ::std::panic::resume_unwind(e.into_panic())
                                                }
                                            };
                                            let exn = exn?;
                                            let result = match exn {
                                                crate::services::base_service::GetSelectedCountersExn::Success(x) => ::std::result::Result::Ok(x),
                                                crate::services::base_service::GetSelectedCountersExn::ApplicationException(ae) => {
                                                    ::std::result::Result::Err(crate::errors::base_service::GetSelectedCountersError::ApplicationException(ae))
                                                }
                                            };
                                            p.read_message_end()?;
                                            result
                                        })();
                                        ::futures::future::ready(result)
                                    }
                                ))
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::std::result::Result<::fbthrift::ApplicationException, _> = ::fbthrift::Deserialize::read(&mut p);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ae.map_err(|e| e.into()).and_then(|ae| {
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                              ::std::result::Result::Err(crate::errors::base_service::GetSelectedCountersError::ApplicationException(ae))
                                          }
                                        )
                                        })
                                    )
                                )
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                            ::std::result::Result::Err(crate::errors::base_service::GetSelectedCountersError::ThriftError(err))
                                          }
                                        )
                                    )
                                )
                            }
                        }
                    })(de)
                })
                .boxed()
        }
        fn getCounter(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::GetCounterError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getCounter";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getCounter",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_key", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_key, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(SERVICE_NAME, METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| {
                    let de = P::deserializer(reply);
                    (move |mut p: P::Deserializer| {
                        use ::fbthrift::{ProtocolReader as _};
                        let (_, message_type, _) = match p.read_message_begin(|_| ()) {
                            Ok(res) => res,
                            Err(e) => return ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ::std::result::Result::Err(e.into())
                                    )
                                )
                        };
                        match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: ::tokio_shim::task::JoinHandle<(Result<crate::services::base_service::GetCounterExn, _>, _)> = ::tokio_shim::task::spawn_blocking(move || {
                                  (::fbthrift::Deserialize::read(&mut p), p)
                                });
                                ::futures::future::Either::Right(exn.then(
                                    |exn| {
                                        let result = (move || {
                                            let (exn, mut p) = match exn {
                                                Ok(res) => res,
                                                Err(e) => {
                                                    // spawn_blocking threads can't be cancelled, so any
                                                    // error is a panic. This shouldn't happen, but we propagate if it does
                                                    ::std::panic::resume_unwind(e.into_panic())
                                                }
                                            };
                                            let exn = exn?;
                                            let result = match exn {
                                                crate::services::base_service::GetCounterExn::Success(x) => ::std::result::Result::Ok(x),
                                                crate::services::base_service::GetCounterExn::ApplicationException(ae) => {
                                                    ::std::result::Result::Err(crate::errors::base_service::GetCounterError::ApplicationException(ae))
                                                }
                                            };
                                            p.read_message_end()?;
                                            result
                                        })();
                                        ::futures::future::ready(result)
                                    }
                                ))
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::std::result::Result<::fbthrift::ApplicationException, _> = ::fbthrift::Deserialize::read(&mut p);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ae.map_err(|e| e.into()).and_then(|ae| {
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                              ::std::result::Result::Err(crate::errors::base_service::GetCounterError::ApplicationException(ae))
                                          }
                                        )
                                        })
                                    )
                                )
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                            ::std::result::Result::Err(crate::errors::base_service::GetCounterError::ThriftError(err))
                                          }
                                        )
                                    )
                                )
                            }
                        }
                    })(de)
                })
                .boxed()
        }
        fn getExportedValues(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetExportedValuesError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getExportedValues";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getExportedValues",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(SERVICE_NAME, METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| {
                    let de = P::deserializer(reply);
                    (move |mut p: P::Deserializer| {
                        use ::fbthrift::{ProtocolReader as _};
                        let (_, message_type, _) = match p.read_message_begin(|_| ()) {
                            Ok(res) => res,
                            Err(e) => return ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ::std::result::Result::Err(e.into())
                                    )
                                )
                        };
                        match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: ::tokio_shim::task::JoinHandle<(Result<crate::services::base_service::GetExportedValuesExn, _>, _)> = ::tokio_shim::task::spawn_blocking(move || {
                                  (::fbthrift::Deserialize::read(&mut p), p)
                                });
                                ::futures::future::Either::Right(exn.then(
                                    |exn| {
                                        let result = (move || {
                                            let (exn, mut p) = match exn {
                                                Ok(res) => res,
                                                Err(e) => {
                                                    // spawn_blocking threads can't be cancelled, so any
                                                    // error is a panic. This shouldn't happen, but we propagate if it does
                                                    ::std::panic::resume_unwind(e.into_panic())
                                                }
                                            };
                                            let exn = exn?;
                                            let result = match exn {
                                                crate::services::base_service::GetExportedValuesExn::Success(x) => ::std::result::Result::Ok(x),
                                                crate::services::base_service::GetExportedValuesExn::ApplicationException(ae) => {
                                                    ::std::result::Result::Err(crate::errors::base_service::GetExportedValuesError::ApplicationException(ae))
                                                }
                                            };
                                            p.read_message_end()?;
                                            result
                                        })();
                                        ::futures::future::ready(result)
                                    }
                                ))
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::std::result::Result<::fbthrift::ApplicationException, _> = ::fbthrift::Deserialize::read(&mut p);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ae.map_err(|e| e.into()).and_then(|ae| {
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                              ::std::result::Result::Err(crate::errors::base_service::GetExportedValuesError::ApplicationException(ae))
                                          }
                                        )
                                        })
                                    )
                                )
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                            ::std::result::Result::Err(crate::errors::base_service::GetExportedValuesError::ThriftError(err))
                                          }
                                        )
                                    )
                                )
                            }
                        }
                    })(de)
                })
                .boxed()
        }
        fn getSelectedExportedValues(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetSelectedExportedValuesError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getSelectedExportedValues";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getSelectedExportedValues",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_keys", ::fbthrift::TType::List, 1i16);
                    ::fbthrift::Serialize::write(&arg_keys, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(SERVICE_NAME, METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| {
                    let de = P::deserializer(reply);
                    (move |mut p: P::Deserializer| {
                        use ::fbthrift::{ProtocolReader as _};
                        let (_, message_type, _) = match p.read_message_begin(|_| ()) {
                            Ok(res) => res,
                            Err(e) => return ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ::std::result::Result::Err(e.into())
                                    )
                                )
                        };
                        match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: ::tokio_shim::task::JoinHandle<(Result<crate::services::base_service::GetSelectedExportedValuesExn, _>, _)> = ::tokio_shim::task::spawn_blocking(move || {
                                  (::fbthrift::Deserialize::read(&mut p), p)
                                });
                                ::futures::future::Either::Right(exn.then(
                                    |exn| {
                                        let result = (move || {
                                            let (exn, mut p) = match exn {
                                                Ok(res) => res,
                                                Err(e) => {
                                                    // spawn_blocking threads can't be cancelled, so any
                                                    // error is a panic. This shouldn't happen, but we propagate if it does
                                                    ::std::panic::resume_unwind(e.into_panic())
                                                }
                                            };
                                            let exn = exn?;
                                            let result = match exn {
                                                crate::services::base_service::GetSelectedExportedValuesExn::Success(x) => ::std::result::Result::Ok(x),
                                                crate::services::base_service::GetSelectedExportedValuesExn::ApplicationException(ae) => {
                                                    ::std::result::Result::Err(crate::errors::base_service::GetSelectedExportedValuesError::ApplicationException(ae))
                                                }
                                            };
                                            p.read_message_end()?;
                                            result
                                        })();
                                        ::futures::future::ready(result)
                                    }
                                ))
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::std::result::Result<::fbthrift::ApplicationException, _> = ::fbthrift::Deserialize::read(&mut p);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ae.map_err(|e| e.into()).and_then(|ae| {
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                              ::std::result::Result::Err(crate::errors::base_service::GetSelectedExportedValuesError::ApplicationException(ae))
                                          }
                                        )
                                        })
                                    )
                                )
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                            ::std::result::Result::Err(crate::errors::base_service::GetSelectedExportedValuesError::ThriftError(err))
                                          }
                                        )
                                    )
                                )
                            }
                        }
                    })(de)
                })
                .boxed()
        }
        fn getRegexExportedValues(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetRegexExportedValuesError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getRegexExportedValues";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getRegexExportedValues",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_regex", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_regex, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(SERVICE_NAME, METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| {
                    let de = P::deserializer(reply);
                    (move |mut p: P::Deserializer| {
                        use ::fbthrift::{ProtocolReader as _};
                        let (_, message_type, _) = match p.read_message_begin(|_| ()) {
                            Ok(res) => res,
                            Err(e) => return ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ::std::result::Result::Err(e.into())
                                    )
                                )
                        };
                        match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: ::tokio_shim::task::JoinHandle<(Result<crate::services::base_service::GetRegexExportedValuesExn, _>, _)> = ::tokio_shim::task::spawn_blocking(move || {
                                  (::fbthrift::Deserialize::read(&mut p), p)
                                });
                                ::futures::future::Either::Right(exn.then(
                                    |exn| {
                                        let result = (move || {
                                            let (exn, mut p) = match exn {
                                                Ok(res) => res,
                                                Err(e) => {
                                                    // spawn_blocking threads can't be cancelled, so any
                                                    // error is a panic. This shouldn't happen, but we propagate if it does
                                                    ::std::panic::resume_unwind(e.into_panic())
                                                }
                                            };
                                            let exn = exn?;
                                            let result = match exn {
                                                crate::services::base_service::GetRegexExportedValuesExn::Success(x) => ::std::result::Result::Ok(x),
                                                crate::services::base_service::GetRegexExportedValuesExn::ApplicationException(ae) => {
                                                    ::std::result::Result::Err(crate::errors::base_service::GetRegexExportedValuesError::ApplicationException(ae))
                                                }
                                            };
                                            p.read_message_end()?;
                                            result
                                        })();
                                        ::futures::future::ready(result)
                                    }
                                ))
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::std::result::Result<::fbthrift::ApplicationException, _> = ::fbthrift::Deserialize::read(&mut p);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ae.map_err(|e| e.into()).and_then(|ae| {
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                              ::std::result::Result::Err(crate::errors::base_service::GetRegexExportedValuesError::ApplicationException(ae))
                                          }
                                        )
                                        })
                                    )
                                )
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                            ::std::result::Result::Err(crate::errors::base_service::GetRegexExportedValuesError::ThriftError(err))
                                          }
                                        )
                                    )
                                )
                            }
                        }
                    })(de)
                })
                .boxed()
        }
        fn getExportedValue(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetExportedValueError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getExportedValue";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getExportedValue",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_key", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_key, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(SERVICE_NAME, METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| {
                    let de = P::deserializer(reply);
                    (move |mut p: P::Deserializer| {
                        use ::fbthrift::{ProtocolReader as _};
                        let (_, message_type, _) = match p.read_message_begin(|_| ()) {
                            Ok(res) => res,
                            Err(e) => return ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ::std::result::Result::Err(e.into())
                                    )
                                )
                        };
                        match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: ::tokio_shim::task::JoinHandle<(Result<crate::services::base_service::GetExportedValueExn, _>, _)> = ::tokio_shim::task::spawn_blocking(move || {
                                  (::fbthrift::Deserialize::read(&mut p), p)
                                });
                                ::futures::future::Either::Right(exn.then(
                                    |exn| {
                                        let result = (move || {
                                            let (exn, mut p) = match exn {
                                                Ok(res) => res,
                                                Err(e) => {
                                                    // spawn_blocking threads can't be cancelled, so any
                                                    // error is a panic. This shouldn't happen, but we propagate if it does
                                                    ::std::panic::resume_unwind(e.into_panic())
                                                }
                                            };
                                            let exn = exn?;
                                            let result = match exn {
                                                crate::services::base_service::GetExportedValueExn::Success(x) => ::std::result::Result::Ok(x),
                                                crate::services::base_service::GetExportedValueExn::ApplicationException(ae) => {
                                                    ::std::result::Result::Err(crate::errors::base_service::GetExportedValueError::ApplicationException(ae))
                                                }
                                            };
                                            p.read_message_end()?;
                                            result
                                        })();
                                        ::futures::future::ready(result)
                                    }
                                ))
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::std::result::Result<::fbthrift::ApplicationException, _> = ::fbthrift::Deserialize::read(&mut p);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ae.map_err(|e| e.into()).and_then(|ae| {
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                              ::std::result::Result::Err(crate::errors::base_service::GetExportedValueError::ApplicationException(ae))
                                          }
                                        )
                                        })
                                    )
                                )
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                            ::std::result::Result::Err(crate::errors::base_service::GetExportedValueError::ThriftError(err))
                                          }
                                        )
                                    )
                                )
                            }
                        }
                    })(de)
                })
                .boxed()
        }
        fn setOption(
            &self,
            arg_key: &::std::primitive::str,
            arg_value: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::base_service::SetOptionError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.setOption";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "setOption",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_key", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_key, p);
                    p.write_field_end();
                    p.write_field_begin("arg_value", ::fbthrift::TType::String, 2i16);
                    ::fbthrift::Serialize::write(&arg_value, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(SERVICE_NAME, METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| {
                    let de = P::deserializer(reply);
                    (move |mut p: P::Deserializer| {
                        use ::fbthrift::{ProtocolReader as _};
                        let (_, message_type, _) = match p.read_message_begin(|_| ()) {
                            Ok(res) => res,
                            Err(e) => return ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ::std::result::Result::Err(e.into())
                                    )
                                )
                        };
                        match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: ::tokio_shim::task::JoinHandle<(Result<crate::services::base_service::SetOptionExn, _>, _)> = ::tokio_shim::task::spawn_blocking(move || {
                                  (::fbthrift::Deserialize::read(&mut p), p)
                                });
                                ::futures::future::Either::Right(exn.then(
                                    |exn| {
                                        let result = (move || {
                                            let (exn, mut p) = match exn {
                                                Ok(res) => res,
                                                Err(e) => {
                                                    // spawn_blocking threads can't be cancelled, so any
                                                    // error is a panic. This shouldn't happen, but we propagate if it does
                                                    ::std::panic::resume_unwind(e.into_panic())
                                                }
                                            };
                                            let exn = exn?;
                                            let result = match exn {
                                                crate::services::base_service::SetOptionExn::Success(x) => ::std::result::Result::Ok(x),
                                                crate::services::base_service::SetOptionExn::ApplicationException(ae) => {
                                                    ::std::result::Result::Err(crate::errors::base_service::SetOptionError::ApplicationException(ae))
                                                }
                                            };
                                            p.read_message_end()?;
                                            result
                                        })();
                                        ::futures::future::ready(result)
                                    }
                                ))
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::std::result::Result<::fbthrift::ApplicationException, _> = ::fbthrift::Deserialize::read(&mut p);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ae.map_err(|e| e.into()).and_then(|ae| {
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                              ::std::result::Result::Err(crate::errors::base_service::SetOptionError::ApplicationException(ae))
                                          }
                                        )
                                        })
                                    )
                                )
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                            ::std::result::Result::Err(crate::errors::base_service::SetOptionError::ThriftError(err))
                                          }
                                        )
                                    )
                                )
                            }
                        }
                    })(de)
                })
                .boxed()
        }
        fn getOption(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetOptionError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getOption";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getOption",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_key", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_key, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(SERVICE_NAME, METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| {
                    let de = P::deserializer(reply);
                    (move |mut p: P::Deserializer| {
                        use ::fbthrift::{ProtocolReader as _};
                        let (_, message_type, _) = match p.read_message_begin(|_| ()) {
                            Ok(res) => res,
                            Err(e) => return ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ::std::result::Result::Err(e.into())
                                    )
                                )
                        };
                        match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: ::tokio_shim::task::JoinHandle<(Result<crate::services::base_service::GetOptionExn, _>, _)> = ::tokio_shim::task::spawn_blocking(move || {
                                  (::fbthrift::Deserialize::read(&mut p), p)
                                });
                                ::futures::future::Either::Right(exn.then(
                                    |exn| {
                                        let result = (move || {
                                            let (exn, mut p) = match exn {
                                                Ok(res) => res,
                                                Err(e) => {
                                                    // spawn_blocking threads can't be cancelled, so any
                                                    // error is a panic. This shouldn't happen, but we propagate if it does
                                                    ::std::panic::resume_unwind(e.into_panic())
                                                }
                                            };
                                            let exn = exn?;
                                            let result = match exn {
                                                crate::services::base_service::GetOptionExn::Success(x) => ::std::result::Result::Ok(x),
                                                crate::services::base_service::GetOptionExn::ApplicationException(ae) => {
                                                    ::std::result::Result::Err(crate::errors::base_service::GetOptionError::ApplicationException(ae))
                                                }
                                            };
                                            p.read_message_end()?;
                                            result
                                        })();
                                        ::futures::future::ready(result)
                                    }
                                ))
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::std::result::Result<::fbthrift::ApplicationException, _> = ::fbthrift::Deserialize::read(&mut p);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ae.map_err(|e| e.into()).and_then(|ae| {
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                              ::std::result::Result::Err(crate::errors::base_service::GetOptionError::ApplicationException(ae))
                                          }
                                        )
                                        })
                                    )
                                )
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                            ::std::result::Result::Err(crate::errors::base_service::GetOptionError::ThriftError(err))
                                          }
                                        )
                                    )
                                )
                            }
                        }
                    })(de)
                })
                .boxed()
        }
        fn getOptions(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetOptionsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getOptions";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getOptions",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(SERVICE_NAME, METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| {
                    let de = P::deserializer(reply);
                    (move |mut p: P::Deserializer| {
                        use ::fbthrift::{ProtocolReader as _};
                        let (_, message_type, _) = match p.read_message_begin(|_| ()) {
                            Ok(res) => res,
                            Err(e) => return ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ::std::result::Result::Err(e.into())
                                    )
                                )
                        };
                        match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: ::tokio_shim::task::JoinHandle<(Result<crate::services::base_service::GetOptionsExn, _>, _)> = ::tokio_shim::task::spawn_blocking(move || {
                                  (::fbthrift::Deserialize::read(&mut p), p)
                                });
                                ::futures::future::Either::Right(exn.then(
                                    |exn| {
                                        let result = (move || {
                                            let (exn, mut p) = match exn {
                                                Ok(res) => res,
                                                Err(e) => {
                                                    // spawn_blocking threads can't be cancelled, so any
                                                    // error is a panic. This shouldn't happen, but we propagate if it does
                                                    ::std::panic::resume_unwind(e.into_panic())
                                                }
                                            };
                                            let exn = exn?;
                                            let result = match exn {
                                                crate::services::base_service::GetOptionsExn::Success(x) => ::std::result::Result::Ok(x),
                                                crate::services::base_service::GetOptionsExn::ApplicationException(ae) => {
                                                    ::std::result::Result::Err(crate::errors::base_service::GetOptionsError::ApplicationException(ae))
                                                }
                                            };
                                            p.read_message_end()?;
                                            result
                                        })();
                                        ::futures::future::ready(result)
                                    }
                                ))
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::std::result::Result<::fbthrift::ApplicationException, _> = ::fbthrift::Deserialize::read(&mut p);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ae.map_err(|e| e.into()).and_then(|ae| {
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                              ::std::result::Result::Err(crate::errors::base_service::GetOptionsError::ApplicationException(ae))
                                          }
                                        )
                                        })
                                    )
                                )
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                            ::std::result::Result::Err(crate::errors::base_service::GetOptionsError::ThriftError(err))
                                          }
                                        )
                                    )
                                )
                            }
                        }
                    })(de)
                })
                .boxed()
        }
        fn aliveSince(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::AliveSinceError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::fbthrift::{ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.aliveSince";
            }
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "aliveSince",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(SERVICE_NAME, METHOD_NAME, request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| {
                    let de = P::deserializer(reply);
                    (move |mut p: P::Deserializer| {
                        use ::fbthrift::{ProtocolReader as _};
                        let (_, message_type, _) = match p.read_message_begin(|_| ()) {
                            Ok(res) => res,
                            Err(e) => return ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ::std::result::Result::Err(e.into())
                                    )
                                )
                        };
                        match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: ::tokio_shim::task::JoinHandle<(Result<crate::services::base_service::AliveSinceExn, _>, _)> = ::tokio_shim::task::spawn_blocking(move || {
                                  (::fbthrift::Deserialize::read(&mut p), p)
                                });
                                ::futures::future::Either::Right(exn.then(
                                    |exn| {
                                        let result = (move || {
                                            let (exn, mut p) = match exn {
                                                Ok(res) => res,
                                                Err(e) => {
                                                    // spawn_blocking threads can't be cancelled, so any
                                                    // error is a panic. This shouldn't happen, but we propagate if it does
                                                    ::std::panic::resume_unwind(e.into_panic())
                                                }
                                            };
                                            let exn = exn?;
                                            let result = match exn {
                                                crate::services::base_service::AliveSinceExn::Success(x) => ::std::result::Result::Ok(x),
                                                crate::services::base_service::AliveSinceExn::ApplicationException(ae) => {
                                                    ::std::result::Result::Err(crate::errors::base_service::AliveSinceError::ApplicationException(ae))
                                                }
                                            };
                                            p.read_message_end()?;
                                            result
                                        })();
                                        ::futures::future::ready(result)
                                    }
                                ))
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::std::result::Result<::fbthrift::ApplicationException, _> = ::fbthrift::Deserialize::read(&mut p);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        ae.map_err(|e| e.into()).and_then(|ae| {
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                              ::std::result::Result::Err(crate::errors::base_service::AliveSinceError::ApplicationException(ae))
                                          }
                                        )
                                        })
                                    )
                                )
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::futures::future::Either::Left(
                                    ::futures::future::ready(
                                        p.read_message_end().map_err(|e| e.into()).and_then(
                                          |_| {
                                            ::std::result::Result::Err(crate::errors::base_service::AliveSinceError::ThriftError(err))
                                          }
                                        )
                                    )
                                )
                            }
                        }
                    })(de)
                })
                .boxed()
        }
    }

    impl<'a, T> BaseService for T
    where
        T: ::std::convert::AsRef<dyn BaseService + 'a>,
        T: ::std::marker::Send,
    {
        fn getStatus(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::fb303_status, crate::errors::base_service::GetStatusError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getStatus(
            )
        }
        fn getName(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetNameError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getName(
            )
        }
        fn getVersion(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetVersionError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getVersion(
            )
        }
        fn getStatusDetails(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetStatusDetailsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getStatusDetails(
            )
        }
        fn getCounters(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetCountersError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getCounters(
            )
        }
        fn getRegexCounters(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetRegexCountersError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getRegexCounters(
                arg_regex,
            )
        }
        fn getSelectedCounters(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetSelectedCountersError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getSelectedCounters(
                arg_keys,
            )
        }
        fn getCounter(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::GetCounterError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getCounter(
                arg_key,
            )
        }
        fn getExportedValues(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetExportedValuesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getExportedValues(
            )
        }
        fn getSelectedExportedValues(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetSelectedExportedValuesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getSelectedExportedValues(
                arg_keys,
            )
        }
        fn getRegexExportedValues(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetRegexExportedValuesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getRegexExportedValues(
                arg_regex,
            )
        }
        fn getExportedValue(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetExportedValueError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getExportedValue(
                arg_key,
            )
        }
        fn setOption(
            &self,
            arg_key: &::std::primitive::str,
            arg_value: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::base_service::SetOptionError>> + ::std::marker::Send + 'static>> {
            self.as_ref().setOption(
                arg_key,
                arg_value,
            )
        }
        fn getOption(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetOptionError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getOption(
                arg_key,
            )
        }
        fn getOptions(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetOptionsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getOptions(
            )
        }
        fn aliveSince(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::AliveSinceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().aliveSince(
            )
        }
    }

    #[derive(Clone)]
    pub struct make_BaseService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// # const _: &str = stringify! {
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = <dyn BuckGraphService>::new(protocol, transport);
    /// # };
    /// ```
    impl dyn BaseService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl BaseService + ::std::marker::Send + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
        {
            let _ = protocol;
            ::std::sync::Arc::new(BaseServiceImpl::<P, T>::new(transport))
        }
    }

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_BaseService {
        type Api = dyn BaseService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn new<P, T>(protocol: P, transport: T) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport + ::std::marker::Sync,
            P::Deserializer: ::std::marker::Send,
        {
            <dyn BaseService>::new(protocol, transport)
        }
    }
}


/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
/// ```thrift
/// service MyService {
///     FunctionResponse myFunction(
///         1: FunctionRequest request,
///     ) throws {
///         1: StorageException s,
///         2: NotFoundException n,
///     ),
///
///     // other functions
/// }
/// ```
///
/// we would end up with this mock object under crate::mock::MyService:
///
/// ```
/// # const _: &str = stringify! {
/// impl crate::client::MyService for MyService<'mock> {...}
///
/// pub struct MyService<'mock> {
///     pub myFunction: myFunction<'mock>,
///     // ...
/// }
///
/// impl dyn crate::client::MyService {
///     pub fn mock<'mock>() -> MyService<'mock>;
/// }
///
/// impl myFunction<'mock> {
///     // directly return the given success response
///     pub fn ret(&self, value: FunctionResponse);
///
///     // invoke closure to compute success response
///     pub fn mock(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///     );
///
///     // invoke closure to compute response
///     pub fn mock_result(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> Result<FunctionResponse, crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock,
///     );
///
///     // return one of the function's declared exceptions
///     pub fn throw<E>(&self, exception: E)
///     where
///         E: Clone + Into<crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
/// }
///
/// impl From<StorageException> for MyFunctionExn {...}
/// impl From<NotFoundException> for MyFunctionExn {...}
/// # };
/// ```
///
/// The intended usage from a test would be:
///
/// ```
/// # const _: &str = stringify! {
/// use std::sync::Arc;
/// use thrift_if::client::MyService;
///
/// #[test]
/// fn test_my_client() {
///     let mock = Arc::new(<dyn MyService>::mock());
///
///     // directly return a success response
///     let resp = FunctionResponse {...};
///     mock.myFunction.ret(resp);
///
///     // or give a closure to compute the success response
///     mock.myFunction.mock(|request| FunctionResponse {...});
///
///     // or throw one of the function's exceptions
///     mock.myFunction.throw(StorageException::ItFailed);
///
///     // or compute a Result (useful if your exceptions aren't Clone)
///     mock.myFunction.mock_result(|request| Err(...));
///
///     let out = do_the_thing(mock).wait().unwrap();
///     assert!(out.what_i_expected());
/// }
///
/// fn do_the_thing(
///     client: Arc<dyn MyService + Send + Sync + 'static>,
/// ) -> impl Future<Item = Out> {...}
/// # };
/// ```
pub mod mock {
    pub struct BaseService<'mock> {
        pub getStatus: r#impl::base_service::getStatus<'mock>,
        pub getName: r#impl::base_service::getName<'mock>,
        pub getVersion: r#impl::base_service::getVersion<'mock>,
        pub getStatusDetails: r#impl::base_service::getStatusDetails<'mock>,
        pub getCounters: r#impl::base_service::getCounters<'mock>,
        pub getRegexCounters: r#impl::base_service::getRegexCounters<'mock>,
        pub getSelectedCounters: r#impl::base_service::getSelectedCounters<'mock>,
        pub getCounter: r#impl::base_service::getCounter<'mock>,
        pub getExportedValues: r#impl::base_service::getExportedValues<'mock>,
        pub getSelectedExportedValues: r#impl::base_service::getSelectedExportedValues<'mock>,
        pub getRegexExportedValues: r#impl::base_service::getRegexExportedValues<'mock>,
        pub getExportedValue: r#impl::base_service::getExportedValue<'mock>,
        pub setOption: r#impl::base_service::setOption<'mock>,
        pub getOption: r#impl::base_service::getOption<'mock>,
        pub getOptions: r#impl::base_service::getOptions<'mock>,
        pub aliveSince: r#impl::base_service::aliveSince<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::BaseService {
        pub fn mock<'mock>() -> BaseService<'mock> {
            BaseService {
                getStatus: r#impl::base_service::getStatus::unimplemented(),
                getName: r#impl::base_service::getName::unimplemented(),
                getVersion: r#impl::base_service::getVersion::unimplemented(),
                getStatusDetails: r#impl::base_service::getStatusDetails::unimplemented(),
                getCounters: r#impl::base_service::getCounters::unimplemented(),
                getRegexCounters: r#impl::base_service::getRegexCounters::unimplemented(),
                getSelectedCounters: r#impl::base_service::getSelectedCounters::unimplemented(),
                getCounter: r#impl::base_service::getCounter::unimplemented(),
                getExportedValues: r#impl::base_service::getExportedValues::unimplemented(),
                getSelectedExportedValues: r#impl::base_service::getSelectedExportedValues::unimplemented(),
                getRegexExportedValues: r#impl::base_service::getRegexExportedValues::unimplemented(),
                getExportedValue: r#impl::base_service::getExportedValue::unimplemented(),
                setOption: r#impl::base_service::setOption::unimplemented(),
                getOption: r#impl::base_service::getOption::unimplemented(),
                getOptions: r#impl::base_service::getOptions::unimplemented(),
                aliveSince: r#impl::base_service::aliveSince::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    #[::async_trait::async_trait]
    impl<'mock> super::client::BaseService for BaseService<'mock> {
        fn getStatus(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::fb303_status, crate::errors::base_service::GetStatusError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getName(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetNameError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getName.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getVersion(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetVersionError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getVersion.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getStatusDetails(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetStatusDetailsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getStatusDetails.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getCounters(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetCountersError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getCounters.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getRegexCounters(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetRegexCountersError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getRegexCounters.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_regex.to_owned())))
        }
        fn getSelectedCounters(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetSelectedCountersError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getSelectedCounters.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_keys.to_owned())))
        }
        fn getCounter(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::GetCounterError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getCounter.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_key.to_owned())))
        }
        fn getExportedValues(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetExportedValuesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getExportedValues.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getSelectedExportedValues(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetSelectedExportedValuesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getSelectedExportedValues.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_keys.to_owned())))
        }
        fn getRegexExportedValues(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetRegexExportedValuesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getRegexExportedValues.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_regex.to_owned())))
        }
        fn getExportedValue(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetExportedValueError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getExportedValue.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_key.to_owned())))
        }
        fn setOption(
            &self,
            arg_key: &::std::primitive::str,
            arg_value: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::base_service::SetOptionError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.setOption.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String, ::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_key.to_owned(), arg_value.to_owned())))
        }
        fn getOption(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetOptionError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getOption.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_key.to_owned())))
        }
        fn getOptions(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetOptionsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getOptions.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn aliveSince(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::AliveSinceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.aliveSince.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
    }

    mod r#impl {
        pub mod base_service {

            pub struct getStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        crate::types::fb303_status,
                        crate::errors::base_service::GetStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getStatus<'mock> {
                pub fn unimplemented() -> Self {
                    getStatus {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::fb303_status) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> crate::types::fb303_status + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<crate::types::fb303_status, crate::errors::base_service::GetStatusError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getName<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::string::String,
                        crate::errors::base_service::GetNameError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getName<'mock> {
                pub fn unimplemented() -> Self {
                    getName {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getName",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::string::String) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::string::String + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::string::String, crate::errors::base_service::GetNameError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetNameError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getVersion<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::string::String,
                        crate::errors::base_service::GetVersionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getVersion<'mock> {
                pub fn unimplemented() -> Self {
                    getVersion {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getVersion",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::string::String) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::string::String + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::string::String, crate::errors::base_service::GetVersionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetVersionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getStatusDetails<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::string::String,
                        crate::errors::base_service::GetStatusDetailsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getStatusDetails<'mock> {
                pub fn unimplemented() -> Self {
                    getStatusDetails {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getStatusDetails",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::string::String) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::string::String + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::string::String, crate::errors::base_service::GetStatusDetailsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetStatusDetailsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getCounters<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>,
                        crate::errors::base_service::GetCountersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getCounters<'mock> {
                pub fn unimplemented() -> Self {
                    getCounters {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getCounters",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetCountersError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetCountersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getRegexCounters<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>,
                        crate::errors::base_service::GetRegexCountersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getRegexCounters<'mock> {
                pub fn unimplemented() -> Self {
                    getRegexCounters {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getRegexCounters",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |regex| ::std::result::Result::Ok(mock(regex)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetRegexCountersError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |regex| mock(regex));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetRegexCountersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSelectedCounters<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>,
                        crate::errors::base_service::GetSelectedCountersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getSelectedCounters<'mock> {
                pub fn unimplemented() -> Self {
                    getSelectedCounters {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::vec::Vec<::std::string::String>| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getSelectedCounters",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>) {
                    self.mock(move |_: ::std::vec::Vec<::std::string::String>| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |keys| ::std::result::Result::Ok(mock(keys)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetSelectedCountersError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |keys| mock(keys));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetSelectedCountersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::vec::Vec<::std::string::String>| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getCounter<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        ::std::primitive::i64,
                        crate::errors::base_service::GetCounterError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getCounter<'mock> {
                pub fn unimplemented() -> Self {
                    getCounter {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getCounter",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::primitive::i64) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::primitive::i64 + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key| ::std::result::Result::Ok(mock(key)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<::std::primitive::i64, crate::errors::base_service::GetCounterError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key| mock(key));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetCounterError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getExportedValues<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
                        crate::errors::base_service::GetExportedValuesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getExportedValues<'mock> {
                pub fn unimplemented() -> Self {
                    getExportedValues {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getExportedValues",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetExportedValuesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetExportedValuesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSelectedExportedValues<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
                        crate::errors::base_service::GetSelectedExportedValuesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getSelectedExportedValues<'mock> {
                pub fn unimplemented() -> Self {
                    getSelectedExportedValues {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::vec::Vec<::std::string::String>| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getSelectedExportedValues",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
                    self.mock(move |_: ::std::vec::Vec<::std::string::String>| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |keys| ::std::result::Result::Ok(mock(keys)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetSelectedExportedValuesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |keys| mock(keys));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetSelectedExportedValuesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::vec::Vec<::std::string::String>| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getRegexExportedValues<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
                        crate::errors::base_service::GetRegexExportedValuesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getRegexExportedValues<'mock> {
                pub fn unimplemented() -> Self {
                    getRegexExportedValues {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getRegexExportedValues",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |regex| ::std::result::Result::Ok(mock(regex)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetRegexExportedValuesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |regex| mock(regex));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetRegexExportedValuesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getExportedValue<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        ::std::string::String,
                        crate::errors::base_service::GetExportedValueError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getExportedValue<'mock> {
                pub fn unimplemented() -> Self {
                    getExportedValue {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getExportedValue",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::string::String) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::string::String + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key| ::std::result::Result::Ok(mock(key)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<::std::string::String, crate::errors::base_service::GetExportedValueError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key| mock(key));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetExportedValueError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct setOption<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String, ::std::string::String) -> ::std::result::Result<
                        (),
                        crate::errors::base_service::SetOptionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> setOption<'mock> {
                pub fn unimplemented() -> Self {
                    setOption {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String, _: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "setOption",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: ::std::string::String, _: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String, ::std::string::String) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key, value| ::std::result::Result::Ok(mock(key, value)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::string::String, ::std::string::String) -> ::std::result::Result<(), crate::errors::base_service::SetOptionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key, value| mock(key, value));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::SetOptionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String, _: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getOption<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        ::std::string::String,
                        crate::errors::base_service::GetOptionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getOption<'mock> {
                pub fn unimplemented() -> Self {
                    getOption {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getOption",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::string::String) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::string::String + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key| ::std::result::Result::Ok(mock(key)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<::std::string::String, crate::errors::base_service::GetOptionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key| mock(key));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetOptionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getOptions<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
                        crate::errors::base_service::GetOptionsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getOptions<'mock> {
                pub fn unimplemented() -> Self {
                    getOptions {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getOptions",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetOptionsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetOptionsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct aliveSince<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::primitive::i64,
                        crate::errors::base_service::AliveSinceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> aliveSince<'mock> {
                pub fn unimplemented() -> Self {
                    aliveSince {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "aliveSince",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::primitive::i64) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::primitive::i64 + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::primitive::i64, crate::errors::base_service::AliveSinceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::AliveSinceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
    }
}

/// Error return types.
pub mod errors {
    /// Errors for BaseService functions.
    pub mod base_service {

        pub type GetStatusError = ::fbthrift::NonthrowingFunctionError;

        pub type GetNameError = ::fbthrift::NonthrowingFunctionError;

        pub type GetVersionError = ::fbthrift::NonthrowingFunctionError;

        pub type GetStatusDetailsError = ::fbthrift::NonthrowingFunctionError;

        pub type GetCountersError = ::fbthrift::NonthrowingFunctionError;

        pub type GetRegexCountersError = ::fbthrift::NonthrowingFunctionError;

        pub type GetSelectedCountersError = ::fbthrift::NonthrowingFunctionError;

        pub type GetCounterError = ::fbthrift::NonthrowingFunctionError;

        pub type GetExportedValuesError = ::fbthrift::NonthrowingFunctionError;

        pub type GetSelectedExportedValuesError = ::fbthrift::NonthrowingFunctionError;

        pub type GetRegexExportedValuesError = ::fbthrift::NonthrowingFunctionError;

        pub type GetExportedValueError = ::fbthrift::NonthrowingFunctionError;

        pub type SetOptionError = ::fbthrift::NonthrowingFunctionError;

        pub type GetOptionError = ::fbthrift::NonthrowingFunctionError;

        pub type GetOptionsError = ::fbthrift::NonthrowingFunctionError;

        pub type AliveSinceError = ::fbthrift::NonthrowingFunctionError;

    }

}
