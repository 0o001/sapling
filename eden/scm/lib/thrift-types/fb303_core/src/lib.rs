// @generated by Thrift for fb303/thrift/fb303_core.thrift
// This file is probably not the place you want to edit!

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

extern crate serde;
pub use self::errors::*;
pub use self::types::*;

/// Thrift type definitions for `fb303_core`.
pub mod types {
    #![allow(clippy::redundant_closure)]


    #[doc = "Common status reporting mechanism across all services"]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct fb303_status(pub ::std::primitive::i32);

    impl fb303_status {
        pub const DEAD: Self = fb303_status(0i32);
        pub const STARTING: Self = fb303_status(1i32);
        pub const ALIVE: Self = fb303_status(2i32);
        pub const STOPPING: Self = fb303_status(3i32);
        pub const STOPPED: Self = fb303_status(4i32);
        pub const WARNING: Self = fb303_status(5i32);
    }

    impl ::fbthrift::ThriftEnum for fb303_status {
        fn enumerate() -> &'static [(fb303_status, &'static str)] {
            &[
                (fb303_status::DEAD, "DEAD"),
                (fb303_status::STARTING, "STARTING"),
                (fb303_status::ALIVE, "ALIVE"),
                (fb303_status::STOPPING, "STOPPING"),
                (fb303_status::STOPPED, "STOPPED"),
                (fb303_status::WARNING, "WARNING"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "DEAD",
                "STARTING",
                "ALIVE",
                "STOPPING",
                "STOPPED",
                "WARNING",
            ]
        }

        fn variant_values() -> &'static [fb303_status] {
            &[
                fb303_status::DEAD,
                fb303_status::STARTING,
                fb303_status::ALIVE,
                fb303_status::STOPPING,
                fb303_status::STOPPED,
                fb303_status::WARNING,
            ]
        }
    }

    impl ::std::default::Default for fb303_status {
        fn default() -> Self {
            fb303_status(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a fb303_status> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a fb303_status) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<fb303_status> for ::std::primitive::i32 {
        #[inline]
        fn from(x: fb303_status) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for fb303_status {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for fb303_status {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("DEAD", 0),
                ("STARTING", 1),
                ("ALIVE", 2),
                ("STOPPING", 3),
                ("STOPPED", 4),
                ("WARNING", 5),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for fb303_status {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "fb303_status::{}", self)
        }
    }

    impl ::std::str::FromStr for fb303_status {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ALIVE", 2),
                ("DEAD", 0),
                ("STARTING", 1),
                ("STOPPED", 4),
                ("STOPPING", 3),
                ("WARNING", 5),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "fb303_status").map(fb303_status)
        }
    }

    impl ::fbthrift::GetTType for fb303_status {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for fb303_status
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for fb303_status
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(fb303_status::from(p.read_i32()?))
        }
    }
}

#[doc(hidden)]
pub mod dependencies {
}

pub mod services {
    pub mod base_service {
        #![doc = "Standard base service interface.\n\nThis interface provides methods to get some service metadata that is common\nacross many services."]


        #[derive(Clone, Debug)]
        pub enum GetStatusExn {
            Success(crate::types::fb303_status),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetStatusExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetStatusExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetStatusExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetStatusExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetStatusExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetStatusExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetStatusExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetStatusExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetStatusExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetStatusExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetStatusExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetStatusExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetStatusExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetStatusExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetStatusExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetStatus");
                match self {
                    GetStatusExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I32,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetStatusExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetStatusExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::I32, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I32, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetStatusExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetNameExn {
            Success(::std::string::String),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetNameExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetNameExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetNameExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetNameExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetNameExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetNameExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetNameExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetNameExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetNameExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetNameExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetNameExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetNameExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetNameExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetNameExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetNameExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetName");
                match self {
                    GetNameExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetNameExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetNameExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::String, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetNameExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetNameExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetNameExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetVersionExn {
            Success(::std::string::String),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetVersionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetVersionExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetVersionExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetVersionExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetVersionExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetVersionExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetVersionExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetVersionExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetVersionExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetVersionExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetVersionExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetVersionExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetVersionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetVersionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetVersionExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetVersion");
                match self {
                    GetVersionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetVersionExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetVersionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::String, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetVersionExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetVersionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetVersionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetStatusDetailsExn {
            Success(::std::string::String),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetStatusDetailsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetStatusDetailsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetStatusDetailsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetStatusDetailsExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetStatusDetailsExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetStatusDetailsExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetStatusDetailsExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetStatusDetailsExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetStatusDetailsExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetStatusDetailsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetStatusDetailsExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetStatusDetailsExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetStatusDetailsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetStatusDetailsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetStatusDetailsExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetStatusDetails");
                match self {
                    GetStatusDetailsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetStatusDetailsExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetStatusDetailsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::String, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetStatusDetailsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetStatusDetailsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetStatusDetailsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetCountersExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetCountersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetCountersExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetCountersExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetCountersExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetCountersExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetCountersExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetCountersExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetCountersExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetCountersExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetCountersExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetCountersExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetCountersExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetCountersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetCountersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetCountersExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetCounters");
                match self {
                    GetCountersExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetCountersExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetCountersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Map, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetCountersExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetCountersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetCountersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetRegexCountersExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetRegexCountersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetRegexCountersExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetRegexCountersExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetRegexCountersExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetRegexCountersExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetRegexCountersExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetRegexCountersExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetRegexCountersExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetRegexCountersExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetRegexCountersExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetRegexCountersExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetRegexCountersExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetRegexCountersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetRegexCountersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetRegexCountersExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetRegexCounters");
                match self {
                    GetRegexCountersExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetRegexCountersExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetRegexCountersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Map, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetRegexCountersExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetRegexCountersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetRegexCountersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSelectedCountersExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetSelectedCountersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetSelectedCountersExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetSelectedCountersExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetSelectedCountersExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetSelectedCountersExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetSelectedCountersExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetSelectedCountersExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetSelectedCountersExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetSelectedCountersExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetSelectedCountersExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetSelectedCountersExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetSelectedCountersExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetSelectedCountersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetSelectedCountersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetSelectedCountersExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetSelectedCounters");
                match self {
                    GetSelectedCountersExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSelectedCountersExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetSelectedCountersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Map, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetSelectedCountersExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSelectedCountersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSelectedCountersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetCounterExn {
            Success(::std::primitive::i64),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetCounterExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetCounterExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetCounterExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetCounterExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetCounterExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetCounterExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetCounterExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetCounterExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetCounterExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetCounterExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetCounterExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetCounterExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetCounterExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetCounterExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetCounterExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetCounter");
                match self {
                    GetCounterExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetCounterExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetCounterExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::I64, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I64, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetCounterExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetCounterExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetCounterExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetExportedValuesExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::string::String>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetExportedValuesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetExportedValuesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetExportedValuesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetExportedValuesExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetExportedValuesExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetExportedValuesExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetExportedValuesExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetExportedValuesExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetExportedValuesExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetExportedValuesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetExportedValuesExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetExportedValuesExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetExportedValuesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetExportedValuesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetExportedValuesExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetExportedValues");
                match self {
                    GetExportedValuesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetExportedValuesExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetExportedValuesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Map, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetExportedValuesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetExportedValuesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetExportedValuesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSelectedExportedValuesExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::string::String>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetSelectedExportedValuesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetSelectedExportedValuesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetSelectedExportedValuesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetSelectedExportedValuesExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetSelectedExportedValuesExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetSelectedExportedValuesExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetSelectedExportedValuesExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetSelectedExportedValuesExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetSelectedExportedValuesExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetSelectedExportedValuesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetSelectedExportedValuesExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetSelectedExportedValuesExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetSelectedExportedValuesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetSelectedExportedValuesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetSelectedExportedValuesExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetSelectedExportedValues");
                match self {
                    GetSelectedExportedValuesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSelectedExportedValuesExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetSelectedExportedValuesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Map, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetSelectedExportedValuesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSelectedExportedValuesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSelectedExportedValuesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetRegexExportedValuesExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::string::String>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetRegexExportedValuesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetRegexExportedValuesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetRegexExportedValuesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetRegexExportedValuesExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetRegexExportedValuesExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetRegexExportedValuesExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetRegexExportedValuesExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetRegexExportedValuesExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetRegexExportedValuesExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetRegexExportedValuesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetRegexExportedValuesExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetRegexExportedValuesExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetRegexExportedValuesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetRegexExportedValuesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetRegexExportedValuesExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetRegexExportedValues");
                match self {
                    GetRegexExportedValuesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetRegexExportedValuesExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetRegexExportedValuesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Map, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetRegexExportedValuesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetRegexExportedValuesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetRegexExportedValuesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetExportedValueExn {
            Success(::std::string::String),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetExportedValueExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetExportedValueExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetExportedValueExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetExportedValueExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetExportedValueExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetExportedValueExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetExportedValueExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetExportedValueExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetExportedValueExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetExportedValueExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetExportedValueExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetExportedValueExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetExportedValueExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetExportedValueExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetExportedValueExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetExportedValue");
                match self {
                    GetExportedValueExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetExportedValueExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetExportedValueExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::String, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetExportedValueExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetExportedValueExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetExportedValueExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SetOptionExn {
            Success(()),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SetOptionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                SetOptionExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for SetOptionExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    SetOptionExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    SetOptionExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    SetOptionExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    SetOptionExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    SetOptionExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    SetOptionExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for SetOptionExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    SetOptionExn::Success(_) => ::fbthrift::ResultType::Return,
                    SetOptionExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for SetOptionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for SetOptionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let SetOptionExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("SetOption");
                match self {
                    SetOptionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SetOptionExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for SetOptionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = SetOptionExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = SetOptionExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SetOptionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetOptionExn {
            Success(::std::string::String),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetOptionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetOptionExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetOptionExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetOptionExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetOptionExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetOptionExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetOptionExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetOptionExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetOptionExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetOptionExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetOptionExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetOptionExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetOptionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetOptionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetOptionExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetOption");
                match self {
                    GetOptionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetOptionExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetOptionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::String, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetOptionExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetOptionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetOptionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetOptionsExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::string::String>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetOptionsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetOptionsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetOptionsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetOptionsExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetOptionsExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetOptionsExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetOptionsExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetOptionsExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetOptionsExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetOptionsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetOptionsExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetOptionsExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetOptionsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetOptionsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetOptionsExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetOptions");
                match self {
                    GetOptionsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetOptionsExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetOptionsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Map, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetOptionsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetOptionsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetOptionsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AliveSinceExn {
            Success(::std::primitive::i64),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AliveSinceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AliveSinceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AliveSinceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    AliveSinceExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    AliveSinceExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    AliveSinceExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    AliveSinceExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    AliveSinceExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    AliveSinceExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AliveSinceExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    AliveSinceExn::Success(_) => ::fbthrift::ResultType::Return,
                    AliveSinceExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for AliveSinceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AliveSinceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let AliveSinceExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AliveSince");
                match self {
                    AliveSinceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AliveSinceExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AliveSinceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::I64, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I64, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AliveSinceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AliveSinceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AliveSinceExn"),
                    )
                    .into(),
                )
            }
        }
    }
}

/// Client implementation for each service in `fb303_core`.
pub mod client {

    pub struct BaseServiceImpl<P, T, S> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> (P, S)>,
    }

    impl<P, T, S> BaseServiceImpl<P, T, S> {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }
    }

    #[doc = "Standard base service interface.\n\nThis interface provides methods to get some service metadata that is common\nacross many services."]
    pub trait BaseService: ::std::marker::Send {
        #[doc = "Gets the status of this service"]
        fn getStatus(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::fb303_status, crate::errors::base_service::GetStatusError>> + ::std::marker::Send + 'static>>;
        #[doc = "Returns a descriptive name of the service"]
        fn getName(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetNameError>> + ::std::marker::Send + 'static>>;
        #[doc = "Returns the version of the service"]
        fn getVersion(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetVersionError>> + ::std::marker::Send + 'static>>;
        #[doc = "User friendly description of status, such as why the service is in\nthe dead or warning state, or what is being started or stopped."]
        fn getStatusDetails(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetStatusDetailsError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets the counters for this service"]
        fn getCounters(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetCountersError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets a subset of counters which match a\nPerl Compatible Regular Expression for this service"]
        fn getRegexCounters(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetRegexCountersError>> + ::std::marker::Send + 'static>>;
        #[doc = "Get counter values for a specific list of keys.  Returns a map from\nkey to counter value; if a requested counter doesn't exist, it won't\nbe in the returned map."]
        fn getSelectedCounters(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetSelectedCountersError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets the value of a single counter"]
        fn getCounter(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::GetCounterError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets the exported string values for this service"]
        fn getExportedValues(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetExportedValuesError>> + ::std::marker::Send + 'static>>;
        #[doc = "Get exported strings for a specific list of keys.  Returns a map from\nkey to string value; if a requested key doesn't exist, it won't\nbe in the returned map."]
        fn getSelectedExportedValues(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetSelectedExportedValuesError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets a subset of exported values which match a\nPerl Compatible Regular Expression for this service"]
        fn getRegexExportedValues(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetRegexExportedValuesError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets the value of a single exported string"]
        fn getExportedValue(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetExportedValueError>> + ::std::marker::Send + 'static>>;
        #[doc = "Sets an option"]
        fn setOption(
            &self,
            arg_key: &::std::primitive::str,
            arg_value: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::base_service::SetOptionError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets an option"]
        fn getOption(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetOptionError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets all options"]
        fn getOptions(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetOptionsError>> + ::std::marker::Send + 'static>>;
        #[doc = "Returns the unix time that the server has been running since"]
        fn aliveSince(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::AliveSinceError>> + ::std::marker::Send + 'static>>;
    }

    struct Args_BaseService_getStatus<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_BaseService_getStatus<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "BaseService.getStatus"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_BaseService_getName<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_BaseService_getName<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "BaseService.getName"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_BaseService_getVersion<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_BaseService_getVersion<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "BaseService.getVersion"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_BaseService_getStatusDetails<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_BaseService_getStatusDetails<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "BaseService.getStatusDetails"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_BaseService_getCounters<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_BaseService_getCounters<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "BaseService.getCounters"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_BaseService_getRegexCounters<'a> {
        regex: &'a ::std::primitive::str,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_BaseService_getRegexCounters<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "BaseService.getRegexCounters"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("regex", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.regex, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_BaseService_getSelectedCounters<'a> {
        keys: &'a [::std::string::String],
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_BaseService_getSelectedCounters<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "BaseService.getSelectedCounters"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("keys", ::fbthrift::TType::List, 1i16);
            ::fbthrift::Serialize::write(&self.keys, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_BaseService_getCounter<'a> {
        key: &'a ::std::primitive::str,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_BaseService_getCounter<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "BaseService.getCounter"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("key", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.key, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_BaseService_getExportedValues<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_BaseService_getExportedValues<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "BaseService.getExportedValues"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_BaseService_getSelectedExportedValues<'a> {
        keys: &'a [::std::string::String],
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_BaseService_getSelectedExportedValues<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "BaseService.getSelectedExportedValues"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("keys", ::fbthrift::TType::List, 1i16);
            ::fbthrift::Serialize::write(&self.keys, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_BaseService_getRegexExportedValues<'a> {
        regex: &'a ::std::primitive::str,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_BaseService_getRegexExportedValues<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "BaseService.getRegexExportedValues"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("regex", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.regex, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_BaseService_getExportedValue<'a> {
        key: &'a ::std::primitive::str,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_BaseService_getExportedValue<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "BaseService.getExportedValue"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("key", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.key, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_BaseService_setOption<'a> {
        key: &'a ::std::primitive::str,
        value: &'a ::std::primitive::str,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_BaseService_setOption<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "BaseService.setOption"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("key", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.key, p);
            p.write_field_end();
            p.write_field_begin("value", ::fbthrift::TType::String, 2i16);
            ::fbthrift::Serialize::write(&self.value, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_BaseService_getOption<'a> {
        key: &'a ::std::primitive::str,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_BaseService_getOption<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "BaseService.getOption"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("key", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.key, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_BaseService_getOptions<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_BaseService_getOptions<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "BaseService.getOptions"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_BaseService_aliveSince<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_BaseService_aliveSince<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "BaseService.aliveSince"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P, T, S> BaseService for BaseServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        #[::tracing::instrument(name = "BaseService.getStatus", skip_all)]
        fn getStatus(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::fb303_status, crate::errors::base_service::GetStatusError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getStatus";
            }
            let args = self::Args_BaseService_getStatus {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getStatus", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "BaseService.getStatus"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::base_service::GetStatusExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::base_service::GetStatusError::ApplicationException(aexn))
                }
            }
            .boxed()
        }


        #[::tracing::instrument(name = "BaseService.getName", skip_all)]
        fn getName(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetNameError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getName";
            }
            let args = self::Args_BaseService_getName {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getName", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "BaseService.getName"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::base_service::GetNameExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::base_service::GetNameError::ApplicationException(aexn))
                }
            }
            .boxed()
        }


        #[::tracing::instrument(name = "BaseService.getVersion", skip_all)]
        fn getVersion(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetVersionError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getVersion";
            }
            let args = self::Args_BaseService_getVersion {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getVersion", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "BaseService.getVersion"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::base_service::GetVersionExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::base_service::GetVersionError::ApplicationException(aexn))
                }
            }
            .boxed()
        }


        #[::tracing::instrument(name = "BaseService.getStatusDetails", skip_all)]
        fn getStatusDetails(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetStatusDetailsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getStatusDetails";
            }
            let args = self::Args_BaseService_getStatusDetails {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getStatusDetails", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "BaseService.getStatusDetails"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::base_service::GetStatusDetailsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::base_service::GetStatusDetailsError::ApplicationException(aexn))
                }
            }
            .boxed()
        }


        #[::tracing::instrument(name = "BaseService.getCounters", skip_all)]
        fn getCounters(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetCountersError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getCounters";
            }
            let args = self::Args_BaseService_getCounters {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getCounters", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "BaseService.getCounters"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::base_service::GetCountersExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::base_service::GetCountersError::ApplicationException(aexn))
                }
            }
            .boxed()
        }


        #[::tracing::instrument(name = "BaseService.getRegexCounters", skip_all)]
        fn getRegexCounters(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetRegexCountersError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getRegexCounters";
            }
            let args = self::Args_BaseService_getRegexCounters {
                regex: arg_regex,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getRegexCounters", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "BaseService.getRegexCounters"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::base_service::GetRegexCountersExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::base_service::GetRegexCountersError::ApplicationException(aexn))
                }
            }
            .boxed()
        }


        #[::tracing::instrument(name = "BaseService.getSelectedCounters", skip_all)]
        fn getSelectedCounters(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetSelectedCountersError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getSelectedCounters";
            }
            let args = self::Args_BaseService_getSelectedCounters {
                keys: arg_keys,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getSelectedCounters", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "BaseService.getSelectedCounters"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::base_service::GetSelectedCountersExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::base_service::GetSelectedCountersError::ApplicationException(aexn))
                }
            }
            .boxed()
        }


        #[::tracing::instrument(name = "BaseService.getCounter", skip_all)]
        fn getCounter(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::GetCounterError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getCounter";
            }
            let args = self::Args_BaseService_getCounter {
                key: arg_key,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getCounter", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "BaseService.getCounter"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::base_service::GetCounterExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::base_service::GetCounterError::ApplicationException(aexn))
                }
            }
            .boxed()
        }


        #[::tracing::instrument(name = "BaseService.getExportedValues", skip_all)]
        fn getExportedValues(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetExportedValuesError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getExportedValues";
            }
            let args = self::Args_BaseService_getExportedValues {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getExportedValues", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "BaseService.getExportedValues"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::base_service::GetExportedValuesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::base_service::GetExportedValuesError::ApplicationException(aexn))
                }
            }
            .boxed()
        }


        #[::tracing::instrument(name = "BaseService.getSelectedExportedValues", skip_all)]
        fn getSelectedExportedValues(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetSelectedExportedValuesError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getSelectedExportedValues";
            }
            let args = self::Args_BaseService_getSelectedExportedValues {
                keys: arg_keys,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getSelectedExportedValues", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "BaseService.getSelectedExportedValues"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::base_service::GetSelectedExportedValuesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::base_service::GetSelectedExportedValuesError::ApplicationException(aexn))
                }
            }
            .boxed()
        }


        #[::tracing::instrument(name = "BaseService.getRegexExportedValues", skip_all)]
        fn getRegexExportedValues(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetRegexExportedValuesError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getRegexExportedValues";
            }
            let args = self::Args_BaseService_getRegexExportedValues {
                regex: arg_regex,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getRegexExportedValues", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "BaseService.getRegexExportedValues"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::base_service::GetRegexExportedValuesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::base_service::GetRegexExportedValuesError::ApplicationException(aexn))
                }
            }
            .boxed()
        }


        #[::tracing::instrument(name = "BaseService.getExportedValue", skip_all)]
        fn getExportedValue(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetExportedValueError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getExportedValue";
            }
            let args = self::Args_BaseService_getExportedValue {
                key: arg_key,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getExportedValue", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "BaseService.getExportedValue"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::base_service::GetExportedValueExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::base_service::GetExportedValueError::ApplicationException(aexn))
                }
            }
            .boxed()
        }


        #[::tracing::instrument(name = "BaseService.setOption", skip_all)]
        fn setOption(
            &self,
            arg_key: &::std::primitive::str,
            arg_value: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::base_service::SetOptionError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.setOption";
            }
            let args = self::Args_BaseService_setOption {
                key: arg_key,
                value: arg_value,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("setOption", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "BaseService.setOption"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::base_service::SetOptionExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::base_service::SetOptionError::ApplicationException(aexn))
                }
            }
            .boxed()
        }


        #[::tracing::instrument(name = "BaseService.getOption", skip_all)]
        fn getOption(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetOptionError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getOption";
            }
            let args = self::Args_BaseService_getOption {
                key: arg_key,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getOption", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "BaseService.getOption"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::base_service::GetOptionExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::base_service::GetOptionError::ApplicationException(aexn))
                }
            }
            .boxed()
        }


        #[::tracing::instrument(name = "BaseService.getOptions", skip_all)]
        fn getOptions(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetOptionsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.getOptions";
            }
            let args = self::Args_BaseService_getOptions {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getOptions", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "BaseService.getOptions"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::base_service::GetOptionsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::base_service::GetOptionsError::ApplicationException(aexn))
                }
            }
            .boxed()
        }


        #[::tracing::instrument(name = "BaseService.aliveSince", skip_all)]
        fn aliveSince(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::AliveSinceError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "BaseService";
                METHOD_NAME = "BaseService.aliveSince";
            }
            let args = self::Args_BaseService_aliveSince {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("aliveSince", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "BaseService.aliveSince"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::base_service::AliveSinceExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::base_service::AliveSinceError::ApplicationException(aexn))
                }
            }
            .boxed()
        }

    }

    impl<'a, T> BaseService for T
    where
        T: ::std::convert::AsRef<dyn BaseService + 'a>,
        T: ::std::marker::Send,
    {
        fn getStatus(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::fb303_status, crate::errors::base_service::GetStatusError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getStatus(
            )
        }
        fn getName(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetNameError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getName(
            )
        }
        fn getVersion(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetVersionError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getVersion(
            )
        }
        fn getStatusDetails(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetStatusDetailsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getStatusDetails(
            )
        }
        fn getCounters(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetCountersError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getCounters(
            )
        }
        fn getRegexCounters(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetRegexCountersError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getRegexCounters(
                arg_regex,
            )
        }
        fn getSelectedCounters(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetSelectedCountersError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getSelectedCounters(
                arg_keys,
            )
        }
        fn getCounter(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::GetCounterError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getCounter(
                arg_key,
            )
        }
        fn getExportedValues(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetExportedValuesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getExportedValues(
            )
        }
        fn getSelectedExportedValues(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetSelectedExportedValuesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getSelectedExportedValues(
                arg_keys,
            )
        }
        fn getRegexExportedValues(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetRegexExportedValuesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getRegexExportedValues(
                arg_regex,
            )
        }
        fn getExportedValue(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetExportedValueError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getExportedValue(
                arg_key,
            )
        }
        fn setOption(
            &self,
            arg_key: &::std::primitive::str,
            arg_value: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::base_service::SetOptionError>> + ::std::marker::Send + 'static>> {
            self.as_ref().setOption(
                arg_key,
                arg_value,
            )
        }
        fn getOption(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetOptionError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getOption(
                arg_key,
            )
        }
        fn getOptions(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetOptionsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getOptions(
            )
        }
        fn aliveSince(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::AliveSinceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().aliveSince(
            )
        }
    }

    #[derive(Clone)]
    pub struct make_BaseService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// # const _: &str = stringify! {
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = <dyn BuckGraphService>::new(protocol, transport);
    /// # };
    /// ```
    impl dyn BaseService {
        pub fn new<P, T, S>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl BaseService + ::std::marker::Send + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            let _ = protocol;
            ::std::sync::Arc::new(BaseServiceImpl::<P, T, S>::new(transport))
        }
    }

    pub type BaseServiceDynClient = <make_BaseService as ::fbthrift::ClientFactory>::Api;
    pub type BaseServiceClient = ::std::sync::Arc<BaseServiceDynClient>;

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_BaseService {
        type Api = dyn BaseService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn new<P, T, S>(protocol: P, transport: T) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport + ::std::marker::Sync,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            <dyn BaseService>::new::<P, T, S>(protocol, transport)
        }
    }


}


/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
/// ```thrift
/// service MyService {
///     FunctionResponse myFunction(
///         1: FunctionRequest request,
///     ) throws {
///         1: StorageException s,
///         2: NotFoundException n,
///     ),
///
///     // other functions
/// }
/// ```
///
/// we would end up with this mock object under crate::mock::MyService:
///
/// ```
/// # const _: &str = stringify! {
/// impl crate::client::MyService for MyService<'mock> {...}
///
/// pub struct MyService<'mock> {
///     pub myFunction: myFunction<'mock>,
///     // ...
/// }
///
/// impl dyn crate::client::MyService {
///     pub fn mock<'mock>() -> MyService<'mock>;
/// }
///
/// impl myFunction<'mock> {
///     // directly return the given success response
///     pub fn ret(&self, value: FunctionResponse);
///
///     // invoke closure to compute success response
///     pub fn mock(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///     );
///
///     // invoke closure to compute response
///     pub fn mock_result(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> Result<FunctionResponse, crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock,
///     );
///
///     // return one of the function's declared exceptions
///     pub fn throw<E>(&self, exception: E)
///     where
///         E: Clone + Into<crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
/// }
///
/// impl From<StorageException> for MyFunctionExn {...}
/// impl From<NotFoundException> for MyFunctionExn {...}
/// # };
/// ```
///
/// The intended usage from a test would be:
///
/// ```
/// # const _: &str = stringify! {
/// use std::sync::Arc;
/// use thrift_if::client::MyService;
///
/// #[test]
/// fn test_my_client() {
///     let mock = Arc::new(<dyn MyService>::mock());
///
///     // directly return a success response
///     let resp = FunctionResponse {...};
///     mock.myFunction.ret(resp);
///
///     // or give a closure to compute the success response
///     mock.myFunction.mock(|request| FunctionResponse {...});
///
///     // or throw one of the function's exceptions
///     mock.myFunction.throw(StorageException::ItFailed);
///
///     // or compute a Result (useful if your exceptions aren't Clone)
///     mock.myFunction.mock_result(|request| Err(...));
///
///     let out = do_the_thing(mock).wait().unwrap();
///     assert!(out.what_i_expected());
/// }
///
/// fn do_the_thing(
///     client: Arc<dyn MyService + Send + Sync + 'static>,
/// ) -> impl Future<Item = Out> {...}
/// # };
/// ```
pub mod mock {
    pub struct BaseService<'mock> {
        pub getStatus: r#impl::base_service::getStatus<'mock>,
        pub getName: r#impl::base_service::getName<'mock>,
        pub getVersion: r#impl::base_service::getVersion<'mock>,
        pub getStatusDetails: r#impl::base_service::getStatusDetails<'mock>,
        pub getCounters: r#impl::base_service::getCounters<'mock>,
        pub getRegexCounters: r#impl::base_service::getRegexCounters<'mock>,
        pub getSelectedCounters: r#impl::base_service::getSelectedCounters<'mock>,
        pub getCounter: r#impl::base_service::getCounter<'mock>,
        pub getExportedValues: r#impl::base_service::getExportedValues<'mock>,
        pub getSelectedExportedValues: r#impl::base_service::getSelectedExportedValues<'mock>,
        pub getRegexExportedValues: r#impl::base_service::getRegexExportedValues<'mock>,
        pub getExportedValue: r#impl::base_service::getExportedValue<'mock>,
        pub setOption: r#impl::base_service::setOption<'mock>,
        pub getOption: r#impl::base_service::getOption<'mock>,
        pub getOptions: r#impl::base_service::getOptions<'mock>,
        pub aliveSince: r#impl::base_service::aliveSince<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::BaseService {
        pub fn mock<'mock>() -> BaseService<'mock> {
            BaseService {
                getStatus: r#impl::base_service::getStatus::unimplemented(),
                getName: r#impl::base_service::getName::unimplemented(),
                getVersion: r#impl::base_service::getVersion::unimplemented(),
                getStatusDetails: r#impl::base_service::getStatusDetails::unimplemented(),
                getCounters: r#impl::base_service::getCounters::unimplemented(),
                getRegexCounters: r#impl::base_service::getRegexCounters::unimplemented(),
                getSelectedCounters: r#impl::base_service::getSelectedCounters::unimplemented(),
                getCounter: r#impl::base_service::getCounter::unimplemented(),
                getExportedValues: r#impl::base_service::getExportedValues::unimplemented(),
                getSelectedExportedValues: r#impl::base_service::getSelectedExportedValues::unimplemented(),
                getRegexExportedValues: r#impl::base_service::getRegexExportedValues::unimplemented(),
                getExportedValue: r#impl::base_service::getExportedValue::unimplemented(),
                setOption: r#impl::base_service::setOption::unimplemented(),
                getOption: r#impl::base_service::getOption::unimplemented(),
                getOptions: r#impl::base_service::getOptions::unimplemented(),
                aliveSince: r#impl::base_service::aliveSince::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    impl<'mock> super::client::BaseService for BaseService<'mock> {
        fn getStatus(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::fb303_status, crate::errors::base_service::GetStatusError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getName(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetNameError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getName.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getVersion(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetVersionError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getVersion.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getStatusDetails(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetStatusDetailsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getStatusDetails.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getCounters(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetCountersError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getCounters.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getRegexCounters(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetRegexCountersError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getRegexCounters.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_regex.to_owned())))
        }
        fn getSelectedCounters(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetSelectedCountersError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getSelectedCounters.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_keys.to_owned())))
        }
        fn getCounter(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::GetCounterError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getCounter.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_key.to_owned())))
        }
        fn getExportedValues(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetExportedValuesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getExportedValues.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getSelectedExportedValues(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetSelectedExportedValuesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getSelectedExportedValues.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_keys.to_owned())))
        }
        fn getRegexExportedValues(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetRegexExportedValuesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getRegexExportedValues.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_regex.to_owned())))
        }
        fn getExportedValue(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetExportedValueError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getExportedValue.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_key.to_owned())))
        }
        fn setOption(
            &self,
            arg_key: &::std::primitive::str,
            arg_value: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::base_service::SetOptionError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.setOption.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String, ::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_key.to_owned(), arg_value.to_owned())))
        }
        fn getOption(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetOptionError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getOption.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_key.to_owned())))
        }
        fn getOptions(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetOptionsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getOptions.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn aliveSince(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::AliveSinceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.aliveSince.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
    }

    mod r#impl {
        pub mod base_service {

            pub struct getStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        crate::types::fb303_status,
                        crate::errors::base_service::GetStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getStatus<'mock> {
                pub fn unimplemented() -> Self {
                    getStatus {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::fb303_status) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> crate::types::fb303_status + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<crate::types::fb303_status, crate::errors::base_service::GetStatusError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getName<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::string::String,
                        crate::errors::base_service::GetNameError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getName<'mock> {
                pub fn unimplemented() -> Self {
                    getName {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getName",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::string::String) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::string::String + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::string::String, crate::errors::base_service::GetNameError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetNameError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getVersion<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::string::String,
                        crate::errors::base_service::GetVersionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getVersion<'mock> {
                pub fn unimplemented() -> Self {
                    getVersion {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getVersion",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::string::String) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::string::String + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::string::String, crate::errors::base_service::GetVersionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetVersionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getStatusDetails<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::string::String,
                        crate::errors::base_service::GetStatusDetailsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getStatusDetails<'mock> {
                pub fn unimplemented() -> Self {
                    getStatusDetails {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getStatusDetails",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::string::String) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::string::String + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::string::String, crate::errors::base_service::GetStatusDetailsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetStatusDetailsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getCounters<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>,
                        crate::errors::base_service::GetCountersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getCounters<'mock> {
                pub fn unimplemented() -> Self {
                    getCounters {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getCounters",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetCountersError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetCountersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getRegexCounters<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>,
                        crate::errors::base_service::GetRegexCountersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getRegexCounters<'mock> {
                pub fn unimplemented() -> Self {
                    getRegexCounters {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getRegexCounters",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |regex| ::std::result::Result::Ok(mock(regex)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetRegexCountersError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |regex| mock(regex));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetRegexCountersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSelectedCounters<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>,
                        crate::errors::base_service::GetSelectedCountersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getSelectedCounters<'mock> {
                pub fn unimplemented() -> Self {
                    getSelectedCounters {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::vec::Vec<::std::string::String>| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getSelectedCounters",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>) {
                    self.mock(move |_: ::std::vec::Vec<::std::string::String>| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |keys| ::std::result::Result::Ok(mock(keys)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetSelectedCountersError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |keys| mock(keys));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetSelectedCountersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::vec::Vec<::std::string::String>| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getCounter<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        ::std::primitive::i64,
                        crate::errors::base_service::GetCounterError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getCounter<'mock> {
                pub fn unimplemented() -> Self {
                    getCounter {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getCounter",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::primitive::i64) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::primitive::i64 + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key| ::std::result::Result::Ok(mock(key)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<::std::primitive::i64, crate::errors::base_service::GetCounterError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key| mock(key));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetCounterError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getExportedValues<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
                        crate::errors::base_service::GetExportedValuesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getExportedValues<'mock> {
                pub fn unimplemented() -> Self {
                    getExportedValues {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getExportedValues",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetExportedValuesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetExportedValuesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSelectedExportedValues<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
                        crate::errors::base_service::GetSelectedExportedValuesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getSelectedExportedValues<'mock> {
                pub fn unimplemented() -> Self {
                    getSelectedExportedValues {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::vec::Vec<::std::string::String>| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getSelectedExportedValues",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
                    self.mock(move |_: ::std::vec::Vec<::std::string::String>| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |keys| ::std::result::Result::Ok(mock(keys)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetSelectedExportedValuesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |keys| mock(keys));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetSelectedExportedValuesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::vec::Vec<::std::string::String>| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getRegexExportedValues<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
                        crate::errors::base_service::GetRegexExportedValuesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getRegexExportedValues<'mock> {
                pub fn unimplemented() -> Self {
                    getRegexExportedValues {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getRegexExportedValues",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |regex| ::std::result::Result::Ok(mock(regex)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetRegexExportedValuesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |regex| mock(regex));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetRegexExportedValuesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getExportedValue<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        ::std::string::String,
                        crate::errors::base_service::GetExportedValueError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getExportedValue<'mock> {
                pub fn unimplemented() -> Self {
                    getExportedValue {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getExportedValue",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::string::String) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::string::String + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key| ::std::result::Result::Ok(mock(key)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<::std::string::String, crate::errors::base_service::GetExportedValueError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key| mock(key));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetExportedValueError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct setOption<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String, ::std::string::String) -> ::std::result::Result<
                        (),
                        crate::errors::base_service::SetOptionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> setOption<'mock> {
                pub fn unimplemented() -> Self {
                    setOption {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String, _: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "setOption",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: ::std::string::String, _: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String, ::std::string::String) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key, value| ::std::result::Result::Ok(mock(key, value)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::string::String, ::std::string::String) -> ::std::result::Result<(), crate::errors::base_service::SetOptionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key, value| mock(key, value));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::SetOptionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String, _: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getOption<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        ::std::string::String,
                        crate::errors::base_service::GetOptionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getOption<'mock> {
                pub fn unimplemented() -> Self {
                    getOption {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getOption",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::string::String) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::string::String + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key| ::std::result::Result::Ok(mock(key)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<::std::string::String, crate::errors::base_service::GetOptionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key| mock(key));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetOptionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getOptions<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
                        crate::errors::base_service::GetOptionsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getOptions<'mock> {
                pub fn unimplemented() -> Self {
                    getOptions {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getOptions",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetOptionsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetOptionsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct aliveSince<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::primitive::i64,
                        crate::errors::base_service::AliveSinceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> aliveSince<'mock> {
                pub fn unimplemented() -> Self {
                    aliveSince {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "aliveSince",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::primitive::i64) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::primitive::i64 + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::primitive::i64, crate::errors::base_service::AliveSinceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::AliveSinceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
    }
}

/// Error return types.
pub mod errors {
    /// Errors for BaseService functions.
    pub mod base_service {

        pub type GetStatusError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::base_service::GetStatusExn> for
            ::std::result::Result<crate::types::fb303_status, GetStatusError>
        {
            fn from(e: crate::services::base_service::GetStatusExn) -> Self {
                match e {
                    crate::services::base_service::GetStatusExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::base_service::GetStatusExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetStatusError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetNameError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::base_service::GetNameExn> for
            ::std::result::Result<::std::string::String, GetNameError>
        {
            fn from(e: crate::services::base_service::GetNameExn) -> Self {
                match e {
                    crate::services::base_service::GetNameExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::base_service::GetNameExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetNameError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetVersionError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::base_service::GetVersionExn> for
            ::std::result::Result<::std::string::String, GetVersionError>
        {
            fn from(e: crate::services::base_service::GetVersionExn) -> Self {
                match e {
                    crate::services::base_service::GetVersionExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::base_service::GetVersionExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetVersionError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetStatusDetailsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::base_service::GetStatusDetailsExn> for
            ::std::result::Result<::std::string::String, GetStatusDetailsError>
        {
            fn from(e: crate::services::base_service::GetStatusDetailsExn) -> Self {
                match e {
                    crate::services::base_service::GetStatusDetailsExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::base_service::GetStatusDetailsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetStatusDetailsError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetCountersError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::base_service::GetCountersExn> for
            ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, GetCountersError>
        {
            fn from(e: crate::services::base_service::GetCountersExn) -> Self {
                match e {
                    crate::services::base_service::GetCountersExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::base_service::GetCountersExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetCountersError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetRegexCountersError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::base_service::GetRegexCountersExn> for
            ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, GetRegexCountersError>
        {
            fn from(e: crate::services::base_service::GetRegexCountersExn) -> Self {
                match e {
                    crate::services::base_service::GetRegexCountersExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::base_service::GetRegexCountersExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetRegexCountersError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetSelectedCountersError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::base_service::GetSelectedCountersExn> for
            ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, GetSelectedCountersError>
        {
            fn from(e: crate::services::base_service::GetSelectedCountersExn) -> Self {
                match e {
                    crate::services::base_service::GetSelectedCountersExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::base_service::GetSelectedCountersExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetSelectedCountersError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetCounterError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::base_service::GetCounterExn> for
            ::std::result::Result<::std::primitive::i64, GetCounterError>
        {
            fn from(e: crate::services::base_service::GetCounterExn) -> Self {
                match e {
                    crate::services::base_service::GetCounterExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::base_service::GetCounterExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetCounterError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetExportedValuesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::base_service::GetExportedValuesExn> for
            ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, GetExportedValuesError>
        {
            fn from(e: crate::services::base_service::GetExportedValuesExn) -> Self {
                match e {
                    crate::services::base_service::GetExportedValuesExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::base_service::GetExportedValuesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetExportedValuesError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetSelectedExportedValuesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::base_service::GetSelectedExportedValuesExn> for
            ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, GetSelectedExportedValuesError>
        {
            fn from(e: crate::services::base_service::GetSelectedExportedValuesExn) -> Self {
                match e {
                    crate::services::base_service::GetSelectedExportedValuesExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::base_service::GetSelectedExportedValuesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetSelectedExportedValuesError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetRegexExportedValuesError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::base_service::GetRegexExportedValuesExn> for
            ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, GetRegexExportedValuesError>
        {
            fn from(e: crate::services::base_service::GetRegexExportedValuesExn) -> Self {
                match e {
                    crate::services::base_service::GetRegexExportedValuesExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::base_service::GetRegexExportedValuesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetRegexExportedValuesError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetExportedValueError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::base_service::GetExportedValueExn> for
            ::std::result::Result<::std::string::String, GetExportedValueError>
        {
            fn from(e: crate::services::base_service::GetExportedValueExn) -> Self {
                match e {
                    crate::services::base_service::GetExportedValueExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::base_service::GetExportedValueExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetExportedValueError::ApplicationException(aexn)),
                }
            }
        }

        pub type SetOptionError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::base_service::SetOptionExn> for
            ::std::result::Result<(), SetOptionError>
        {
            fn from(e: crate::services::base_service::SetOptionExn) -> Self {
                match e {
                    crate::services::base_service::SetOptionExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::base_service::SetOptionExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(SetOptionError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetOptionError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::base_service::GetOptionExn> for
            ::std::result::Result<::std::string::String, GetOptionError>
        {
            fn from(e: crate::services::base_service::GetOptionExn) -> Self {
                match e {
                    crate::services::base_service::GetOptionExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::base_service::GetOptionExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetOptionError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetOptionsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::base_service::GetOptionsExn> for
            ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, GetOptionsError>
        {
            fn from(e: crate::services::base_service::GetOptionsExn) -> Self {
                match e {
                    crate::services::base_service::GetOptionsExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::base_service::GetOptionsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetOptionsError::ApplicationException(aexn)),
                }
            }
        }

        pub type AliveSinceError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::base_service::AliveSinceExn> for
            ::std::result::Result<::std::primitive::i64, AliveSinceError>
        {
            fn from(e: crate::services::base_service::AliveSinceExn) -> Self {
                match e {
                    crate::services::base_service::AliveSinceExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::base_service::AliveSinceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AliveSinceError::ApplicationException(aexn)),
                }
            }
        }

    }

}
