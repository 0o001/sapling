// @generated by Thrift for eden/fs/config/eden_config.thrift
// This file is probably not the place you want to edit!

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

extern crate serde;
pub use self::errors::*;
pub use self::types::*;

/// Thrift type definitions for `eden_config`.
pub mod types {
    #![allow(clippy::redundant_closure)]


    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ConfigValue {
        #[serde(default)]
        pub parsedValue: ::std::string::String,
        #[serde(default)]
        pub source: crate::types::ConfigSource,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct EdenConfigData {
        #[serde(default)]
        pub values: ::std::collections::BTreeMap<::std::string::String, crate::types::ConfigValue>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[doc = "ConfigSource identifies the point of origin of a config setting.\nIt is ordered from low to high precedence. Higher precedence\nconfiguration values over-ride lower precedence values. A config\nsetting of CommandLine takes precedence over all other settings."]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ConfigSource(pub ::std::primitive::i32);

    impl ConfigSource {
        pub const Default: Self = ConfigSource(0i32);
        pub const SystemConfig: Self = ConfigSource(1i32);
        pub const UserConfig: Self = ConfigSource(2i32);
        pub const CommandLine: Self = ConfigSource(3i32);
    }

    impl ::fbthrift::ThriftEnum for ConfigSource {
        fn enumerate() -> &'static [(ConfigSource, &'static str)] {
            &[
                (ConfigSource::Default, "Default"),
                (ConfigSource::SystemConfig, "SystemConfig"),
                (ConfigSource::UserConfig, "UserConfig"),
                (ConfigSource::CommandLine, "CommandLine"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "Default",
                "SystemConfig",
                "UserConfig",
                "CommandLine",
            ]
        }

        fn variant_values() -> &'static [ConfigSource] {
            &[
                ConfigSource::Default,
                ConfigSource::SystemConfig,
                ConfigSource::UserConfig,
                ConfigSource::CommandLine,
            ]
        }
    }

    impl ::std::default::Default for ConfigSource {
        fn default() -> Self {
            ConfigSource(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ConfigSource> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ConfigSource) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ConfigSource> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ConfigSource) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ConfigSource {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ConfigSource {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("Default", 0),
                ("SystemConfig", 1),
                ("UserConfig", 2),
                ("CommandLine", 3),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for ConfigSource {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ConfigSource::{}", self)
        }
    }

    impl ::std::str::FromStr for ConfigSource {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("CommandLine", 3),
                ("Default", 0),
                ("SystemConfig", 1),
                ("UserConfig", 2),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ConfigSource").map(ConfigSource)
        }
    }

    impl ::fbthrift::GetTType for ConfigSource {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ConfigSource
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ConfigSource
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ConfigSource::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ConfigReloadBehavior(pub ::std::primitive::i32);

    impl ConfigReloadBehavior {
        pub const AutoReload: Self = ConfigReloadBehavior(0i32);
        pub const NoReload: Self = ConfigReloadBehavior(1i32);
        pub const ForceReload: Self = ConfigReloadBehavior(2i32);
    }

    impl ::fbthrift::ThriftEnum for ConfigReloadBehavior {
        fn enumerate() -> &'static [(ConfigReloadBehavior, &'static str)] {
            &[
                (ConfigReloadBehavior::AutoReload, "AutoReload"),
                (ConfigReloadBehavior::NoReload, "NoReload"),
                (ConfigReloadBehavior::ForceReload, "ForceReload"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "AutoReload",
                "NoReload",
                "ForceReload",
            ]
        }

        fn variant_values() -> &'static [ConfigReloadBehavior] {
            &[
                ConfigReloadBehavior::AutoReload,
                ConfigReloadBehavior::NoReload,
                ConfigReloadBehavior::ForceReload,
            ]
        }
    }

    impl ::std::default::Default for ConfigReloadBehavior {
        fn default() -> Self {
            ConfigReloadBehavior(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ConfigReloadBehavior> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ConfigReloadBehavior) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ConfigReloadBehavior> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ConfigReloadBehavior) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ConfigReloadBehavior {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ConfigReloadBehavior {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("AutoReload", 0),
                ("NoReload", 1),
                ("ForceReload", 2),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for ConfigReloadBehavior {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ConfigReloadBehavior::{}", self)
        }
    }

    impl ::std::str::FromStr for ConfigReloadBehavior {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("AutoReload", 0),
                ("ForceReload", 2),
                ("NoReload", 1),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ConfigReloadBehavior").map(ConfigReloadBehavior)
        }
    }

    impl ::fbthrift::GetTType for ConfigReloadBehavior {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ConfigReloadBehavior
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ConfigReloadBehavior
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ConfigReloadBehavior::from(p.read_i32()?))
        }
    }

    impl ::std::default::Default for self::ConfigValue {
        fn default() -> Self {
            Self {
                parsedValue: ::std::default::Default::default(),
                source: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::ConfigValue {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("ConfigValue")
                .field("parsedValue", &self.parsedValue)
                .field("source", &self.source)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::ConfigValue {}
    unsafe impl ::std::marker::Sync for self::ConfigValue {}

    impl ::fbthrift::GetTType for self::ConfigValue {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ConfigValue
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ConfigValue");
            p.write_field_begin("parsedValue", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.parsedValue, p);
            p.write_field_end();
            p.write_field_begin("source", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.source, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ConfigValue
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("parsedValue", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("source", ::fbthrift::TType::I32, 2),
            ];
            let mut field_parsedValue = ::std::option::Option::None;
            let mut field_source = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_parsedValue = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_source = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                parsedValue: field_parsedValue.unwrap_or_default(),
                source: field_source.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::EdenConfigData {
        fn default() -> Self {
            Self {
                values: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::EdenConfigData {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("EdenConfigData")
                .field("values", &self.values)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::EdenConfigData {}
    unsafe impl ::std::marker::Sync for self::EdenConfigData {}

    impl ::fbthrift::GetTType for self::EdenConfigData {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::EdenConfigData
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EdenConfigData");
            p.write_field_begin("values", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::EdenConfigData
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("values", ::fbthrift::TType::Map, 1),
            ];
            let mut field_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Map, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                values: field_values.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    mod dot_dot {
        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
        pub struct OtherFields(pub(crate) ());

        pub(super) fn default_for_serde_deserialize() -> OtherFields {
            OtherFields(())
        }
    }
}

/// Error return types.
pub mod errors {
}
