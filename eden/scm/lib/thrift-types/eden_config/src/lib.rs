// @generated by Thrift. This file is probably not the place you want to edit!

#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

pub use self::errors::*;
pub use self::types::*;

pub mod types {
    #![allow(clippy::redundant_closure)]


    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ConfigValue {
        #[serde(default)]
        pub parsedValue: ::std::string::String,
        #[serde(default)]
        pub source: crate::types::ConfigSource,
    }

    #[derive(Clone, Debug, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct EdenConfigData {
        #[serde(default)]
        pub values: ::std::collections::BTreeMap<::std::string::String, crate::types::ConfigValue>,
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ConfigSource(pub ::std::primitive::i32);

    impl ConfigSource {
        pub const Default: Self = ConfigSource(0i32);
        pub const SystemConfig: Self = ConfigSource(1i32);
        pub const UserConfig: Self = ConfigSource(2i32);
        pub const CommandLine: Self = ConfigSource(3i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "Default",
                "SystemConfig",
                "UserConfig",
                "CommandLine",
            ]
        }
    }

    impl ::std::default::Default for ConfigSource {
        fn default() -> Self {
            ConfigSource(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ConfigSource> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ConfigSource) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ConfigSource> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ConfigSource) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ConfigSource {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ConfigSource {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                ConfigSource::Default => "Default",
                ConfigSource::SystemConfig => "SystemConfig",
                ConfigSource::UserConfig => "UserConfig",
                ConfigSource::CommandLine => "CommandLine",
                ConfigSource(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for ConfigSource {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ConfigSource::{}", self)
        }
    }

    impl ::std::str::FromStr for ConfigSource {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "Default" => ::std::result::Result::Ok(ConfigSource::Default),
                "SystemConfig" => ::std::result::Result::Ok(ConfigSource::SystemConfig),
                "UserConfig" => ::std::result::Result::Ok(ConfigSource::UserConfig),
                "CommandLine" => ::std::result::Result::Ok(ConfigSource::CommandLine),
                _ => ::anyhow::bail!("Unable to parse {} as ConfigSource", string),
            }
        }
    }

    impl ::fbthrift::GetTType for ConfigSource {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ConfigSource
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ConfigSource
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ConfigSource::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ConfigReloadBehavior(pub ::std::primitive::i32);

    impl ConfigReloadBehavior {
        pub const AutoReload: Self = ConfigReloadBehavior(0i32);
        pub const NoReload: Self = ConfigReloadBehavior(1i32);
        pub const ForceReload: Self = ConfigReloadBehavior(2i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "AutoReload",
                "NoReload",
                "ForceReload",
            ]
        }
    }

    impl ::std::default::Default for ConfigReloadBehavior {
        fn default() -> Self {
            ConfigReloadBehavior(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ConfigReloadBehavior> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ConfigReloadBehavior) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ConfigReloadBehavior> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ConfigReloadBehavior) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ConfigReloadBehavior {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ConfigReloadBehavior {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                ConfigReloadBehavior::AutoReload => "AutoReload",
                ConfigReloadBehavior::NoReload => "NoReload",
                ConfigReloadBehavior::ForceReload => "ForceReload",
                ConfigReloadBehavior(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for ConfigReloadBehavior {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ConfigReloadBehavior::{}", self)
        }
    }

    impl ::std::str::FromStr for ConfigReloadBehavior {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "AutoReload" => ::std::result::Result::Ok(ConfigReloadBehavior::AutoReload),
                "NoReload" => ::std::result::Result::Ok(ConfigReloadBehavior::NoReload),
                "ForceReload" => ::std::result::Result::Ok(ConfigReloadBehavior::ForceReload),
                _ => ::anyhow::bail!("Unable to parse {} as ConfigReloadBehavior", string),
            }
        }
    }

    impl ::fbthrift::GetTType for ConfigReloadBehavior {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ConfigReloadBehavior
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ConfigReloadBehavior
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ConfigReloadBehavior::from(p.read_i32()?))
        }
    }

    impl ::std::default::Default for self::ConfigValue {
        fn default() -> Self {
            Self {
                parsedValue: ::std::default::Default::default(),
                source: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ConfigValue {}
    unsafe impl ::std::marker::Sync for self::ConfigValue {}

    impl ::fbthrift::GetTType for self::ConfigValue {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ConfigValue
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ConfigValue");
            p.write_field_begin("parsedValue", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.parsedValue, p);
            p.write_field_end();
            p.write_field_begin("source", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.source, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ConfigValue
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_parsedValue = ::std::option::Option::None;
            let mut field_source = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_parsedValue = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_source = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                parsedValue: field_parsedValue.unwrap_or_default(),
                source: field_source.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::EdenConfigData {
        fn default() -> Self {
            Self {
                values: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::EdenConfigData {}
    unsafe impl ::std::marker::Sync for self::EdenConfigData {}

    impl ::fbthrift::GetTType for self::EdenConfigData {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::EdenConfigData
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EdenConfigData");
            p.write_field_begin("values", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::EdenConfigData
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_values = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Map, 1) => field_values = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                values: field_values.unwrap_or_default(),
            })
        }
    }

}

pub mod errors {
}
