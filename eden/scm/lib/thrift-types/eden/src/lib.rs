// @generated by Thrift. This file is probably not the place you want to edit!

#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]

pub use self::errors::*;
pub use self::types::*;

pub mod types {
    use fbthrift::{
        Deserialize, GetTType, ProtocolReader, ProtocolWriter, Serialize, TType,
    };

    pub type unsigned64 = i64;

    pub type pid_t = i32;

    pub type BinaryHash = Vec<u8>;

    pub type PathString = Vec<u8>;

    pub type DType = i16;

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct EdenError {
        pub message: String,
        pub errorCode: Option<i32>,
        pub errorType: crate::types::EdenErrorType,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct NoValueForKeyError {
        pub key: String,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DaemonInfo {
        pub pid: i32,
        pub commandLine: Vec<String>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct MountInfo {
        pub mountPoint: crate::types::PathString,
        pub edenClientPath: crate::types::PathString,
        pub state: crate::types::MountState,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct MountArgument {
        pub mountPoint: crate::types::PathString,
        pub edenClientPath: crate::types::PathString,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub enum SHA1Result {
        sha1(crate::types::BinaryHash),
        error(crate::types::EdenError),
        UnknownField(i32),
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct TimeSpec {
        pub seconds: i64,
        pub nanoSeconds: i64,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct FileInformation {
        pub size: crate::types::unsigned64,
        pub mtime: crate::types::TimeSpec,
        pub mode: i32,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub enum FileInformationOrError {
        info(crate::types::FileInformation),
        error(crate::types::EdenError),
        UnknownField(i32),
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct JournalPosition {
        pub mountGeneration: i64,
        pub sequenceNumber: crate::types::unsigned64,
        pub snapshotHash: crate::types::BinaryHash,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct FileDelta {
        pub fromPosition: crate::types::JournalPosition,
        pub toPosition: crate::types::JournalPosition,
        pub changedPaths: Vec<crate::types::PathString>,
        pub createdPaths: Vec<crate::types::PathString>,
        pub removedPaths: Vec<crate::types::PathString>,
        pub uncleanPaths: Vec<crate::types::PathString>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DebugGetRawJournalParams {
        pub mountPoint: crate::types::PathString,
        pub limit: Option<i32>,
        pub fromSequenceNumber: i32,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct DebugPathChangeInfo {
        pub existedBefore: bool,
        pub existedAfter: bool,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct DebugJournalDelta {
        pub fromPosition: crate::types::JournalPosition,
        pub toPosition: crate::types::JournalPosition,
        pub changedPaths: std::collections::BTreeMap<crate::types::PathString, crate::types::DebugPathChangeInfo>,
        pub uncleanPaths: std::collections::BTreeSet<crate::types::PathString>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct DebugGetRawJournalResponse {
        pub allDeltas: Vec<crate::types::DebugJournalDelta>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct ScmStatus {
        pub entries: std::collections::BTreeMap<crate::types::PathString, crate::types::ScmFileStatus>,
        pub errors: std::collections::BTreeMap<crate::types::PathString, String>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct CheckoutConflict {
        pub path: crate::types::PathString,
        pub type_: crate::types::ConflictType,
        pub message: String,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ScmBlobMetadata {
        pub size: i64,
        pub contentsSha1: crate::types::BinaryHash,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ScmTreeEntry {
        pub name: Vec<u8>,
        pub mode: i32,
        pub id: crate::types::BinaryHash,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct TreeInodeEntryDebugInfo {
        pub name: Vec<u8>,
        pub inodeNumber: i64,
        pub mode: i32,
        pub loaded: bool,
        pub materialized: bool,
        pub hash: crate::types::BinaryHash,
        pub fileSize: Option<i64>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct WorkingDirectoryParents {
        pub parent1: crate::types::BinaryHash,
        pub parent2: Option<crate::types::BinaryHash>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct TreeInodeDebugInfo {
        pub inodeNumber: i64,
        pub path: Vec<u8>,
        pub materialized: bool,
        pub treeHash: crate::types::BinaryHash,
        pub entries: Vec<crate::types::TreeInodeEntryDebugInfo>,
        pub refcount: i64,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct InodePathDebugInfo {
        pub path: crate::types::PathString,
        pub loaded: bool,
        pub linked: bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct SetLogLevelResult {
        pub categoryCreated: bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct JournalInfo {
        pub entryCount: i64,
        pub memoryUsage: i64,
        pub durationSeconds: i64,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct MountInodeInfo {
        pub unloadedInodeCount: i64,
        pub loadedFileCount: i64,
        pub loadedTreeCount: i64,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct CacheStats {
        pub entryCount: i64,
        pub totalSizeInBytes: i64,
        pub hitCount: i64,
        pub missCount: i64,
        pub evictionCount: i64,
        pub dropCount: i64,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct InternalStats {
        pub periodicUnloadCount: i64,
        pub counters: std::collections::BTreeMap<String, i64>,
        pub mountPointInfo: std::collections::BTreeMap<crate::types::PathString, crate::types::MountInodeInfo>,
        pub smaps: Vec<u8>,
        pub privateBytes: i64,
        pub vmRSSBytes: i64,
        pub blobCacheStats: crate::types::CacheStats,
        pub mountPointJournalInfo: std::collections::BTreeMap<crate::types::PathString, crate::types::JournalInfo>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ManifestEntry {
        pub mode: i32,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct FuseCall {
        pub len: i32,
        pub opcode: i32,
        pub unique: i64,
        pub nodeid: i64,
        pub uid: i32,
        pub gid: i32,
        pub pid: crate::types::pid_t,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetConfigParams {
        pub reload: eden_config::types::ConfigReloadBehavior,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GlobParams {
        pub mountPoint: crate::types::PathString,
        pub globs: Vec<String>,
        pub includeDotfiles: bool,
        pub prefetchFiles: bool,
        pub suppressFileList: bool,
        pub wantDtype: bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Glob {
        pub matchingFiles: Vec<crate::types::PathString>,
        pub dtypes: Vec<crate::types::DType>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct AccessCounts {
        pub fuseTotal: i64,
        pub fuseReads: i64,
        pub fuseWrites: i64,
        pub fuseBackingStoreImports: i64,
        pub fuseDurationNs: i64,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct MountAccesses {
        pub accessCountsByPid: std::collections::BTreeMap<crate::types::pid_t, crate::types::AccessCounts>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetAccessCountsResult {
        pub cmdsByPid: std::collections::BTreeMap<crate::types::pid_t, Vec<u8>>,
        pub accessesByMount: std::collections::BTreeMap<crate::types::PathString, crate::types::MountAccesses>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct TracePoint {
        pub timestamp: i64,
        pub traceId: i64,
        pub blockId: i64,
        pub parentBlockId: i64,
        pub name: String,
        pub event: crate::types::TracePointEvent,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct FaultDefinition {
        pub keyClass: String,
        pub keyValueRegex: String,
        pub count: i64,
        pub block: bool,
        pub delayMilliseconds: i64,
        pub errorType: Option<String>,
        pub errorMessage: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct RemoveFaultArg {
        pub keyClass: String,
        pub keyValueRegex: String,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct UnblockFaultArg {
        pub keyClass: Option<String>,
        pub keyValueRegex: Option<String>,
        pub errorType: Option<String>,
        pub errorMessage: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct GetScmStatusResult {
        pub status: crate::types::ScmStatus,
        pub version: String,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct GetScmStatusParams {
        pub mountPoint: crate::types::PathString,
        pub commit: crate::types::BinaryHash,
        pub listIgnored: bool,
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct EdenErrorType(pub i32);

    impl EdenErrorType {
        pub const POSIX_ERROR: Self = EdenErrorType(0i32);
        pub const WIN32_ERROR: Self = EdenErrorType(1i32);
        pub const HRESULT_ERROR: Self = EdenErrorType(2i32);
        pub const ARGUMENT_ERROR: Self = EdenErrorType(3i32);
        pub const GENERIC_ERROR: Self = EdenErrorType(4i32);
        pub const MOUNT_GENERATION_CHANGED: Self = EdenErrorType(5i32);
        pub const JOURNAL_TRUNCATED: Self = EdenErrorType(6i32);
        pub const CHECKOUT_IN_PROGRESS: Self = EdenErrorType(7i32);
        pub const OUT_OF_DATE_PARENT: Self = EdenErrorType(8i32);
    }

    impl Default for EdenErrorType {
        fn default() -> Self {
            EdenErrorType(fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> From<&'a EdenErrorType> for i32 {
        #[inline]
        fn from(x: &'a EdenErrorType) -> i32 {
            x.0
        }
    }

    impl From<EdenErrorType> for i32 {
        #[inline]
        fn from(x: EdenErrorType) -> i32 {
            x.0
        }
    }

    impl From<i32> for EdenErrorType {
        #[inline]
        fn from(x: i32) -> Self {
            Self(x)
        }
    }

    impl std::fmt::Display for EdenErrorType {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            let s: &str = match *self {
                EdenErrorType::POSIX_ERROR => "POSIX_ERROR",
                EdenErrorType::WIN32_ERROR => "WIN32_ERROR",
                EdenErrorType::HRESULT_ERROR => "HRESULT_ERROR",
                EdenErrorType::ARGUMENT_ERROR => "ARGUMENT_ERROR",
                EdenErrorType::GENERIC_ERROR => "GENERIC_ERROR",
                EdenErrorType::MOUNT_GENERATION_CHANGED => "MOUNT_GENERATION_CHANGED",
                EdenErrorType::JOURNAL_TRUNCATED => "JOURNAL_TRUNCATED",
                EdenErrorType::CHECKOUT_IN_PROGRESS => "CHECKOUT_IN_PROGRESS",
                EdenErrorType::OUT_OF_DATE_PARENT => "OUT_OF_DATE_PARENT",
                EdenErrorType(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl std::fmt::Debug for EdenErrorType {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(fmt, "{}::{}", "EdenErrorType", self)
        }
    }

    impl std::str::FromStr for EdenErrorType {
        type Err = anyhow::Error;

        fn from_str(string: &str) -> std::result::Result<Self, Self::Err> {
            match string {
                "POSIX_ERROR" => Ok(EdenErrorType::POSIX_ERROR),
                "WIN32_ERROR" => Ok(EdenErrorType::WIN32_ERROR),
                "HRESULT_ERROR" => Ok(EdenErrorType::HRESULT_ERROR),
                "ARGUMENT_ERROR" => Ok(EdenErrorType::ARGUMENT_ERROR),
                "GENERIC_ERROR" => Ok(EdenErrorType::GENERIC_ERROR),
                "MOUNT_GENERATION_CHANGED" => Ok(EdenErrorType::MOUNT_GENERATION_CHANGED),
                "JOURNAL_TRUNCATED" => Ok(EdenErrorType::JOURNAL_TRUNCATED),
                "CHECKOUT_IN_PROGRESS" => Ok(EdenErrorType::CHECKOUT_IN_PROGRESS),
                "OUT_OF_DATE_PARENT" => Ok(EdenErrorType::OUT_OF_DATE_PARENT),
                _ => anyhow::bail!("Unable to parse {} as {}", string, "EdenErrorType"),
            }
        }
    }

    impl GetTType for EdenErrorType {
        const TTYPE: TType = TType::I32;
    }

    impl<P: ProtocolWriter> Serialize<P> for EdenErrorType {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for EdenErrorType {
        #[inline]
        fn read(p: &mut P) -> anyhow::Result<Self> {
            Ok(EdenErrorType::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct MountState(pub i32);

    impl MountState {
        pub const UNINITIALIZED: Self = MountState(0i32);
        pub const INITIALIZING: Self = MountState(1i32);
        pub const INITIALIZED: Self = MountState(2i32);
        pub const STARTING: Self = MountState(3i32);
        pub const RUNNING: Self = MountState(4i32);
        pub const FUSE_ERROR: Self = MountState(5i32);
        pub const SHUTTING_DOWN: Self = MountState(6i32);
        pub const SHUT_DOWN: Self = MountState(7i32);
        pub const DESTROYING: Self = MountState(8i32);
        pub const INIT_ERROR: Self = MountState(9i32);
    }

    impl Default for MountState {
        fn default() -> Self {
            MountState(fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> From<&'a MountState> for i32 {
        #[inline]
        fn from(x: &'a MountState) -> i32 {
            x.0
        }
    }

    impl From<MountState> for i32 {
        #[inline]
        fn from(x: MountState) -> i32 {
            x.0
        }
    }

    impl From<i32> for MountState {
        #[inline]
        fn from(x: i32) -> Self {
            Self(x)
        }
    }

    impl std::fmt::Display for MountState {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            let s: &str = match *self {
                MountState::UNINITIALIZED => "UNINITIALIZED",
                MountState::INITIALIZING => "INITIALIZING",
                MountState::INITIALIZED => "INITIALIZED",
                MountState::STARTING => "STARTING",
                MountState::RUNNING => "RUNNING",
                MountState::FUSE_ERROR => "FUSE_ERROR",
                MountState::SHUTTING_DOWN => "SHUTTING_DOWN",
                MountState::SHUT_DOWN => "SHUT_DOWN",
                MountState::DESTROYING => "DESTROYING",
                MountState::INIT_ERROR => "INIT_ERROR",
                MountState(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl std::fmt::Debug for MountState {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(fmt, "{}::{}", "MountState", self)
        }
    }

    impl std::str::FromStr for MountState {
        type Err = anyhow::Error;

        fn from_str(string: &str) -> std::result::Result<Self, Self::Err> {
            match string {
                "UNINITIALIZED" => Ok(MountState::UNINITIALIZED),
                "INITIALIZING" => Ok(MountState::INITIALIZING),
                "INITIALIZED" => Ok(MountState::INITIALIZED),
                "STARTING" => Ok(MountState::STARTING),
                "RUNNING" => Ok(MountState::RUNNING),
                "FUSE_ERROR" => Ok(MountState::FUSE_ERROR),
                "SHUTTING_DOWN" => Ok(MountState::SHUTTING_DOWN),
                "SHUT_DOWN" => Ok(MountState::SHUT_DOWN),
                "DESTROYING" => Ok(MountState::DESTROYING),
                "INIT_ERROR" => Ok(MountState::INIT_ERROR),
                _ => anyhow::bail!("Unable to parse {} as {}", string, "MountState"),
            }
        }
    }

    impl GetTType for MountState {
        const TTYPE: TType = TType::I32;
    }

    impl<P: ProtocolWriter> Serialize<P> for MountState {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for MountState {
        #[inline]
        fn read(p: &mut P) -> anyhow::Result<Self> {
            Ok(MountState::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ScmFileStatus(pub i32);

    impl ScmFileStatus {
        pub const ADDED: Self = ScmFileStatus(0i32);
        pub const MODIFIED: Self = ScmFileStatus(1i32);
        pub const REMOVED: Self = ScmFileStatus(2i32);
        pub const IGNORED: Self = ScmFileStatus(3i32);
    }

    impl Default for ScmFileStatus {
        fn default() -> Self {
            ScmFileStatus(fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> From<&'a ScmFileStatus> for i32 {
        #[inline]
        fn from(x: &'a ScmFileStatus) -> i32 {
            x.0
        }
    }

    impl From<ScmFileStatus> for i32 {
        #[inline]
        fn from(x: ScmFileStatus) -> i32 {
            x.0
        }
    }

    impl From<i32> for ScmFileStatus {
        #[inline]
        fn from(x: i32) -> Self {
            Self(x)
        }
    }

    impl std::fmt::Display for ScmFileStatus {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            let s: &str = match *self {
                ScmFileStatus::ADDED => "ADDED",
                ScmFileStatus::MODIFIED => "MODIFIED",
                ScmFileStatus::REMOVED => "REMOVED",
                ScmFileStatus::IGNORED => "IGNORED",
                ScmFileStatus(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl std::fmt::Debug for ScmFileStatus {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(fmt, "{}::{}", "ScmFileStatus", self)
        }
    }

    impl std::str::FromStr for ScmFileStatus {
        type Err = anyhow::Error;

        fn from_str(string: &str) -> std::result::Result<Self, Self::Err> {
            match string {
                "ADDED" => Ok(ScmFileStatus::ADDED),
                "MODIFIED" => Ok(ScmFileStatus::MODIFIED),
                "REMOVED" => Ok(ScmFileStatus::REMOVED),
                "IGNORED" => Ok(ScmFileStatus::IGNORED),
                _ => anyhow::bail!("Unable to parse {} as {}", string, "ScmFileStatus"),
            }
        }
    }

    impl GetTType for ScmFileStatus {
        const TTYPE: TType = TType::I32;
    }

    impl<P: ProtocolWriter> Serialize<P> for ScmFileStatus {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for ScmFileStatus {
        #[inline]
        fn read(p: &mut P) -> anyhow::Result<Self> {
            Ok(ScmFileStatus::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct CheckoutMode(pub i32);

    impl CheckoutMode {
        pub const NORMAL: Self = CheckoutMode(0i32);
        pub const DRY_RUN: Self = CheckoutMode(1i32);
        pub const FORCE: Self = CheckoutMode(2i32);
    }

    impl Default for CheckoutMode {
        fn default() -> Self {
            CheckoutMode(fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> From<&'a CheckoutMode> for i32 {
        #[inline]
        fn from(x: &'a CheckoutMode) -> i32 {
            x.0
        }
    }

    impl From<CheckoutMode> for i32 {
        #[inline]
        fn from(x: CheckoutMode) -> i32 {
            x.0
        }
    }

    impl From<i32> for CheckoutMode {
        #[inline]
        fn from(x: i32) -> Self {
            Self(x)
        }
    }

    impl std::fmt::Display for CheckoutMode {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            let s: &str = match *self {
                CheckoutMode::NORMAL => "NORMAL",
                CheckoutMode::DRY_RUN => "DRY_RUN",
                CheckoutMode::FORCE => "FORCE",
                CheckoutMode(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl std::fmt::Debug for CheckoutMode {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(fmt, "{}::{}", "CheckoutMode", self)
        }
    }

    impl std::str::FromStr for CheckoutMode {
        type Err = anyhow::Error;

        fn from_str(string: &str) -> std::result::Result<Self, Self::Err> {
            match string {
                "NORMAL" => Ok(CheckoutMode::NORMAL),
                "DRY_RUN" => Ok(CheckoutMode::DRY_RUN),
                "FORCE" => Ok(CheckoutMode::FORCE),
                _ => anyhow::bail!("Unable to parse {} as {}", string, "CheckoutMode"),
            }
        }
    }

    impl GetTType for CheckoutMode {
        const TTYPE: TType = TType::I32;
    }

    impl<P: ProtocolWriter> Serialize<P> for CheckoutMode {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for CheckoutMode {
        #[inline]
        fn read(p: &mut P) -> anyhow::Result<Self> {
            Ok(CheckoutMode::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ConflictType(pub i32);

    impl ConflictType {
        pub const ERROR: Self = ConflictType(0i32);
        pub const MODIFIED_REMOVED: Self = ConflictType(1i32);
        pub const UNTRACKED_ADDED: Self = ConflictType(2i32);
        pub const REMOVED_MODIFIED: Self = ConflictType(3i32);
        pub const MISSING_REMOVED: Self = ConflictType(4i32);
        pub const MODIFIED_MODIFIED: Self = ConflictType(5i32);
        pub const DIRECTORY_NOT_EMPTY: Self = ConflictType(6i32);
    }

    impl Default for ConflictType {
        fn default() -> Self {
            ConflictType(fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> From<&'a ConflictType> for i32 {
        #[inline]
        fn from(x: &'a ConflictType) -> i32 {
            x.0
        }
    }

    impl From<ConflictType> for i32 {
        #[inline]
        fn from(x: ConflictType) -> i32 {
            x.0
        }
    }

    impl From<i32> for ConflictType {
        #[inline]
        fn from(x: i32) -> Self {
            Self(x)
        }
    }

    impl std::fmt::Display for ConflictType {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            let s: &str = match *self {
                ConflictType::ERROR => "ERROR",
                ConflictType::MODIFIED_REMOVED => "MODIFIED_REMOVED",
                ConflictType::UNTRACKED_ADDED => "UNTRACKED_ADDED",
                ConflictType::REMOVED_MODIFIED => "REMOVED_MODIFIED",
                ConflictType::MISSING_REMOVED => "MISSING_REMOVED",
                ConflictType::MODIFIED_MODIFIED => "MODIFIED_MODIFIED",
                ConflictType::DIRECTORY_NOT_EMPTY => "DIRECTORY_NOT_EMPTY",
                ConflictType(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl std::fmt::Debug for ConflictType {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(fmt, "{}::{}", "ConflictType", self)
        }
    }

    impl std::str::FromStr for ConflictType {
        type Err = anyhow::Error;

        fn from_str(string: &str) -> std::result::Result<Self, Self::Err> {
            match string {
                "ERROR" => Ok(ConflictType::ERROR),
                "MODIFIED_REMOVED" => Ok(ConflictType::MODIFIED_REMOVED),
                "UNTRACKED_ADDED" => Ok(ConflictType::UNTRACKED_ADDED),
                "REMOVED_MODIFIED" => Ok(ConflictType::REMOVED_MODIFIED),
                "MISSING_REMOVED" => Ok(ConflictType::MISSING_REMOVED),
                "MODIFIED_MODIFIED" => Ok(ConflictType::MODIFIED_MODIFIED),
                "DIRECTORY_NOT_EMPTY" => Ok(ConflictType::DIRECTORY_NOT_EMPTY),
                _ => anyhow::bail!("Unable to parse {} as {}", string, "ConflictType"),
            }
        }
    }

    impl GetTType for ConflictType {
        const TTYPE: TType = TType::I32;
    }

    impl<P: ProtocolWriter> Serialize<P> for ConflictType {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for ConflictType {
        #[inline]
        fn read(p: &mut P) -> anyhow::Result<Self> {
            Ok(ConflictType::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct TracePointEvent(pub i32);

    impl TracePointEvent {
        pub const START: Self = TracePointEvent(0i32);
        pub const STOP: Self = TracePointEvent(1i32);
    }

    impl Default for TracePointEvent {
        fn default() -> Self {
            TracePointEvent(fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> From<&'a TracePointEvent> for i32 {
        #[inline]
        fn from(x: &'a TracePointEvent) -> i32 {
            x.0
        }
    }

    impl From<TracePointEvent> for i32 {
        #[inline]
        fn from(x: TracePointEvent) -> i32 {
            x.0
        }
    }

    impl From<i32> for TracePointEvent {
        #[inline]
        fn from(x: i32) -> Self {
            Self(x)
        }
    }

    impl std::fmt::Display for TracePointEvent {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            let s: &str = match *self {
                TracePointEvent::START => "START",
                TracePointEvent::STOP => "STOP",
                TracePointEvent(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl std::fmt::Debug for TracePointEvent {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(fmt, "{}::{}", "TracePointEvent", self)
        }
    }

    impl std::str::FromStr for TracePointEvent {
        type Err = anyhow::Error;

        fn from_str(string: &str) -> std::result::Result<Self, Self::Err> {
            match string {
                "START" => Ok(TracePointEvent::START),
                "STOP" => Ok(TracePointEvent::STOP),
                _ => anyhow::bail!("Unable to parse {} as {}", string, "TracePointEvent"),
            }
        }
    }

    impl GetTType for TracePointEvent {
        const TTYPE: TType = TType::I32;
    }

    impl<P: ProtocolWriter> Serialize<P> for TracePointEvent {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for TracePointEvent {
        #[inline]
        fn read(p: &mut P) -> anyhow::Result<Self> {
            Ok(TracePointEvent::from(p.read_i32()?))
        }
    }






    impl Default for self::EdenError {
        fn default() -> Self {
            Self {
                message: Default::default(),
                errorCode: None,
                errorType: Default::default(),
            }
        }
    }

    impl GetTType for self::EdenError {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::EdenError {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EdenError");
            p.write_field_begin("message", TType::String, 1);
            Serialize::write(&self.message, p);
            p.write_field_end();
            if let Some(some) = &self.errorCode {
                p.write_field_begin("errorCode", TType::I32, 2);
                Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_begin("errorType", TType::I32, 3);
            Serialize::write(&self.errorType, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::EdenError {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_message = None;
            let mut field_errorCode = None;
            let mut field_errorType = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_message = Some(Deserialize::read(p)?),
                    (TType::I32, 2) => field_errorCode = Some(Deserialize::read(p)?),
                    (TType::I32, 3) => field_errorType = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                message: field_message.unwrap_or_default(),
                errorCode: field_errorCode,
                errorType: field_errorType.unwrap_or_default(),
            })
        }
    }


    impl Default for self::NoValueForKeyError {
        fn default() -> Self {
            Self {
                key: Default::default(),
            }
        }
    }

    impl GetTType for self::NoValueForKeyError {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::NoValueForKeyError {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("NoValueForKeyError");
            p.write_field_begin("key", TType::String, 1);
            Serialize::write(&self.key, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::NoValueForKeyError {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_key = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_key = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                key: field_key.unwrap_or_default(),
            })
        }
    }


    impl Default for self::DaemonInfo {
        fn default() -> Self {
            Self {
                pid: Default::default(),
                commandLine: Default::default(),
            }
        }
    }

    impl GetTType for self::DaemonInfo {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::DaemonInfo {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DaemonInfo");
            p.write_field_begin("pid", TType::I32, 1);
            Serialize::write(&self.pid, p);
            p.write_field_end();
            p.write_field_begin("commandLine", TType::List, 2);
            Serialize::write(&self.commandLine, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::DaemonInfo {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_pid = None;
            let mut field_commandLine = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I32, 1) => field_pid = Some(Deserialize::read(p)?),
                    (TType::List, 2) => field_commandLine = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                pid: field_pid.unwrap_or_default(),
                commandLine: field_commandLine.unwrap_or_default(),
            })
        }
    }


    impl Default for self::MountInfo {
        fn default() -> Self {
            Self {
                mountPoint: Default::default(),
                edenClientPath: Default::default(),
                state: Default::default(),
            }
        }
    }

    impl GetTType for self::MountInfo {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::MountInfo {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MountInfo");
            p.write_field_begin("mountPoint", TType::String, 1);
            Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("edenClientPath", TType::String, 2);
            Serialize::write(&self.edenClientPath, p);
            p.write_field_end();
            p.write_field_begin("state", TType::I32, 3);
            Serialize::write(&self.state, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::MountInfo {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_mountPoint = None;
            let mut field_edenClientPath = None;
            let mut field_state = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_edenClientPath = Some(Deserialize::read(p)?),
                    (TType::I32, 3) => field_state = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                edenClientPath: field_edenClientPath.unwrap_or_default(),
                state: field_state.unwrap_or_default(),
            })
        }
    }


    impl Default for self::MountArgument {
        fn default() -> Self {
            Self {
                mountPoint: Default::default(),
                edenClientPath: Default::default(),
            }
        }
    }

    impl GetTType for self::MountArgument {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::MountArgument {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MountArgument");
            p.write_field_begin("mountPoint", TType::String, 1);
            Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("edenClientPath", TType::String, 2);
            Serialize::write(&self.edenClientPath, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::MountArgument {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_mountPoint = None;
            let mut field_edenClientPath = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_edenClientPath = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                edenClientPath: field_edenClientPath.unwrap_or_default(),
            })
        }
    }



    impl Default for SHA1Result {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl GetTType for SHA1Result {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for SHA1Result {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SHA1Result");
            match self {
                SHA1Result::sha1(inner) => {
                    p.write_field_begin("sha1", TType::String, 1);
                    Serialize::write(inner, p);
                    p.write_field_end();
                }
                SHA1Result::error(inner) => {
                    p.write_field_begin("error", TType::Struct, 2);
                    Serialize::write(inner, p);
                    p.write_field_end();
                }
                SHA1Result::UnknownField(x) => {
                    p.write_field_begin("UnknownField", TType::I32, *x as i16);
                    x.write(p);
                    p.write_field_end();
                }
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for SHA1Result {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32, once) {
                    (TType::Stop, _, _) => break,
                    (TType::String, 1, false) => {
                        once = true;
                        alt = Some(SHA1Result::sha1(Deserialize::read(p)?));
                    }
                    (TType::Struct, 2, false) => {
                        once = true;
                        alt = Some(SHA1Result::error(Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return Err(From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "SHA1Result",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(alt.unwrap_or_default())
        }
    }

    impl Default for self::TimeSpec {
        fn default() -> Self {
            Self {
                seconds: Default::default(),
                nanoSeconds: Default::default(),
            }
        }
    }

    impl GetTType for self::TimeSpec {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::TimeSpec {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TimeSpec");
            p.write_field_begin("seconds", TType::I64, 1);
            Serialize::write(&self.seconds, p);
            p.write_field_end();
            p.write_field_begin("nanoSeconds", TType::I64, 2);
            Serialize::write(&self.nanoSeconds, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::TimeSpec {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_seconds = None;
            let mut field_nanoSeconds = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I64, 1) => field_seconds = Some(Deserialize::read(p)?),
                    (TType::I64, 2) => field_nanoSeconds = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                seconds: field_seconds.unwrap_or_default(),
                nanoSeconds: field_nanoSeconds.unwrap_or_default(),
            })
        }
    }


    impl Default for self::FileInformation {
        fn default() -> Self {
            Self {
                size: Default::default(),
                mtime: Default::default(),
                mode: Default::default(),
            }
        }
    }

    impl GetTType for self::FileInformation {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::FileInformation {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FileInformation");
            p.write_field_begin("size", TType::I64, 1);
            Serialize::write(&self.size, p);
            p.write_field_end();
            p.write_field_begin("mtime", TType::Struct, 2);
            Serialize::write(&self.mtime, p);
            p.write_field_end();
            p.write_field_begin("mode", TType::I32, 3);
            Serialize::write(&self.mode, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::FileInformation {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_size = None;
            let mut field_mtime = None;
            let mut field_mode = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I64, 1) => field_size = Some(Deserialize::read(p)?),
                    (TType::Struct, 2) => field_mtime = Some(Deserialize::read(p)?),
                    (TType::I32, 3) => field_mode = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                size: field_size.unwrap_or_default(),
                mtime: field_mtime.unwrap_or_default(),
                mode: field_mode.unwrap_or_default(),
            })
        }
    }



    impl Default for FileInformationOrError {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl GetTType for FileInformationOrError {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for FileInformationOrError {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FileInformationOrError");
            match self {
                FileInformationOrError::info(inner) => {
                    p.write_field_begin("info", TType::Struct, 1);
                    Serialize::write(inner, p);
                    p.write_field_end();
                }
                FileInformationOrError::error(inner) => {
                    p.write_field_begin("error", TType::Struct, 2);
                    Serialize::write(inner, p);
                    p.write_field_end();
                }
                FileInformationOrError::UnknownField(x) => {
                    p.write_field_begin("UnknownField", TType::I32, *x as i16);
                    x.write(p);
                    p.write_field_end();
                }
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for FileInformationOrError {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32, once) {
                    (TType::Stop, _, _) => break,
                    (TType::Struct, 1, false) => {
                        once = true;
                        alt = Some(FileInformationOrError::info(Deserialize::read(p)?));
                    }
                    (TType::Struct, 2, false) => {
                        once = true;
                        alt = Some(FileInformationOrError::error(Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return Err(From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "FileInformationOrError",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(alt.unwrap_or_default())
        }
    }

    impl Default for self::JournalPosition {
        fn default() -> Self {
            Self {
                mountGeneration: Default::default(),
                sequenceNumber: Default::default(),
                snapshotHash: Default::default(),
            }
        }
    }

    impl GetTType for self::JournalPosition {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::JournalPosition {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("JournalPosition");
            p.write_field_begin("mountGeneration", TType::I64, 1);
            Serialize::write(&self.mountGeneration, p);
            p.write_field_end();
            p.write_field_begin("sequenceNumber", TType::I64, 2);
            Serialize::write(&self.sequenceNumber, p);
            p.write_field_end();
            p.write_field_begin("snapshotHash", TType::String, 3);
            Serialize::write(&self.snapshotHash, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::JournalPosition {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_mountGeneration = None;
            let mut field_sequenceNumber = None;
            let mut field_snapshotHash = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I64, 1) => field_mountGeneration = Some(Deserialize::read(p)?),
                    (TType::I64, 2) => field_sequenceNumber = Some(Deserialize::read(p)?),
                    (TType::String, 3) => field_snapshotHash = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                mountGeneration: field_mountGeneration.unwrap_or_default(),
                sequenceNumber: field_sequenceNumber.unwrap_or_default(),
                snapshotHash: field_snapshotHash.unwrap_or_default(),
            })
        }
    }


    impl Default for self::FileDelta {
        fn default() -> Self {
            Self {
                fromPosition: Default::default(),
                toPosition: Default::default(),
                changedPaths: Default::default(),
                createdPaths: Default::default(),
                removedPaths: Default::default(),
                uncleanPaths: Default::default(),
            }
        }
    }

    impl GetTType for self::FileDelta {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::FileDelta {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FileDelta");
            p.write_field_begin("fromPosition", TType::Struct, 1);
            Serialize::write(&self.fromPosition, p);
            p.write_field_end();
            p.write_field_begin("toPosition", TType::Struct, 2);
            Serialize::write(&self.toPosition, p);
            p.write_field_end();
            p.write_field_begin("changedPaths", TType::List, 3);
            Serialize::write(&self.changedPaths, p);
            p.write_field_end();
            p.write_field_begin("createdPaths", TType::List, 4);
            Serialize::write(&self.createdPaths, p);
            p.write_field_end();
            p.write_field_begin("removedPaths", TType::List, 5);
            Serialize::write(&self.removedPaths, p);
            p.write_field_end();
            p.write_field_begin("uncleanPaths", TType::List, 6);
            Serialize::write(&self.uncleanPaths, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::FileDelta {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_fromPosition = None;
            let mut field_toPosition = None;
            let mut field_changedPaths = None;
            let mut field_createdPaths = None;
            let mut field_removedPaths = None;
            let mut field_uncleanPaths = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Struct, 1) => field_fromPosition = Some(Deserialize::read(p)?),
                    (TType::Struct, 2) => field_toPosition = Some(Deserialize::read(p)?),
                    (TType::List, 3) => field_changedPaths = Some(Deserialize::read(p)?),
                    (TType::List, 4) => field_createdPaths = Some(Deserialize::read(p)?),
                    (TType::List, 5) => field_removedPaths = Some(Deserialize::read(p)?),
                    (TType::List, 6) => field_uncleanPaths = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                fromPosition: field_fromPosition.unwrap_or_default(),
                toPosition: field_toPosition.unwrap_or_default(),
                changedPaths: field_changedPaths.unwrap_or_default(),
                createdPaths: field_createdPaths.unwrap_or_default(),
                removedPaths: field_removedPaths.unwrap_or_default(),
                uncleanPaths: field_uncleanPaths.unwrap_or_default(),
            })
        }
    }


    impl Default for self::DebugGetRawJournalParams {
        fn default() -> Self {
            Self {
                mountPoint: Default::default(),
                limit: None,
                fromSequenceNumber: Default::default(),
            }
        }
    }

    impl GetTType for self::DebugGetRawJournalParams {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::DebugGetRawJournalParams {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DebugGetRawJournalParams");
            p.write_field_begin("mountPoint", TType::String, 1);
            Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            if let Some(some) = &self.limit {
                p.write_field_begin("limit", TType::I32, 2);
                Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_begin("fromSequenceNumber", TType::I32, 3);
            Serialize::write(&self.fromSequenceNumber, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::DebugGetRawJournalParams {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_mountPoint = None;
            let mut field_limit = None;
            let mut field_fromSequenceNumber = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::I32, 2) => field_limit = Some(Deserialize::read(p)?),
                    (TType::I32, 3) => field_fromSequenceNumber = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                limit: field_limit,
                fromSequenceNumber: field_fromSequenceNumber.unwrap_or_default(),
            })
        }
    }


    impl Default for self::DebugPathChangeInfo {
        fn default() -> Self {
            Self {
                existedBefore: Default::default(),
                existedAfter: Default::default(),
            }
        }
    }

    impl GetTType for self::DebugPathChangeInfo {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::DebugPathChangeInfo {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DebugPathChangeInfo");
            p.write_field_begin("existedBefore", TType::Bool, 1);
            Serialize::write(&self.existedBefore, p);
            p.write_field_end();
            p.write_field_begin("existedAfter", TType::Bool, 2);
            Serialize::write(&self.existedAfter, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::DebugPathChangeInfo {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_existedBefore = None;
            let mut field_existedAfter = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Bool, 1) => field_existedBefore = Some(Deserialize::read(p)?),
                    (TType::Bool, 2) => field_existedAfter = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                existedBefore: field_existedBefore.unwrap_or_default(),
                existedAfter: field_existedAfter.unwrap_or_default(),
            })
        }
    }


    impl Default for self::DebugJournalDelta {
        fn default() -> Self {
            Self {
                fromPosition: Default::default(),
                toPosition: Default::default(),
                changedPaths: Default::default(),
                uncleanPaths: Default::default(),
            }
        }
    }

    impl GetTType for self::DebugJournalDelta {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::DebugJournalDelta {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DebugJournalDelta");
            p.write_field_begin("fromPosition", TType::Struct, 1);
            Serialize::write(&self.fromPosition, p);
            p.write_field_end();
            p.write_field_begin("toPosition", TType::Struct, 2);
            Serialize::write(&self.toPosition, p);
            p.write_field_end();
            p.write_field_begin("changedPaths", TType::Map, 3);
            Serialize::write(&self.changedPaths, p);
            p.write_field_end();
            p.write_field_begin("uncleanPaths", TType::Set, 4);
            Serialize::write(&self.uncleanPaths, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::DebugJournalDelta {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_fromPosition = None;
            let mut field_toPosition = None;
            let mut field_changedPaths = None;
            let mut field_uncleanPaths = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Struct, 1) => field_fromPosition = Some(Deserialize::read(p)?),
                    (TType::Struct, 2) => field_toPosition = Some(Deserialize::read(p)?),
                    (TType::Map, 3) => field_changedPaths = Some(Deserialize::read(p)?),
                    (TType::Set, 4) => field_uncleanPaths = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                fromPosition: field_fromPosition.unwrap_or_default(),
                toPosition: field_toPosition.unwrap_or_default(),
                changedPaths: field_changedPaths.unwrap_or_default(),
                uncleanPaths: field_uncleanPaths.unwrap_or_default(),
            })
        }
    }


    impl Default for self::DebugGetRawJournalResponse {
        fn default() -> Self {
            Self {
                allDeltas: Default::default(),
            }
        }
    }

    impl GetTType for self::DebugGetRawJournalResponse {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::DebugGetRawJournalResponse {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DebugGetRawJournalResponse");
            p.write_field_begin("allDeltas", TType::List, 2);
            Serialize::write(&self.allDeltas, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::DebugGetRawJournalResponse {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_allDeltas = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::List, 2) => field_allDeltas = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                allDeltas: field_allDeltas.unwrap_or_default(),
            })
        }
    }


    impl Default for self::ScmStatus {
        fn default() -> Self {
            Self {
                entries: Default::default(),
                errors: Default::default(),
            }
        }
    }

    impl GetTType for self::ScmStatus {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::ScmStatus {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScmStatus");
            p.write_field_begin("entries", TType::Map, 1);
            Serialize::write(&self.entries, p);
            p.write_field_end();
            p.write_field_begin("errors", TType::Map, 2);
            Serialize::write(&self.errors, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::ScmStatus {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_entries = None;
            let mut field_errors = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Map, 1) => field_entries = Some(Deserialize::read(p)?),
                    (TType::Map, 2) => field_errors = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                entries: field_entries.unwrap_or_default(),
                errors: field_errors.unwrap_or_default(),
            })
        }
    }


    impl Default for self::CheckoutConflict {
        fn default() -> Self {
            Self {
                path: Default::default(),
                type_: Default::default(),
                message: Default::default(),
            }
        }
    }

    impl GetTType for self::CheckoutConflict {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::CheckoutConflict {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CheckoutConflict");
            p.write_field_begin("path", TType::String, 1);
            Serialize::write(&self.path, p);
            p.write_field_end();
            p.write_field_begin("type", TType::I32, 2);
            Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_begin("message", TType::String, 3);
            Serialize::write(&self.message, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::CheckoutConflict {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_path = None;
            let mut field_type = None;
            let mut field_message = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_path = Some(Deserialize::read(p)?),
                    (TType::I32, 2) => field_type = Some(Deserialize::read(p)?),
                    (TType::String, 3) => field_message = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                path: field_path.unwrap_or_default(),
                type_: field_type.unwrap_or_default(),
                message: field_message.unwrap_or_default(),
            })
        }
    }


    impl Default for self::ScmBlobMetadata {
        fn default() -> Self {
            Self {
                size: Default::default(),
                contentsSha1: Default::default(),
            }
        }
    }

    impl GetTType for self::ScmBlobMetadata {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::ScmBlobMetadata {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScmBlobMetadata");
            p.write_field_begin("size", TType::I64, 1);
            Serialize::write(&self.size, p);
            p.write_field_end();
            p.write_field_begin("contentsSha1", TType::String, 2);
            Serialize::write(&self.contentsSha1, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::ScmBlobMetadata {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_size = None;
            let mut field_contentsSha1 = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I64, 1) => field_size = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_contentsSha1 = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                size: field_size.unwrap_or_default(),
                contentsSha1: field_contentsSha1.unwrap_or_default(),
            })
        }
    }


    impl Default for self::ScmTreeEntry {
        fn default() -> Self {
            Self {
                name: Default::default(),
                mode: Default::default(),
                id: Default::default(),
            }
        }
    }

    impl GetTType for self::ScmTreeEntry {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::ScmTreeEntry {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScmTreeEntry");
            p.write_field_begin("name", TType::String, 1);
            Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("mode", TType::I32, 2);
            Serialize::write(&self.mode, p);
            p.write_field_end();
            p.write_field_begin("id", TType::String, 3);
            Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::ScmTreeEntry {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_name = None;
            let mut field_mode = None;
            let mut field_id = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_name = Some(Deserialize::read(p)?),
                    (TType::I32, 2) => field_mode = Some(Deserialize::read(p)?),
                    (TType::String, 3) => field_id = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                name: field_name.unwrap_or_default(),
                mode: field_mode.unwrap_or_default(),
                id: field_id.unwrap_or_default(),
            })
        }
    }


    impl Default for self::TreeInodeEntryDebugInfo {
        fn default() -> Self {
            Self {
                name: Default::default(),
                inodeNumber: Default::default(),
                mode: Default::default(),
                loaded: Default::default(),
                materialized: Default::default(),
                hash: Default::default(),
                fileSize: None,
            }
        }
    }

    impl GetTType for self::TreeInodeEntryDebugInfo {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::TreeInodeEntryDebugInfo {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TreeInodeEntryDebugInfo");
            p.write_field_begin("name", TType::String, 1);
            Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("inodeNumber", TType::I64, 2);
            Serialize::write(&self.inodeNumber, p);
            p.write_field_end();
            p.write_field_begin("mode", TType::I32, 3);
            Serialize::write(&self.mode, p);
            p.write_field_end();
            p.write_field_begin("loaded", TType::Bool, 4);
            Serialize::write(&self.loaded, p);
            p.write_field_end();
            p.write_field_begin("materialized", TType::Bool, 5);
            Serialize::write(&self.materialized, p);
            p.write_field_end();
            p.write_field_begin("hash", TType::String, 6);
            Serialize::write(&self.hash, p);
            p.write_field_end();
            if let Some(some) = &self.fileSize {
                p.write_field_begin("fileSize", TType::I64, 7);
                Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::TreeInodeEntryDebugInfo {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_name = None;
            let mut field_inodeNumber = None;
            let mut field_mode = None;
            let mut field_loaded = None;
            let mut field_materialized = None;
            let mut field_hash = None;
            let mut field_fileSize = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_name = Some(Deserialize::read(p)?),
                    (TType::I64, 2) => field_inodeNumber = Some(Deserialize::read(p)?),
                    (TType::I32, 3) => field_mode = Some(Deserialize::read(p)?),
                    (TType::Bool, 4) => field_loaded = Some(Deserialize::read(p)?),
                    (TType::Bool, 5) => field_materialized = Some(Deserialize::read(p)?),
                    (TType::String, 6) => field_hash = Some(Deserialize::read(p)?),
                    (TType::I64, 7) => field_fileSize = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                name: field_name.unwrap_or_default(),
                inodeNumber: field_inodeNumber.unwrap_or_default(),
                mode: field_mode.unwrap_or_default(),
                loaded: field_loaded.unwrap_or_default(),
                materialized: field_materialized.unwrap_or_default(),
                hash: field_hash.unwrap_or_default(),
                fileSize: field_fileSize,
            })
        }
    }


    impl Default for self::WorkingDirectoryParents {
        fn default() -> Self {
            Self {
                parent1: Default::default(),
                parent2: None,
            }
        }
    }

    impl GetTType for self::WorkingDirectoryParents {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::WorkingDirectoryParents {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("WorkingDirectoryParents");
            p.write_field_begin("parent1", TType::String, 1);
            Serialize::write(&self.parent1, p);
            p.write_field_end();
            if let Some(some) = &self.parent2 {
                p.write_field_begin("parent2", TType::String, 2);
                Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::WorkingDirectoryParents {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_parent1 = None;
            let mut field_parent2 = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_parent1 = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_parent2 = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                parent1: field_parent1.unwrap_or_default(),
                parent2: field_parent2,
            })
        }
    }


    impl Default for self::TreeInodeDebugInfo {
        fn default() -> Self {
            Self {
                inodeNumber: Default::default(),
                path: Default::default(),
                materialized: Default::default(),
                treeHash: Default::default(),
                entries: Default::default(),
                refcount: Default::default(),
            }
        }
    }

    impl GetTType for self::TreeInodeDebugInfo {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::TreeInodeDebugInfo {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TreeInodeDebugInfo");
            p.write_field_begin("inodeNumber", TType::I64, 1);
            Serialize::write(&self.inodeNumber, p);
            p.write_field_end();
            p.write_field_begin("path", TType::String, 2);
            Serialize::write(&self.path, p);
            p.write_field_end();
            p.write_field_begin("materialized", TType::Bool, 3);
            Serialize::write(&self.materialized, p);
            p.write_field_end();
            p.write_field_begin("treeHash", TType::String, 4);
            Serialize::write(&self.treeHash, p);
            p.write_field_end();
            p.write_field_begin("entries", TType::List, 5);
            Serialize::write(&self.entries, p);
            p.write_field_end();
            p.write_field_begin("refcount", TType::I64, 6);
            Serialize::write(&self.refcount, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::TreeInodeDebugInfo {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_inodeNumber = None;
            let mut field_path = None;
            let mut field_materialized = None;
            let mut field_treeHash = None;
            let mut field_entries = None;
            let mut field_refcount = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I64, 1) => field_inodeNumber = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_path = Some(Deserialize::read(p)?),
                    (TType::Bool, 3) => field_materialized = Some(Deserialize::read(p)?),
                    (TType::String, 4) => field_treeHash = Some(Deserialize::read(p)?),
                    (TType::List, 5) => field_entries = Some(Deserialize::read(p)?),
                    (TType::I64, 6) => field_refcount = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                inodeNumber: field_inodeNumber.unwrap_or_default(),
                path: field_path.unwrap_or_default(),
                materialized: field_materialized.unwrap_or_default(),
                treeHash: field_treeHash.unwrap_or_default(),
                entries: field_entries.unwrap_or_default(),
                refcount: field_refcount.unwrap_or_default(),
            })
        }
    }


    impl Default for self::InodePathDebugInfo {
        fn default() -> Self {
            Self {
                path: Default::default(),
                loaded: Default::default(),
                linked: Default::default(),
            }
        }
    }

    impl GetTType for self::InodePathDebugInfo {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::InodePathDebugInfo {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("InodePathDebugInfo");
            p.write_field_begin("path", TType::String, 1);
            Serialize::write(&self.path, p);
            p.write_field_end();
            p.write_field_begin("loaded", TType::Bool, 2);
            Serialize::write(&self.loaded, p);
            p.write_field_end();
            p.write_field_begin("linked", TType::Bool, 3);
            Serialize::write(&self.linked, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::InodePathDebugInfo {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_path = None;
            let mut field_loaded = None;
            let mut field_linked = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_path = Some(Deserialize::read(p)?),
                    (TType::Bool, 2) => field_loaded = Some(Deserialize::read(p)?),
                    (TType::Bool, 3) => field_linked = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                path: field_path.unwrap_or_default(),
                loaded: field_loaded.unwrap_or_default(),
                linked: field_linked.unwrap_or_default(),
            })
        }
    }


    impl Default for self::SetLogLevelResult {
        fn default() -> Self {
            Self {
                categoryCreated: Default::default(),
            }
        }
    }

    impl GetTType for self::SetLogLevelResult {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::SetLogLevelResult {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SetLogLevelResult");
            p.write_field_begin("categoryCreated", TType::Bool, 1);
            Serialize::write(&self.categoryCreated, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::SetLogLevelResult {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_categoryCreated = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Bool, 1) => field_categoryCreated = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                categoryCreated: field_categoryCreated.unwrap_or_default(),
            })
        }
    }


    impl Default for self::JournalInfo {
        fn default() -> Self {
            Self {
                entryCount: Default::default(),
                memoryUsage: Default::default(),
                durationSeconds: Default::default(),
            }
        }
    }

    impl GetTType for self::JournalInfo {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::JournalInfo {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("JournalInfo");
            p.write_field_begin("entryCount", TType::I64, 1);
            Serialize::write(&self.entryCount, p);
            p.write_field_end();
            p.write_field_begin("memoryUsage", TType::I64, 2);
            Serialize::write(&self.memoryUsage, p);
            p.write_field_end();
            p.write_field_begin("durationSeconds", TType::I64, 3);
            Serialize::write(&self.durationSeconds, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::JournalInfo {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_entryCount = None;
            let mut field_memoryUsage = None;
            let mut field_durationSeconds = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I64, 1) => field_entryCount = Some(Deserialize::read(p)?),
                    (TType::I64, 2) => field_memoryUsage = Some(Deserialize::read(p)?),
                    (TType::I64, 3) => field_durationSeconds = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                entryCount: field_entryCount.unwrap_or_default(),
                memoryUsage: field_memoryUsage.unwrap_or_default(),
                durationSeconds: field_durationSeconds.unwrap_or_default(),
            })
        }
    }


    impl Default for self::MountInodeInfo {
        fn default() -> Self {
            Self {
                unloadedInodeCount: Default::default(),
                loadedFileCount: Default::default(),
                loadedTreeCount: Default::default(),
            }
        }
    }

    impl GetTType for self::MountInodeInfo {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::MountInodeInfo {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MountInodeInfo");
            p.write_field_begin("unloadedInodeCount", TType::I64, 2);
            Serialize::write(&self.unloadedInodeCount, p);
            p.write_field_end();
            p.write_field_begin("loadedFileCount", TType::I64, 4);
            Serialize::write(&self.loadedFileCount, p);
            p.write_field_end();
            p.write_field_begin("loadedTreeCount", TType::I64, 5);
            Serialize::write(&self.loadedTreeCount, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::MountInodeInfo {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_unloadedInodeCount = None;
            let mut field_loadedFileCount = None;
            let mut field_loadedTreeCount = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I64, 2) => field_unloadedInodeCount = Some(Deserialize::read(p)?),
                    (TType::I64, 4) => field_loadedFileCount = Some(Deserialize::read(p)?),
                    (TType::I64, 5) => field_loadedTreeCount = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                unloadedInodeCount: field_unloadedInodeCount.unwrap_or_default(),
                loadedFileCount: field_loadedFileCount.unwrap_or_default(),
                loadedTreeCount: field_loadedTreeCount.unwrap_or_default(),
            })
        }
    }


    impl Default for self::CacheStats {
        fn default() -> Self {
            Self {
                entryCount: Default::default(),
                totalSizeInBytes: Default::default(),
                hitCount: Default::default(),
                missCount: Default::default(),
                evictionCount: Default::default(),
                dropCount: Default::default(),
            }
        }
    }

    impl GetTType for self::CacheStats {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::CacheStats {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CacheStats");
            p.write_field_begin("entryCount", TType::I64, 1);
            Serialize::write(&self.entryCount, p);
            p.write_field_end();
            p.write_field_begin("totalSizeInBytes", TType::I64, 2);
            Serialize::write(&self.totalSizeInBytes, p);
            p.write_field_end();
            p.write_field_begin("hitCount", TType::I64, 3);
            Serialize::write(&self.hitCount, p);
            p.write_field_end();
            p.write_field_begin("missCount", TType::I64, 4);
            Serialize::write(&self.missCount, p);
            p.write_field_end();
            p.write_field_begin("evictionCount", TType::I64, 5);
            Serialize::write(&self.evictionCount, p);
            p.write_field_end();
            p.write_field_begin("dropCount", TType::I64, 6);
            Serialize::write(&self.dropCount, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::CacheStats {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_entryCount = None;
            let mut field_totalSizeInBytes = None;
            let mut field_hitCount = None;
            let mut field_missCount = None;
            let mut field_evictionCount = None;
            let mut field_dropCount = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I64, 1) => field_entryCount = Some(Deserialize::read(p)?),
                    (TType::I64, 2) => field_totalSizeInBytes = Some(Deserialize::read(p)?),
                    (TType::I64, 3) => field_hitCount = Some(Deserialize::read(p)?),
                    (TType::I64, 4) => field_missCount = Some(Deserialize::read(p)?),
                    (TType::I64, 5) => field_evictionCount = Some(Deserialize::read(p)?),
                    (TType::I64, 6) => field_dropCount = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                entryCount: field_entryCount.unwrap_or_default(),
                totalSizeInBytes: field_totalSizeInBytes.unwrap_or_default(),
                hitCount: field_hitCount.unwrap_or_default(),
                missCount: field_missCount.unwrap_or_default(),
                evictionCount: field_evictionCount.unwrap_or_default(),
                dropCount: field_dropCount.unwrap_or_default(),
            })
        }
    }


    impl Default for self::InternalStats {
        fn default() -> Self {
            Self {
                periodicUnloadCount: Default::default(),
                counters: Default::default(),
                mountPointInfo: Default::default(),
                smaps: Default::default(),
                privateBytes: Default::default(),
                vmRSSBytes: Default::default(),
                blobCacheStats: Default::default(),
                mountPointJournalInfo: Default::default(),
            }
        }
    }

    impl GetTType for self::InternalStats {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::InternalStats {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("InternalStats");
            p.write_field_begin("periodicUnloadCount", TType::I64, 1);
            Serialize::write(&self.periodicUnloadCount, p);
            p.write_field_end();
            p.write_field_begin("counters", TType::Map, 2);
            Serialize::write(&self.counters, p);
            p.write_field_end();
            p.write_field_begin("mountPointInfo", TType::Map, 3);
            Serialize::write(&self.mountPointInfo, p);
            p.write_field_end();
            p.write_field_begin("smaps", TType::String, 4);
            Serialize::write(&self.smaps, p);
            p.write_field_end();
            p.write_field_begin("privateBytes", TType::I64, 5);
            Serialize::write(&self.privateBytes, p);
            p.write_field_end();
            p.write_field_begin("vmRSSBytes", TType::I64, 6);
            Serialize::write(&self.vmRSSBytes, p);
            p.write_field_end();
            p.write_field_begin("blobCacheStats", TType::Struct, 7);
            Serialize::write(&self.blobCacheStats, p);
            p.write_field_end();
            p.write_field_begin("mountPointJournalInfo", TType::Map, 8);
            Serialize::write(&self.mountPointJournalInfo, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::InternalStats {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_periodicUnloadCount = None;
            let mut field_counters = None;
            let mut field_mountPointInfo = None;
            let mut field_smaps = None;
            let mut field_privateBytes = None;
            let mut field_vmRSSBytes = None;
            let mut field_blobCacheStats = None;
            let mut field_mountPointJournalInfo = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I64, 1) => field_periodicUnloadCount = Some(Deserialize::read(p)?),
                    (TType::Map, 2) => field_counters = Some(Deserialize::read(p)?),
                    (TType::Map, 3) => field_mountPointInfo = Some(Deserialize::read(p)?),
                    (TType::String, 4) => field_smaps = Some(Deserialize::read(p)?),
                    (TType::I64, 5) => field_privateBytes = Some(Deserialize::read(p)?),
                    (TType::I64, 6) => field_vmRSSBytes = Some(Deserialize::read(p)?),
                    (TType::Struct, 7) => field_blobCacheStats = Some(Deserialize::read(p)?),
                    (TType::Map, 8) => field_mountPointJournalInfo = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                periodicUnloadCount: field_periodicUnloadCount.unwrap_or_default(),
                counters: field_counters.unwrap_or_default(),
                mountPointInfo: field_mountPointInfo.unwrap_or_default(),
                smaps: field_smaps.unwrap_or_default(),
                privateBytes: field_privateBytes.unwrap_or_default(),
                vmRSSBytes: field_vmRSSBytes.unwrap_or_default(),
                blobCacheStats: field_blobCacheStats.unwrap_or_default(),
                mountPointJournalInfo: field_mountPointJournalInfo.unwrap_or_default(),
            })
        }
    }


    impl Default for self::ManifestEntry {
        fn default() -> Self {
            Self {
                mode: Default::default(),
            }
        }
    }

    impl GetTType for self::ManifestEntry {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::ManifestEntry {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ManifestEntry");
            p.write_field_begin("mode", TType::I32, 1);
            Serialize::write(&self.mode, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::ManifestEntry {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_mode = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I32, 1) => field_mode = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                mode: field_mode.unwrap_or_default(),
            })
        }
    }


    impl Default for self::FuseCall {
        fn default() -> Self {
            Self {
                len: Default::default(),
                opcode: Default::default(),
                unique: Default::default(),
                nodeid: Default::default(),
                uid: Default::default(),
                gid: Default::default(),
                pid: Default::default(),
            }
        }
    }

    impl GetTType for self::FuseCall {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::FuseCall {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FuseCall");
            p.write_field_begin("len", TType::I32, 1);
            Serialize::write(&self.len, p);
            p.write_field_end();
            p.write_field_begin("opcode", TType::I32, 2);
            Serialize::write(&self.opcode, p);
            p.write_field_end();
            p.write_field_begin("unique", TType::I64, 3);
            Serialize::write(&self.unique, p);
            p.write_field_end();
            p.write_field_begin("nodeid", TType::I64, 4);
            Serialize::write(&self.nodeid, p);
            p.write_field_end();
            p.write_field_begin("uid", TType::I32, 5);
            Serialize::write(&self.uid, p);
            p.write_field_end();
            p.write_field_begin("gid", TType::I32, 6);
            Serialize::write(&self.gid, p);
            p.write_field_end();
            p.write_field_begin("pid", TType::I32, 7);
            Serialize::write(&self.pid, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::FuseCall {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_len = None;
            let mut field_opcode = None;
            let mut field_unique = None;
            let mut field_nodeid = None;
            let mut field_uid = None;
            let mut field_gid = None;
            let mut field_pid = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I32, 1) => field_len = Some(Deserialize::read(p)?),
                    (TType::I32, 2) => field_opcode = Some(Deserialize::read(p)?),
                    (TType::I64, 3) => field_unique = Some(Deserialize::read(p)?),
                    (TType::I64, 4) => field_nodeid = Some(Deserialize::read(p)?),
                    (TType::I32, 5) => field_uid = Some(Deserialize::read(p)?),
                    (TType::I32, 6) => field_gid = Some(Deserialize::read(p)?),
                    (TType::I32, 7) => field_pid = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                len: field_len.unwrap_or_default(),
                opcode: field_opcode.unwrap_or_default(),
                unique: field_unique.unwrap_or_default(),
                nodeid: field_nodeid.unwrap_or_default(),
                uid: field_uid.unwrap_or_default(),
                gid: field_gid.unwrap_or_default(),
                pid: field_pid.unwrap_or_default(),
            })
        }
    }


    impl Default for self::GetConfigParams {
        fn default() -> Self {
            Self {
                reload: eden_config::types::ConfigReloadBehavior::AutoReload,
            }
        }
    }

    impl GetTType for self::GetConfigParams {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::GetConfigParams {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetConfigParams");
            p.write_field_begin("reload", TType::I32, 1);
            Serialize::write(&self.reload, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::GetConfigParams {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_reload = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I32, 1) => field_reload = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                reload: field_reload.unwrap_or_else(|| eden_config::types::ConfigReloadBehavior::AutoReload),
            })
        }
    }


    impl Default for self::GlobParams {
        fn default() -> Self {
            Self {
                mountPoint: Default::default(),
                globs: Default::default(),
                includeDotfiles: Default::default(),
                prefetchFiles: Default::default(),
                suppressFileList: Default::default(),
                wantDtype: Default::default(),
            }
        }
    }

    impl GetTType for self::GlobParams {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::GlobParams {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GlobParams");
            p.write_field_begin("mountPoint", TType::String, 1);
            Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("globs", TType::List, 2);
            Serialize::write(&self.globs, p);
            p.write_field_end();
            p.write_field_begin("includeDotfiles", TType::Bool, 3);
            Serialize::write(&self.includeDotfiles, p);
            p.write_field_end();
            p.write_field_begin("prefetchFiles", TType::Bool, 4);
            Serialize::write(&self.prefetchFiles, p);
            p.write_field_end();
            p.write_field_begin("suppressFileList", TType::Bool, 5);
            Serialize::write(&self.suppressFileList, p);
            p.write_field_end();
            p.write_field_begin("wantDtype", TType::Bool, 6);
            Serialize::write(&self.wantDtype, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::GlobParams {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_mountPoint = None;
            let mut field_globs = None;
            let mut field_includeDotfiles = None;
            let mut field_prefetchFiles = None;
            let mut field_suppressFileList = None;
            let mut field_wantDtype = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::List, 2) => field_globs = Some(Deserialize::read(p)?),
                    (TType::Bool, 3) => field_includeDotfiles = Some(Deserialize::read(p)?),
                    (TType::Bool, 4) => field_prefetchFiles = Some(Deserialize::read(p)?),
                    (TType::Bool, 5) => field_suppressFileList = Some(Deserialize::read(p)?),
                    (TType::Bool, 6) => field_wantDtype = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                globs: field_globs.unwrap_or_default(),
                includeDotfiles: field_includeDotfiles.unwrap_or_default(),
                prefetchFiles: field_prefetchFiles.unwrap_or_default(),
                suppressFileList: field_suppressFileList.unwrap_or_default(),
                wantDtype: field_wantDtype.unwrap_or_default(),
            })
        }
    }


    impl Default for self::Glob {
        fn default() -> Self {
            Self {
                matchingFiles: Default::default(),
                dtypes: Default::default(),
            }
        }
    }

    impl GetTType for self::Glob {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::Glob {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Glob");
            p.write_field_begin("matchingFiles", TType::List, 1);
            Serialize::write(&self.matchingFiles, p);
            p.write_field_end();
            p.write_field_begin("dtypes", TType::List, 2);
            Serialize::write(&self.dtypes, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::Glob {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_matchingFiles = None;
            let mut field_dtypes = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::List, 1) => field_matchingFiles = Some(Deserialize::read(p)?),
                    (TType::List, 2) => field_dtypes = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                matchingFiles: field_matchingFiles.unwrap_or_default(),
                dtypes: field_dtypes.unwrap_or_default(),
            })
        }
    }


    impl Default for self::AccessCounts {
        fn default() -> Self {
            Self {
                fuseTotal: Default::default(),
                fuseReads: Default::default(),
                fuseWrites: Default::default(),
                fuseBackingStoreImports: Default::default(),
                fuseDurationNs: Default::default(),
            }
        }
    }

    impl GetTType for self::AccessCounts {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::AccessCounts {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AccessCounts");
            p.write_field_begin("fuseTotal", TType::I64, 1);
            Serialize::write(&self.fuseTotal, p);
            p.write_field_end();
            p.write_field_begin("fuseReads", TType::I64, 2);
            Serialize::write(&self.fuseReads, p);
            p.write_field_end();
            p.write_field_begin("fuseWrites", TType::I64, 3);
            Serialize::write(&self.fuseWrites, p);
            p.write_field_end();
            p.write_field_begin("fuseBackingStoreImports", TType::I64, 4);
            Serialize::write(&self.fuseBackingStoreImports, p);
            p.write_field_end();
            p.write_field_begin("fuseDurationNs", TType::I64, 5);
            Serialize::write(&self.fuseDurationNs, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::AccessCounts {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_fuseTotal = None;
            let mut field_fuseReads = None;
            let mut field_fuseWrites = None;
            let mut field_fuseBackingStoreImports = None;
            let mut field_fuseDurationNs = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I64, 1) => field_fuseTotal = Some(Deserialize::read(p)?),
                    (TType::I64, 2) => field_fuseReads = Some(Deserialize::read(p)?),
                    (TType::I64, 3) => field_fuseWrites = Some(Deserialize::read(p)?),
                    (TType::I64, 4) => field_fuseBackingStoreImports = Some(Deserialize::read(p)?),
                    (TType::I64, 5) => field_fuseDurationNs = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                fuseTotal: field_fuseTotal.unwrap_or_default(),
                fuseReads: field_fuseReads.unwrap_or_default(),
                fuseWrites: field_fuseWrites.unwrap_or_default(),
                fuseBackingStoreImports: field_fuseBackingStoreImports.unwrap_or_default(),
                fuseDurationNs: field_fuseDurationNs.unwrap_or_default(),
            })
        }
    }


    impl Default for self::MountAccesses {
        fn default() -> Self {
            Self {
                accessCountsByPid: Default::default(),
            }
        }
    }

    impl GetTType for self::MountAccesses {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::MountAccesses {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MountAccesses");
            p.write_field_begin("accessCountsByPid", TType::Map, 1);
            Serialize::write(&self.accessCountsByPid, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::MountAccesses {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_accessCountsByPid = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Map, 1) => field_accessCountsByPid = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                accessCountsByPid: field_accessCountsByPid.unwrap_or_default(),
            })
        }
    }


    impl Default for self::GetAccessCountsResult {
        fn default() -> Self {
            Self {
                cmdsByPid: Default::default(),
                accessesByMount: Default::default(),
            }
        }
    }

    impl GetTType for self::GetAccessCountsResult {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::GetAccessCountsResult {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetAccessCountsResult");
            p.write_field_begin("cmdsByPid", TType::Map, 1);
            Serialize::write(&self.cmdsByPid, p);
            p.write_field_end();
            p.write_field_begin("accessesByMount", TType::Map, 2);
            Serialize::write(&self.accessesByMount, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::GetAccessCountsResult {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_cmdsByPid = None;
            let mut field_accessesByMount = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Map, 1) => field_cmdsByPid = Some(Deserialize::read(p)?),
                    (TType::Map, 2) => field_accessesByMount = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                cmdsByPid: field_cmdsByPid.unwrap_or_default(),
                accessesByMount: field_accessesByMount.unwrap_or_default(),
            })
        }
    }


    impl Default for self::TracePoint {
        fn default() -> Self {
            Self {
                timestamp: Default::default(),
                traceId: Default::default(),
                blockId: Default::default(),
                parentBlockId: Default::default(),
                name: String::new(),
                event: Default::default(),
            }
        }
    }

    impl GetTType for self::TracePoint {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::TracePoint {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TracePoint");
            p.write_field_begin("timestamp", TType::I64, 1);
            Serialize::write(&self.timestamp, p);
            p.write_field_end();
            p.write_field_begin("traceId", TType::I64, 2);
            Serialize::write(&self.traceId, p);
            p.write_field_end();
            p.write_field_begin("blockId", TType::I64, 3);
            Serialize::write(&self.blockId, p);
            p.write_field_end();
            p.write_field_begin("parentBlockId", TType::I64, 4);
            Serialize::write(&self.parentBlockId, p);
            p.write_field_end();
            p.write_field_begin("name", TType::String, 5);
            Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("event", TType::I32, 6);
            Serialize::write(&self.event, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::TracePoint {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_timestamp = None;
            let mut field_traceId = None;
            let mut field_blockId = None;
            let mut field_parentBlockId = None;
            let mut field_name = None;
            let mut field_event = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I64, 1) => field_timestamp = Some(Deserialize::read(p)?),
                    (TType::I64, 2) => field_traceId = Some(Deserialize::read(p)?),
                    (TType::I64, 3) => field_blockId = Some(Deserialize::read(p)?),
                    (TType::I64, 4) => field_parentBlockId = Some(Deserialize::read(p)?),
                    (TType::String, 5) => field_name = Some(Deserialize::read(p)?),
                    (TType::I32, 6) => field_event = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                timestamp: field_timestamp.unwrap_or_default(),
                traceId: field_traceId.unwrap_or_default(),
                blockId: field_blockId.unwrap_or_default(),
                parentBlockId: field_parentBlockId.unwrap_or_default(),
                name: field_name.unwrap_or_else(|| String::new()),
                event: field_event.unwrap_or_default(),
            })
        }
    }


    impl Default for self::FaultDefinition {
        fn default() -> Self {
            Self {
                keyClass: Default::default(),
                keyValueRegex: Default::default(),
                count: Default::default(),
                block: Default::default(),
                delayMilliseconds: Default::default(),
                errorType: None,
                errorMessage: None,
            }
        }
    }

    impl GetTType for self::FaultDefinition {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::FaultDefinition {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FaultDefinition");
            p.write_field_begin("keyClass", TType::String, 1);
            Serialize::write(&self.keyClass, p);
            p.write_field_end();
            p.write_field_begin("keyValueRegex", TType::String, 2);
            Serialize::write(&self.keyValueRegex, p);
            p.write_field_end();
            p.write_field_begin("count", TType::I64, 3);
            Serialize::write(&self.count, p);
            p.write_field_end();
            p.write_field_begin("block", TType::Bool, 4);
            Serialize::write(&self.block, p);
            p.write_field_end();
            p.write_field_begin("delayMilliseconds", TType::I64, 5);
            Serialize::write(&self.delayMilliseconds, p);
            p.write_field_end();
            if let Some(some) = &self.errorType {
                p.write_field_begin("errorType", TType::String, 6);
                Serialize::write(some, p);
                p.write_field_end();
            }
            if let Some(some) = &self.errorMessage {
                p.write_field_begin("errorMessage", TType::String, 7);
                Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::FaultDefinition {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_keyClass = None;
            let mut field_keyValueRegex = None;
            let mut field_count = None;
            let mut field_block = None;
            let mut field_delayMilliseconds = None;
            let mut field_errorType = None;
            let mut field_errorMessage = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_keyClass = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_keyValueRegex = Some(Deserialize::read(p)?),
                    (TType::I64, 3) => field_count = Some(Deserialize::read(p)?),
                    (TType::Bool, 4) => field_block = Some(Deserialize::read(p)?),
                    (TType::I64, 5) => field_delayMilliseconds = Some(Deserialize::read(p)?),
                    (TType::String, 6) => field_errorType = Some(Deserialize::read(p)?),
                    (TType::String, 7) => field_errorMessage = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                keyClass: field_keyClass.unwrap_or_default(),
                keyValueRegex: field_keyValueRegex.unwrap_or_default(),
                count: field_count.unwrap_or_default(),
                block: field_block.unwrap_or_default(),
                delayMilliseconds: field_delayMilliseconds.unwrap_or_default(),
                errorType: field_errorType,
                errorMessage: field_errorMessage,
            })
        }
    }


    impl Default for self::RemoveFaultArg {
        fn default() -> Self {
            Self {
                keyClass: Default::default(),
                keyValueRegex: Default::default(),
            }
        }
    }

    impl GetTType for self::RemoveFaultArg {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::RemoveFaultArg {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RemoveFaultArg");
            p.write_field_begin("keyClass", TType::String, 1);
            Serialize::write(&self.keyClass, p);
            p.write_field_end();
            p.write_field_begin("keyValueRegex", TType::String, 2);
            Serialize::write(&self.keyValueRegex, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::RemoveFaultArg {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_keyClass = None;
            let mut field_keyValueRegex = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_keyClass = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_keyValueRegex = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                keyClass: field_keyClass.unwrap_or_default(),
                keyValueRegex: field_keyValueRegex.unwrap_or_default(),
            })
        }
    }


    impl Default for self::UnblockFaultArg {
        fn default() -> Self {
            Self {
                keyClass: None,
                keyValueRegex: None,
                errorType: None,
                errorMessage: None,
            }
        }
    }

    impl GetTType for self::UnblockFaultArg {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::UnblockFaultArg {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("UnblockFaultArg");
            if let Some(some) = &self.keyClass {
                p.write_field_begin("keyClass", TType::String, 1);
                Serialize::write(some, p);
                p.write_field_end();
            }
            if let Some(some) = &self.keyValueRegex {
                p.write_field_begin("keyValueRegex", TType::String, 2);
                Serialize::write(some, p);
                p.write_field_end();
            }
            if let Some(some) = &self.errorType {
                p.write_field_begin("errorType", TType::String, 3);
                Serialize::write(some, p);
                p.write_field_end();
            }
            if let Some(some) = &self.errorMessage {
                p.write_field_begin("errorMessage", TType::String, 4);
                Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::UnblockFaultArg {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_keyClass = None;
            let mut field_keyValueRegex = None;
            let mut field_errorType = None;
            let mut field_errorMessage = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_keyClass = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_keyValueRegex = Some(Deserialize::read(p)?),
                    (TType::String, 3) => field_errorType = Some(Deserialize::read(p)?),
                    (TType::String, 4) => field_errorMessage = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                keyClass: field_keyClass,
                keyValueRegex: field_keyValueRegex,
                errorType: field_errorType,
                errorMessage: field_errorMessage,
            })
        }
    }


    impl Default for self::GetScmStatusResult {
        fn default() -> Self {
            Self {
                status: Default::default(),
                version: Default::default(),
            }
        }
    }

    impl GetTType for self::GetScmStatusResult {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::GetScmStatusResult {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetScmStatusResult");
            p.write_field_begin("status", TType::Struct, 1);
            Serialize::write(&self.status, p);
            p.write_field_end();
            p.write_field_begin("version", TType::String, 2);
            Serialize::write(&self.version, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::GetScmStatusResult {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_status = None;
            let mut field_version = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Struct, 1) => field_status = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_version = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                status: field_status.unwrap_or_default(),
                version: field_version.unwrap_or_default(),
            })
        }
    }


    impl Default for self::GetScmStatusParams {
        fn default() -> Self {
            Self {
                mountPoint: Default::default(),
                commit: Default::default(),
                listIgnored: false,
            }
        }
    }

    impl GetTType for self::GetScmStatusParams {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::GetScmStatusParams {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetScmStatusParams");
            p.write_field_begin("mountPoint", TType::String, 1);
            Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("commit", TType::String, 2);
            Serialize::write(&self.commit, p);
            p.write_field_end();
            p.write_field_begin("listIgnored", TType::Bool, 3);
            Serialize::write(&self.listIgnored, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::GetScmStatusParams {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_mountPoint = None;
            let mut field_commit = None;
            let mut field_listIgnored = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_commit = Some(Deserialize::read(p)?),
                    (TType::Bool, 3) => field_listIgnored = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                commit: field_commit.unwrap_or_default(),
                listIgnored: field_listIgnored.unwrap_or_else(|| false),
            })
        }
    }

}

pub mod services {
    pub mod eden_service {
        use fbthrift::{
            ApplicationException, ApplicationExceptionErrorCode, Deserialize, ProtocolReader,
            ProtocolWriter, Serialize, TType,
        };

        #[derive(Clone, Debug)]
        pub enum ListMountsExn {
            Success(Vec<crate::types::MountInfo>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for ListMountsExn {
            fn default() -> Self {
                ListMountsExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for ListMountsExn {
            fn from(exn: crate::types::EdenError) -> Self {
                ListMountsExn::ex(exn)
            }
        }

        impl From<ApplicationException> for ListMountsExn {
            fn from(exn: ApplicationException) -> Self {
                ListMountsExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for ListMountsExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for ListMountsExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListMounts");
                match self {
                    ListMountsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListMountsExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListMountsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    ListMountsExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for ListMountsExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::List, 0i32), false) => {
                            once = true;
                            alt = Some(ListMountsExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(ListMountsExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListMountsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListMountsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum MountExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for MountExn {
            fn default() -> Self {
                MountExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for MountExn {
            fn from(exn: crate::types::EdenError) -> Self {
                MountExn::ex(exn)
            }
        }

        impl From<ApplicationException> for MountExn {
            fn from(exn: ApplicationException) -> Self {
                MountExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for MountExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for MountExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Mount");
                match self {
                    MountExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    MountExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    MountExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    MountExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for MountExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = MountExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = MountExn::Success(Deserialize::read(p)?);
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = MountExn::ex(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "MountExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum UnmountExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for UnmountExn {
            fn default() -> Self {
                UnmountExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for UnmountExn {
            fn from(exn: crate::types::EdenError) -> Self {
                UnmountExn::ex(exn)
            }
        }

        impl From<ApplicationException> for UnmountExn {
            fn from(exn: ApplicationException) -> Self {
                UnmountExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for UnmountExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for UnmountExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Unmount");
                match self {
                    UnmountExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnmountExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnmountExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    UnmountExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for UnmountExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = UnmountExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = UnmountExn::Success(Deserialize::read(p)?);
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = UnmountExn::ex(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UnmountExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum CheckOutRevisionExn {
            Success(Vec<crate::types::CheckoutConflict>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for CheckOutRevisionExn {
            fn default() -> Self {
                CheckOutRevisionExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for CheckOutRevisionExn {
            fn from(exn: crate::types::EdenError) -> Self {
                CheckOutRevisionExn::ex(exn)
            }
        }

        impl From<ApplicationException> for CheckOutRevisionExn {
            fn from(exn: ApplicationException) -> Self {
                CheckOutRevisionExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for CheckOutRevisionExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for CheckOutRevisionExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CheckOutRevision");
                match self {
                    CheckOutRevisionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CheckOutRevisionExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CheckOutRevisionExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    CheckOutRevisionExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for CheckOutRevisionExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::List, 0i32), false) => {
                            once = true;
                            alt = Some(CheckOutRevisionExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(CheckOutRevisionExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CheckOutRevisionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CheckOutRevisionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ResetParentCommitsExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for ResetParentCommitsExn {
            fn default() -> Self {
                ResetParentCommitsExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for ResetParentCommitsExn {
            fn from(exn: crate::types::EdenError) -> Self {
                ResetParentCommitsExn::ex(exn)
            }
        }

        impl From<ApplicationException> for ResetParentCommitsExn {
            fn from(exn: ApplicationException) -> Self {
                ResetParentCommitsExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for ResetParentCommitsExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for ResetParentCommitsExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ResetParentCommits");
                match self {
                    ResetParentCommitsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ResetParentCommitsExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ResetParentCommitsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    ResetParentCommitsExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for ResetParentCommitsExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ResetParentCommitsExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = ResetParentCommitsExn::Success(Deserialize::read(p)?);
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = ResetParentCommitsExn::ex(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ResetParentCommitsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSHA1Exn {
            Success(Vec<crate::types::SHA1Result>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetSHA1Exn {
            fn default() -> Self {
                GetSHA1Exn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GetSHA1Exn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetSHA1Exn::ex(exn)
            }
        }

        impl From<ApplicationException> for GetSHA1Exn {
            fn from(exn: ApplicationException) -> Self {
                GetSHA1Exn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetSHA1Exn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetSHA1Exn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetSHA1");
                match self {
                    GetSHA1Exn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSHA1Exn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSHA1Exn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetSHA1Exn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetSHA1Exn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::List, 0i32), false) => {
                            once = true;
                            alt = Some(GetSHA1Exn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GetSHA1Exn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSHA1Exn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSHA1Exn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetBindMountsExn {
            Success(Vec<crate::types::PathString>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetBindMountsExn {
            fn default() -> Self {
                GetBindMountsExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GetBindMountsExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetBindMountsExn::ex(exn)
            }
        }

        impl From<ApplicationException> for GetBindMountsExn {
            fn from(exn: ApplicationException) -> Self {
                GetBindMountsExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetBindMountsExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetBindMountsExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetBindMounts");
                match self {
                    GetBindMountsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetBindMountsExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetBindMountsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetBindMountsExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetBindMountsExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::List, 0i32), false) => {
                            once = true;
                            alt = Some(GetBindMountsExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GetBindMountsExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetBindMountsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetBindMountsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddBindMountExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for AddBindMountExn {
            fn default() -> Self {
                AddBindMountExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for AddBindMountExn {
            fn from(exn: crate::types::EdenError) -> Self {
                AddBindMountExn::ex(exn)
            }
        }

        impl From<ApplicationException> for AddBindMountExn {
            fn from(exn: ApplicationException) -> Self {
                AddBindMountExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for AddBindMountExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for AddBindMountExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AddBindMount");
                match self {
                    AddBindMountExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddBindMountExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddBindMountExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    AddBindMountExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for AddBindMountExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = AddBindMountExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = AddBindMountExn::Success(Deserialize::read(p)?);
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = AddBindMountExn::ex(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddBindMountExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveBindMountExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for RemoveBindMountExn {
            fn default() -> Self {
                RemoveBindMountExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for RemoveBindMountExn {
            fn from(exn: crate::types::EdenError) -> Self {
                RemoveBindMountExn::ex(exn)
            }
        }

        impl From<ApplicationException> for RemoveBindMountExn {
            fn from(exn: ApplicationException) -> Self {
                RemoveBindMountExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for RemoveBindMountExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for RemoveBindMountExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RemoveBindMount");
                match self {
                    RemoveBindMountExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveBindMountExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveBindMountExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    RemoveBindMountExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for RemoveBindMountExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = RemoveBindMountExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = RemoveBindMountExn::Success(Deserialize::read(p)?);
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = RemoveBindMountExn::ex(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveBindMountExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetCurrentJournalPositionExn {
            Success(crate::types::JournalPosition),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetCurrentJournalPositionExn {
            fn default() -> Self {
                GetCurrentJournalPositionExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GetCurrentJournalPositionExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetCurrentJournalPositionExn::ex(exn)
            }
        }

        impl From<ApplicationException> for GetCurrentJournalPositionExn {
            fn from(exn: ApplicationException) -> Self {
                GetCurrentJournalPositionExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetCurrentJournalPositionExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetCurrentJournalPositionExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetCurrentJournalPosition");
                match self {
                    GetCurrentJournalPositionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetCurrentJournalPositionExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetCurrentJournalPositionExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetCurrentJournalPositionExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetCurrentJournalPositionExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Struct, 0i32), false) => {
                            once = true;
                            alt = Some(GetCurrentJournalPositionExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GetCurrentJournalPositionExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetCurrentJournalPositionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetCurrentJournalPositionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetFilesChangedSinceExn {
            Success(crate::types::FileDelta),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetFilesChangedSinceExn {
            fn default() -> Self {
                GetFilesChangedSinceExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GetFilesChangedSinceExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetFilesChangedSinceExn::ex(exn)
            }
        }

        impl From<ApplicationException> for GetFilesChangedSinceExn {
            fn from(exn: ApplicationException) -> Self {
                GetFilesChangedSinceExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetFilesChangedSinceExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetFilesChangedSinceExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetFilesChangedSince");
                match self {
                    GetFilesChangedSinceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetFilesChangedSinceExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetFilesChangedSinceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetFilesChangedSinceExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetFilesChangedSinceExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Struct, 0i32), false) => {
                            once = true;
                            alt = Some(GetFilesChangedSinceExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GetFilesChangedSinceExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetFilesChangedSinceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetFilesChangedSinceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SetJournalMemoryLimitExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for SetJournalMemoryLimitExn {
            fn default() -> Self {
                SetJournalMemoryLimitExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for SetJournalMemoryLimitExn {
            fn from(exn: crate::types::EdenError) -> Self {
                SetJournalMemoryLimitExn::ex(exn)
            }
        }

        impl From<ApplicationException> for SetJournalMemoryLimitExn {
            fn from(exn: ApplicationException) -> Self {
                SetJournalMemoryLimitExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for SetJournalMemoryLimitExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for SetJournalMemoryLimitExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("SetJournalMemoryLimit");
                match self {
                    SetJournalMemoryLimitExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SetJournalMemoryLimitExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SetJournalMemoryLimitExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    SetJournalMemoryLimitExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for SetJournalMemoryLimitExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = SetJournalMemoryLimitExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = SetJournalMemoryLimitExn::Success(Deserialize::read(p)?);
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = SetJournalMemoryLimitExn::ex(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SetJournalMemoryLimitExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetJournalMemoryLimitExn {
            Success(i64),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetJournalMemoryLimitExn {
            fn default() -> Self {
                GetJournalMemoryLimitExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GetJournalMemoryLimitExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetJournalMemoryLimitExn::ex(exn)
            }
        }

        impl From<ApplicationException> for GetJournalMemoryLimitExn {
            fn from(exn: ApplicationException) -> Self {
                GetJournalMemoryLimitExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetJournalMemoryLimitExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetJournalMemoryLimitExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetJournalMemoryLimit");
                match self {
                    GetJournalMemoryLimitExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetJournalMemoryLimitExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetJournalMemoryLimitExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetJournalMemoryLimitExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetJournalMemoryLimitExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::I64, 0i32), false) => {
                            once = true;
                            alt = Some(GetJournalMemoryLimitExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GetJournalMemoryLimitExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetJournalMemoryLimitExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetJournalMemoryLimitExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum FlushJournalExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for FlushJournalExn {
            fn default() -> Self {
                FlushJournalExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for FlushJournalExn {
            fn from(exn: crate::types::EdenError) -> Self {
                FlushJournalExn::ex(exn)
            }
        }

        impl From<ApplicationException> for FlushJournalExn {
            fn from(exn: ApplicationException) -> Self {
                FlushJournalExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for FlushJournalExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for FlushJournalExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("FlushJournal");
                match self {
                    FlushJournalExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    FlushJournalExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    FlushJournalExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    FlushJournalExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for FlushJournalExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = FlushJournalExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = FlushJournalExn::Success(Deserialize::read(p)?);
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = FlushJournalExn::ex(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "FlushJournalExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugGetRawJournalExn {
            Success(crate::types::DebugGetRawJournalResponse),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for DebugGetRawJournalExn {
            fn default() -> Self {
                DebugGetRawJournalExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for DebugGetRawJournalExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugGetRawJournalExn::ex(exn)
            }
        }

        impl From<ApplicationException> for DebugGetRawJournalExn {
            fn from(exn: ApplicationException) -> Self {
                DebugGetRawJournalExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for DebugGetRawJournalExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for DebugGetRawJournalExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugGetRawJournal");
                match self {
                    DebugGetRawJournalExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetRawJournalExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetRawJournalExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    DebugGetRawJournalExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for DebugGetRawJournalExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Struct, 0i32), false) => {
                            once = true;
                            alt = Some(DebugGetRawJournalExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(DebugGetRawJournalExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugGetRawJournalExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugGetRawJournalExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetFileInformationExn {
            Success(Vec<crate::types::FileInformationOrError>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetFileInformationExn {
            fn default() -> Self {
                GetFileInformationExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GetFileInformationExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetFileInformationExn::ex(exn)
            }
        }

        impl From<ApplicationException> for GetFileInformationExn {
            fn from(exn: ApplicationException) -> Self {
                GetFileInformationExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetFileInformationExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetFileInformationExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetFileInformation");
                match self {
                    GetFileInformationExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetFileInformationExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetFileInformationExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetFileInformationExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetFileInformationExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::List, 0i32), false) => {
                            once = true;
                            alt = Some(GetFileInformationExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GetFileInformationExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetFileInformationExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetFileInformationExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GlobExn {
            Success(Vec<crate::types::PathString>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GlobExn {
            fn default() -> Self {
                GlobExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GlobExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GlobExn::ex(exn)
            }
        }

        impl From<ApplicationException> for GlobExn {
            fn from(exn: ApplicationException) -> Self {
                GlobExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GlobExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GlobExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Glob");
                match self {
                    GlobExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GlobExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GlobExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GlobExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GlobExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::List, 0i32), false) => {
                            once = true;
                            alt = Some(GlobExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GlobExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GlobExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GlobExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GlobFilesExn {
            Success(crate::types::Glob),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GlobFilesExn {
            fn default() -> Self {
                GlobFilesExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GlobFilesExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GlobFilesExn::ex(exn)
            }
        }

        impl From<ApplicationException> for GlobFilesExn {
            fn from(exn: ApplicationException) -> Self {
                GlobFilesExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GlobFilesExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GlobFilesExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GlobFiles");
                match self {
                    GlobFilesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GlobFilesExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GlobFilesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GlobFilesExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GlobFilesExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Struct, 0i32), false) => {
                            once = true;
                            alt = Some(GlobFilesExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GlobFilesExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GlobFilesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GlobFilesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ChownExn {
            Success(()),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for ChownExn {
            fn default() -> Self {
                ChownExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for ChownExn {
            fn from(exn: ApplicationException) -> Self {
                ChownExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for ChownExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for ChownExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Chown");
                match self {
                    ChownExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ChownExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    ChownExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for ChownExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ChownExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = ChownExn::Success(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ChownExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetScmStatusV2Exn {
            Success(crate::types::GetScmStatusResult),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetScmStatusV2Exn {
            fn default() -> Self {
                GetScmStatusV2Exn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GetScmStatusV2Exn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetScmStatusV2Exn::ex(exn)
            }
        }

        impl From<ApplicationException> for GetScmStatusV2Exn {
            fn from(exn: ApplicationException) -> Self {
                GetScmStatusV2Exn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetScmStatusV2Exn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetScmStatusV2Exn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetScmStatusV2");
                match self {
                    GetScmStatusV2Exn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusV2Exn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusV2Exn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetScmStatusV2Exn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetScmStatusV2Exn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Struct, 0i32), false) => {
                            once = true;
                            alt = Some(GetScmStatusV2Exn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GetScmStatusV2Exn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetScmStatusV2Exn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetScmStatusV2Exn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetScmStatusExn {
            Success(crate::types::ScmStatus),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetScmStatusExn {
            fn default() -> Self {
                GetScmStatusExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GetScmStatusExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetScmStatusExn::ex(exn)
            }
        }

        impl From<ApplicationException> for GetScmStatusExn {
            fn from(exn: ApplicationException) -> Self {
                GetScmStatusExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetScmStatusExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetScmStatusExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetScmStatus");
                match self {
                    GetScmStatusExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetScmStatusExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetScmStatusExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Struct, 0i32), false) => {
                            once = true;
                            alt = Some(GetScmStatusExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GetScmStatusExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetScmStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetScmStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetScmStatusBetweenRevisionsExn {
            Success(crate::types::ScmStatus),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetScmStatusBetweenRevisionsExn {
            fn default() -> Self {
                GetScmStatusBetweenRevisionsExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GetScmStatusBetweenRevisionsExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetScmStatusBetweenRevisionsExn::ex(exn)
            }
        }

        impl From<ApplicationException> for GetScmStatusBetweenRevisionsExn {
            fn from(exn: ApplicationException) -> Self {
                GetScmStatusBetweenRevisionsExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetScmStatusBetweenRevisionsExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetScmStatusBetweenRevisionsExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetScmStatusBetweenRevisions");
                match self {
                    GetScmStatusBetweenRevisionsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusBetweenRevisionsExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusBetweenRevisionsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetScmStatusBetweenRevisionsExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetScmStatusBetweenRevisionsExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Struct, 0i32), false) => {
                            once = true;
                            alt = Some(GetScmStatusBetweenRevisionsExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GetScmStatusBetweenRevisionsExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetScmStatusBetweenRevisionsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetScmStatusBetweenRevisionsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetManifestEntryExn {
            Success(crate::types::ManifestEntry),
            ex(crate::types::EdenError),
            noValueForKeyError(crate::types::NoValueForKeyError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetManifestEntryExn {
            fn default() -> Self {
                GetManifestEntryExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GetManifestEntryExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetManifestEntryExn::ex(exn)
            }
        }

        impl From<crate::types::NoValueForKeyError> for GetManifestEntryExn {
            fn from(exn: crate::types::NoValueForKeyError) -> Self {
                GetManifestEntryExn::noValueForKeyError(exn)
            }
        }

        impl From<ApplicationException> for GetManifestEntryExn {
            fn from(exn: ApplicationException) -> Self {
                GetManifestEntryExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetManifestEntryExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetManifestEntryExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetManifestEntry");
                match self {
                    GetManifestEntryExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetManifestEntryExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetManifestEntryExn::noValueForKeyError(inner) => {
                        p.write_field_begin(
                            "noValueForKeyError",
                            TType::Struct,
                            2,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetManifestEntryExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetManifestEntryExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetManifestEntryExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Struct, 0i32), false) => {
                            once = true;
                            alt = Some(GetManifestEntryExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GetManifestEntryExn::ex(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 2), false) => {
                            once = true;
                            alt = Some(GetManifestEntryExn::noValueForKeyError(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetManifestEntryExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetManifestEntryExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetDaemonInfoExn {
            Success(crate::types::DaemonInfo),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetDaemonInfoExn {
            fn default() -> Self {
                GetDaemonInfoExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GetDaemonInfoExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetDaemonInfoExn::ex(exn)
            }
        }

        impl From<ApplicationException> for GetDaemonInfoExn {
            fn from(exn: ApplicationException) -> Self {
                GetDaemonInfoExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetDaemonInfoExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetDaemonInfoExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetDaemonInfo");
                match self {
                    GetDaemonInfoExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetDaemonInfoExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetDaemonInfoExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetDaemonInfoExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetDaemonInfoExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Struct, 0i32), false) => {
                            once = true;
                            alt = Some(GetDaemonInfoExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GetDaemonInfoExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetDaemonInfoExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetDaemonInfoExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetPidExn {
            Success(i64),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetPidExn {
            fn default() -> Self {
                GetPidExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GetPidExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetPidExn::ex(exn)
            }
        }

        impl From<ApplicationException> for GetPidExn {
            fn from(exn: ApplicationException) -> Self {
                GetPidExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetPidExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetPidExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetPid");
                match self {
                    GetPidExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetPidExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetPidExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetPidExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetPidExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::I64, 0i32), false) => {
                            once = true;
                            alt = Some(GetPidExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GetPidExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetPidExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetPidExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum InitiateShutdownExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for InitiateShutdownExn {
            fn default() -> Self {
                InitiateShutdownExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for InitiateShutdownExn {
            fn from(exn: crate::types::EdenError) -> Self {
                InitiateShutdownExn::ex(exn)
            }
        }

        impl From<ApplicationException> for InitiateShutdownExn {
            fn from(exn: ApplicationException) -> Self {
                InitiateShutdownExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for InitiateShutdownExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for InitiateShutdownExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("InitiateShutdown");
                match self {
                    InitiateShutdownExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InitiateShutdownExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InitiateShutdownExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    InitiateShutdownExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for InitiateShutdownExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = InitiateShutdownExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = InitiateShutdownExn::Success(Deserialize::read(p)?);
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = InitiateShutdownExn::ex(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "InitiateShutdownExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetConfigExn {
            Success(eden_config::types::EdenConfigData),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetConfigExn {
            fn default() -> Self {
                GetConfigExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GetConfigExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetConfigExn::ex(exn)
            }
        }

        impl From<ApplicationException> for GetConfigExn {
            fn from(exn: ApplicationException) -> Self {
                GetConfigExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetConfigExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetConfigExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetConfig");
                match self {
                    GetConfigExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetConfigExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetConfigExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetConfigExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetConfigExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Struct, 0i32), false) => {
                            once = true;
                            alt = Some(GetConfigExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GetConfigExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ReloadConfigExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for ReloadConfigExn {
            fn default() -> Self {
                ReloadConfigExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for ReloadConfigExn {
            fn from(exn: crate::types::EdenError) -> Self {
                ReloadConfigExn::ex(exn)
            }
        }

        impl From<ApplicationException> for ReloadConfigExn {
            fn from(exn: ApplicationException) -> Self {
                ReloadConfigExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for ReloadConfigExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for ReloadConfigExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ReloadConfig");
                match self {
                    ReloadConfigExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ReloadConfigExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ReloadConfigExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    ReloadConfigExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for ReloadConfigExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ReloadConfigExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = ReloadConfigExn::Success(Deserialize::read(p)?);
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = ReloadConfigExn::ex(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ReloadConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugGetScmTreeExn {
            Success(Vec<crate::types::ScmTreeEntry>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for DebugGetScmTreeExn {
            fn default() -> Self {
                DebugGetScmTreeExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for DebugGetScmTreeExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugGetScmTreeExn::ex(exn)
            }
        }

        impl From<ApplicationException> for DebugGetScmTreeExn {
            fn from(exn: ApplicationException) -> Self {
                DebugGetScmTreeExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for DebugGetScmTreeExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for DebugGetScmTreeExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugGetScmTree");
                match self {
                    DebugGetScmTreeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmTreeExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmTreeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    DebugGetScmTreeExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for DebugGetScmTreeExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::List, 0i32), false) => {
                            once = true;
                            alt = Some(DebugGetScmTreeExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(DebugGetScmTreeExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugGetScmTreeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugGetScmTreeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugGetScmBlobExn {
            Success(Vec<u8>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for DebugGetScmBlobExn {
            fn default() -> Self {
                DebugGetScmBlobExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for DebugGetScmBlobExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugGetScmBlobExn::ex(exn)
            }
        }

        impl From<ApplicationException> for DebugGetScmBlobExn {
            fn from(exn: ApplicationException) -> Self {
                DebugGetScmBlobExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for DebugGetScmBlobExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for DebugGetScmBlobExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugGetScmBlob");
                match self {
                    DebugGetScmBlobExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmBlobExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmBlobExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    DebugGetScmBlobExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for DebugGetScmBlobExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::String, 0i32), false) => {
                            once = true;
                            alt = Some(DebugGetScmBlobExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(DebugGetScmBlobExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugGetScmBlobExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugGetScmBlobExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugGetScmBlobMetadataExn {
            Success(crate::types::ScmBlobMetadata),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for DebugGetScmBlobMetadataExn {
            fn default() -> Self {
                DebugGetScmBlobMetadataExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for DebugGetScmBlobMetadataExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugGetScmBlobMetadataExn::ex(exn)
            }
        }

        impl From<ApplicationException> for DebugGetScmBlobMetadataExn {
            fn from(exn: ApplicationException) -> Self {
                DebugGetScmBlobMetadataExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for DebugGetScmBlobMetadataExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for DebugGetScmBlobMetadataExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugGetScmBlobMetadata");
                match self {
                    DebugGetScmBlobMetadataExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmBlobMetadataExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmBlobMetadataExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    DebugGetScmBlobMetadataExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for DebugGetScmBlobMetadataExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Struct, 0i32), false) => {
                            once = true;
                            alt = Some(DebugGetScmBlobMetadataExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(DebugGetScmBlobMetadataExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugGetScmBlobMetadataExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugGetScmBlobMetadataExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugInodeStatusExn {
            Success(Vec<crate::types::TreeInodeDebugInfo>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for DebugInodeStatusExn {
            fn default() -> Self {
                DebugInodeStatusExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for DebugInodeStatusExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugInodeStatusExn::ex(exn)
            }
        }

        impl From<ApplicationException> for DebugInodeStatusExn {
            fn from(exn: ApplicationException) -> Self {
                DebugInodeStatusExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for DebugInodeStatusExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for DebugInodeStatusExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugInodeStatus");
                match self {
                    DebugInodeStatusExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugInodeStatusExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugInodeStatusExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    DebugInodeStatusExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for DebugInodeStatusExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::List, 0i32), false) => {
                            once = true;
                            alt = Some(DebugInodeStatusExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(DebugInodeStatusExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugInodeStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugInodeStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugOutstandingFuseCallsExn {
            Success(Vec<crate::types::FuseCall>),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for DebugOutstandingFuseCallsExn {
            fn default() -> Self {
                DebugOutstandingFuseCallsExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for DebugOutstandingFuseCallsExn {
            fn from(exn: ApplicationException) -> Self {
                DebugOutstandingFuseCallsExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for DebugOutstandingFuseCallsExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for DebugOutstandingFuseCallsExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugOutstandingFuseCalls");
                match self {
                    DebugOutstandingFuseCallsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugOutstandingFuseCallsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    DebugOutstandingFuseCallsExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for DebugOutstandingFuseCallsExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::List, 0i32), false) => {
                            once = true;
                            alt = Some(DebugOutstandingFuseCallsExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugOutstandingFuseCallsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugOutstandingFuseCallsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugGetInodePathExn {
            Success(crate::types::InodePathDebugInfo),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for DebugGetInodePathExn {
            fn default() -> Self {
                DebugGetInodePathExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for DebugGetInodePathExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugGetInodePathExn::ex(exn)
            }
        }

        impl From<ApplicationException> for DebugGetInodePathExn {
            fn from(exn: ApplicationException) -> Self {
                DebugGetInodePathExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for DebugGetInodePathExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for DebugGetInodePathExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugGetInodePath");
                match self {
                    DebugGetInodePathExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetInodePathExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetInodePathExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    DebugGetInodePathExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for DebugGetInodePathExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Struct, 0i32), false) => {
                            once = true;
                            alt = Some(DebugGetInodePathExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(DebugGetInodePathExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugGetInodePathExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugGetInodePathExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugSetLogLevelExn {
            Success(crate::types::SetLogLevelResult),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for DebugSetLogLevelExn {
            fn default() -> Self {
                DebugSetLogLevelExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for DebugSetLogLevelExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugSetLogLevelExn::ex(exn)
            }
        }

        impl From<ApplicationException> for DebugSetLogLevelExn {
            fn from(exn: ApplicationException) -> Self {
                DebugSetLogLevelExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for DebugSetLogLevelExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for DebugSetLogLevelExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugSetLogLevel");
                match self {
                    DebugSetLogLevelExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugSetLogLevelExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugSetLogLevelExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    DebugSetLogLevelExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for DebugSetLogLevelExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Struct, 0i32), false) => {
                            once = true;
                            alt = Some(DebugSetLogLevelExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(DebugSetLogLevelExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugSetLogLevelExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugSetLogLevelExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetAccessCountsExn {
            Success(crate::types::GetAccessCountsResult),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetAccessCountsExn {
            fn default() -> Self {
                GetAccessCountsExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GetAccessCountsExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetAccessCountsExn::ex(exn)
            }
        }

        impl From<ApplicationException> for GetAccessCountsExn {
            fn from(exn: ApplicationException) -> Self {
                GetAccessCountsExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetAccessCountsExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetAccessCountsExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetAccessCounts");
                match self {
                    GetAccessCountsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetAccessCountsExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetAccessCountsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetAccessCountsExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetAccessCountsExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Struct, 0i32), false) => {
                            once = true;
                            alt = Some(GetAccessCountsExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GetAccessCountsExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetAccessCountsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetAccessCountsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ClearAndCompactLocalStoreExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for ClearAndCompactLocalStoreExn {
            fn default() -> Self {
                ClearAndCompactLocalStoreExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for ClearAndCompactLocalStoreExn {
            fn from(exn: crate::types::EdenError) -> Self {
                ClearAndCompactLocalStoreExn::ex(exn)
            }
        }

        impl From<ApplicationException> for ClearAndCompactLocalStoreExn {
            fn from(exn: ApplicationException) -> Self {
                ClearAndCompactLocalStoreExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for ClearAndCompactLocalStoreExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for ClearAndCompactLocalStoreExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ClearAndCompactLocalStore");
                match self {
                    ClearAndCompactLocalStoreExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ClearAndCompactLocalStoreExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ClearAndCompactLocalStoreExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    ClearAndCompactLocalStoreExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for ClearAndCompactLocalStoreExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ClearAndCompactLocalStoreExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = ClearAndCompactLocalStoreExn::Success(Deserialize::read(p)?);
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = ClearAndCompactLocalStoreExn::ex(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ClearAndCompactLocalStoreExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugClearLocalStoreCachesExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for DebugClearLocalStoreCachesExn {
            fn default() -> Self {
                DebugClearLocalStoreCachesExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for DebugClearLocalStoreCachesExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugClearLocalStoreCachesExn::ex(exn)
            }
        }

        impl From<ApplicationException> for DebugClearLocalStoreCachesExn {
            fn from(exn: ApplicationException) -> Self {
                DebugClearLocalStoreCachesExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for DebugClearLocalStoreCachesExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for DebugClearLocalStoreCachesExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugClearLocalStoreCaches");
                match self {
                    DebugClearLocalStoreCachesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugClearLocalStoreCachesExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugClearLocalStoreCachesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    DebugClearLocalStoreCachesExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for DebugClearLocalStoreCachesExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = DebugClearLocalStoreCachesExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = DebugClearLocalStoreCachesExn::Success(Deserialize::read(p)?);
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = DebugClearLocalStoreCachesExn::ex(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugClearLocalStoreCachesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugCompactLocalStorageExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for DebugCompactLocalStorageExn {
            fn default() -> Self {
                DebugCompactLocalStorageExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for DebugCompactLocalStorageExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugCompactLocalStorageExn::ex(exn)
            }
        }

        impl From<ApplicationException> for DebugCompactLocalStorageExn {
            fn from(exn: ApplicationException) -> Self {
                DebugCompactLocalStorageExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for DebugCompactLocalStorageExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for DebugCompactLocalStorageExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugCompactLocalStorage");
                match self {
                    DebugCompactLocalStorageExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugCompactLocalStorageExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugCompactLocalStorageExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    DebugCompactLocalStorageExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for DebugCompactLocalStorageExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = DebugCompactLocalStorageExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = DebugCompactLocalStorageExn::Success(Deserialize::read(p)?);
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = DebugCompactLocalStorageExn::ex(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugCompactLocalStorageExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum UnloadInodeForPathExn {
            Success(i64),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for UnloadInodeForPathExn {
            fn default() -> Self {
                UnloadInodeForPathExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for UnloadInodeForPathExn {
            fn from(exn: crate::types::EdenError) -> Self {
                UnloadInodeForPathExn::ex(exn)
            }
        }

        impl From<ApplicationException> for UnloadInodeForPathExn {
            fn from(exn: ApplicationException) -> Self {
                UnloadInodeForPathExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for UnloadInodeForPathExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for UnloadInodeForPathExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("UnloadInodeForPath");
                match self {
                    UnloadInodeForPathExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnloadInodeForPathExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnloadInodeForPathExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    UnloadInodeForPathExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for UnloadInodeForPathExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::I64, 0i32), false) => {
                            once = true;
                            alt = Some(UnloadInodeForPathExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(UnloadInodeForPathExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UnloadInodeForPathExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UnloadInodeForPathExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum FlushStatsNowExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for FlushStatsNowExn {
            fn default() -> Self {
                FlushStatsNowExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for FlushStatsNowExn {
            fn from(exn: crate::types::EdenError) -> Self {
                FlushStatsNowExn::ex(exn)
            }
        }

        impl From<ApplicationException> for FlushStatsNowExn {
            fn from(exn: ApplicationException) -> Self {
                FlushStatsNowExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for FlushStatsNowExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for FlushStatsNowExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("FlushStatsNow");
                match self {
                    FlushStatsNowExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    FlushStatsNowExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    FlushStatsNowExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    FlushStatsNowExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for FlushStatsNowExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = FlushStatsNowExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = FlushStatsNowExn::Success(Deserialize::read(p)?);
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = FlushStatsNowExn::ex(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "FlushStatsNowExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum InvalidateKernelInodeCacheExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for InvalidateKernelInodeCacheExn {
            fn default() -> Self {
                InvalidateKernelInodeCacheExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for InvalidateKernelInodeCacheExn {
            fn from(exn: crate::types::EdenError) -> Self {
                InvalidateKernelInodeCacheExn::ex(exn)
            }
        }

        impl From<ApplicationException> for InvalidateKernelInodeCacheExn {
            fn from(exn: ApplicationException) -> Self {
                InvalidateKernelInodeCacheExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for InvalidateKernelInodeCacheExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for InvalidateKernelInodeCacheExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("InvalidateKernelInodeCache");
                match self {
                    InvalidateKernelInodeCacheExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InvalidateKernelInodeCacheExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InvalidateKernelInodeCacheExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    InvalidateKernelInodeCacheExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for InvalidateKernelInodeCacheExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = InvalidateKernelInodeCacheExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = InvalidateKernelInodeCacheExn::Success(Deserialize::read(p)?);
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = InvalidateKernelInodeCacheExn::ex(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "InvalidateKernelInodeCacheExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetStatInfoExn {
            Success(crate::types::InternalStats),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetStatInfoExn {
            fn default() -> Self {
                GetStatInfoExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for GetStatInfoExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetStatInfoExn::ex(exn)
            }
        }

        impl From<ApplicationException> for GetStatInfoExn {
            fn from(exn: ApplicationException) -> Self {
                GetStatInfoExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetStatInfoExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetStatInfoExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetStatInfo");
                match self {
                    GetStatInfoExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetStatInfoExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetStatInfoExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetStatInfoExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetStatInfoExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Struct, 0i32), false) => {
                            once = true;
                            alt = Some(GetStatInfoExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(GetStatInfoExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetStatInfoExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetStatInfoExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum EnableTracingExn {
            Success(()),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for EnableTracingExn {
            fn default() -> Self {
                EnableTracingExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for EnableTracingExn {
            fn from(exn: ApplicationException) -> Self {
                EnableTracingExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for EnableTracingExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for EnableTracingExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("EnableTracing");
                match self {
                    EnableTracingExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    EnableTracingExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    EnableTracingExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for EnableTracingExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = EnableTracingExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = EnableTracingExn::Success(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "EnableTracingExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum DisableTracingExn {
            Success(()),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for DisableTracingExn {
            fn default() -> Self {
                DisableTracingExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for DisableTracingExn {
            fn from(exn: ApplicationException) -> Self {
                DisableTracingExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for DisableTracingExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for DisableTracingExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DisableTracing");
                match self {
                    DisableTracingExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DisableTracingExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    DisableTracingExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for DisableTracingExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = DisableTracingExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = DisableTracingExn::Success(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DisableTracingExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetTracePointsExn {
            Success(Vec<crate::types::TracePoint>),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetTracePointsExn {
            fn default() -> Self {
                GetTracePointsExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for GetTracePointsExn {
            fn from(exn: ApplicationException) -> Self {
                GetTracePointsExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetTracePointsExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetTracePointsExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetTracePoints");
                match self {
                    GetTracePointsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetTracePointsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetTracePointsExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetTracePointsExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::List, 0i32), false) => {
                            once = true;
                            alt = Some(GetTracePointsExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetTracePointsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetTracePointsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum InjectFaultExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for InjectFaultExn {
            fn default() -> Self {
                InjectFaultExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for InjectFaultExn {
            fn from(exn: crate::types::EdenError) -> Self {
                InjectFaultExn::ex(exn)
            }
        }

        impl From<ApplicationException> for InjectFaultExn {
            fn from(exn: ApplicationException) -> Self {
                InjectFaultExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for InjectFaultExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for InjectFaultExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("InjectFault");
                match self {
                    InjectFaultExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InjectFaultExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InjectFaultExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    InjectFaultExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for InjectFaultExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = InjectFaultExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = InjectFaultExn::Success(Deserialize::read(p)?);
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = InjectFaultExn::ex(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "InjectFaultExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveFaultExn {
            Success(bool),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for RemoveFaultExn {
            fn default() -> Self {
                RemoveFaultExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for RemoveFaultExn {
            fn from(exn: crate::types::EdenError) -> Self {
                RemoveFaultExn::ex(exn)
            }
        }

        impl From<ApplicationException> for RemoveFaultExn {
            fn from(exn: ApplicationException) -> Self {
                RemoveFaultExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for RemoveFaultExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for RemoveFaultExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RemoveFault");
                match self {
                    RemoveFaultExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Bool,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveFaultExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveFaultExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    RemoveFaultExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for RemoveFaultExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Bool, 0i32), false) => {
                            once = true;
                            alt = Some(RemoveFaultExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(RemoveFaultExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveFaultExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveFaultExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum UnblockFaultExn {
            Success(i64),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for UnblockFaultExn {
            fn default() -> Self {
                UnblockFaultExn::UnknownField(-1)
            }
        }

        impl From<crate::types::EdenError> for UnblockFaultExn {
            fn from(exn: crate::types::EdenError) -> Self {
                UnblockFaultExn::ex(exn)
            }
        }

        impl From<ApplicationException> for UnblockFaultExn {
            fn from(exn: ApplicationException) -> Self {
                UnblockFaultExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for UnblockFaultExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for UnblockFaultExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("UnblockFault");
                match self {
                    UnblockFaultExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnblockFaultExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnblockFaultExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    UnblockFaultExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for UnblockFaultExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::I64, 0i32), false) => {
                            once = true;
                            alt = Some(UnblockFaultExn::Success(Deserialize::read(p)?));
                        }
                        ((TType::Struct, 1), false) => {
                            once = true;
                            alt = Some(UnblockFaultExn::ex(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UnblockFaultExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UnblockFaultExn"),
                    )
                    .into(),
                )
            }
        }
    }
}

pub mod client {
    use fbthrift::*;
    use std::marker::PhantomData;
    use std::sync::Arc;

    pub struct EdenServiceImpl<P, T> {
        transport: T,
        _phantom: PhantomData<fn() -> P>,
    }

    impl<P, T> EdenServiceImpl<P, T> {
        pub fn new(transport: T) -> Self {
            Self {
                transport,
                _phantom: PhantomData,
            }
        }
    }

    pub trait EdenService: Send {
        fn listMounts(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::MountInfo>>> + Send + 'static>>;
        fn mount(
            &self,
            arg_info: &crate::types::MountArgument,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn unmount(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn checkOutRevision(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_snapshotHash: &crate::types::BinaryHash,
            arg_checkoutMode: &crate::types::CheckoutMode,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::CheckoutConflict>>> + Send + 'static>>;
        fn resetParentCommits(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_parents: &crate::types::WorkingDirectoryParents,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn getSHA1(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &Vec<crate::types::PathString>,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::SHA1Result>>> + Send + 'static>>;
        fn getBindMounts(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::PathString>>> + Send + 'static>>;
        fn addBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
            arg_targetPath: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn removeBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn getCurrentJournalPosition(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::JournalPosition>> + Send + 'static>>;
        fn getFilesChangedSince(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_fromPosition: &crate::types::JournalPosition,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::FileDelta>> + Send + 'static>>;
        fn setJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_limit: i64,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn getJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>>;
        fn flushJournal(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn debugGetRawJournal(
            &self,
            arg_params: &crate::types::DebugGetRawJournalParams,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::DebugGetRawJournalResponse>> + Send + 'static>>;
        fn getFileInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &Vec<crate::types::PathString>,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::FileInformationOrError>>> + Send + 'static>>;
        fn glob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_globs: &Vec<String>,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::PathString>>> + Send + 'static>>;
        fn globFiles(
            &self,
            arg_params: &crate::types::GlobParams,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::Glob>> + Send + 'static>>;
        fn chown(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_uid: i32,
            arg_gid: i32,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn getScmStatusV2(
            &self,
            arg_params: &crate::types::GetScmStatusParams,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::GetScmStatusResult>> + Send + 'static>>;
        fn getScmStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_listIgnored: bool,
            arg_commit: &crate::types::BinaryHash,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::ScmStatus>> + Send + 'static>>;
        fn getScmStatusBetweenRevisions(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_oldHash: &crate::types::BinaryHash,
            arg_newHash: &crate::types::BinaryHash,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::ScmStatus>> + Send + 'static>>;
        fn getManifestEntry(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_relativePath: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::ManifestEntry>> + Send + 'static>>;
        fn getDaemonInfo(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::DaemonInfo>> + Send + 'static>>;
        fn getPid(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>>;
        fn initiateShutdown(
            &self,
            arg_reason: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn getConfig(
            &self,
            arg_params: &crate::types::GetConfigParams,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<eden_config::types::EdenConfigData>> + Send + 'static>>;
        fn reloadConfig(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn debugGetScmTree(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: bool,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::ScmTreeEntry>>> + Send + 'static>>;
        fn debugGetScmBlob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: bool,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<u8>>> + Send + 'static>>;
        fn debugGetScmBlobMetadata(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: bool,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::ScmBlobMetadata>> + Send + 'static>>;
        fn debugInodeStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::TreeInodeDebugInfo>>> + Send + 'static>>;
        fn debugOutstandingFuseCalls(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::FuseCall>>> + Send + 'static>>;
        fn debugGetInodePath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_inodeNumber: i64,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::InodePathDebugInfo>> + Send + 'static>>;
        fn debugSetLogLevel(
            &self,
            arg_category: &str,
            arg_level: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::SetLogLevelResult>> + Send + 'static>>;
        fn getAccessCounts(
            &self,
            arg_duration: i64,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::GetAccessCountsResult>> + Send + 'static>>;
        fn clearAndCompactLocalStore(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn debugClearLocalStoreCaches(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn debugCompactLocalStorage(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn unloadInodeForPath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
            arg_age: &crate::types::TimeSpec,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>>;
        fn flushStatsNow(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn invalidateKernelInodeCache(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn getStatInfo(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::InternalStats>> + Send + 'static>>;
        fn enableTracing(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn disableTracing(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn getTracePoints(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::TracePoint>>> + Send + 'static>>;
        fn injectFault(
            &self,
            arg_fault: &crate::types::FaultDefinition,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn removeFault(
            &self,
            arg_fault: &crate::types::RemoveFaultArg,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<bool>> + Send + 'static>>;
        fn unblockFault(
            &self,
            arg_info: &crate::types::UnblockFaultArg,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>>;
    }

    impl<P, T> EdenService for EdenServiceImpl<P, T>
    where
        P: Protocol,
        T: Transport,
        P::Frame: Framing<DecBuf = FramingDecoded<T>>,
        ProtocolEncoded<P>: BufMutExt<Final = FramingEncodedFinal<T>>,
    {        fn listMounts(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::MountInfo>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "listMounts",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<Vec<crate::types::MountInfo>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::ListMountsExn::read(p)? {
                                    crate::services::eden_service::ListMountsExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceListMountsError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceListMountsError(
                                    crate::services::eden_service::ListMountsExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn mount(
            &self,
            arg_info: &crate::types::MountArgument,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "mount",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_info", TType::Struct, 1i16);
                    arg_info.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::MountExn::read(p)? {
                                    crate::services::eden_service::MountExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceMountError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceMountError(
                                    crate::services::eden_service::MountExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn unmount(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "unmount",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::UnmountExn::read(p)? {
                                    crate::services::eden_service::UnmountExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceUnmountError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceUnmountError(
                                    crate::services::eden_service::UnmountExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn checkOutRevision(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_snapshotHash: &crate::types::BinaryHash,
            arg_checkoutMode: &crate::types::CheckoutMode,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::CheckoutConflict>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "checkOutRevision",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_snapshotHash", TType::String, 2i16);
                    arg_snapshotHash.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_checkoutMode", TType::I32, 3i16);
                    arg_checkoutMode.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<Vec<crate::types::CheckoutConflict>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::CheckOutRevisionExn::read(p)? {
                                    crate::services::eden_service::CheckOutRevisionExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceCheckOutRevisionError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceCheckOutRevisionError(
                                    crate::services::eden_service::CheckOutRevisionExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn resetParentCommits(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_parents: &crate::types::WorkingDirectoryParents,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "resetParentCommits",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_parents", TType::Struct, 2i16);
                    arg_parents.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::ResetParentCommitsExn::read(p)? {
                                    crate::services::eden_service::ResetParentCommitsExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceResetParentCommitsError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceResetParentCommitsError(
                                    crate::services::eden_service::ResetParentCommitsExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getSHA1(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &Vec<crate::types::PathString>,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::SHA1Result>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getSHA1",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_paths", TType::List, 2i16);
                    arg_paths.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<Vec<crate::types::SHA1Result>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GetSHA1Exn::read(p)? {
                                    crate::services::eden_service::GetSHA1Exn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGetSHA1Error(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGetSHA1Error(
                                    crate::services::eden_service::GetSHA1Exn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getBindMounts(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::PathString>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getBindMounts",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<Vec<crate::types::PathString>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GetBindMountsExn::read(p)? {
                                    crate::services::eden_service::GetBindMountsExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGetBindMountsError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGetBindMountsError(
                                    crate::services::eden_service::GetBindMountsExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn addBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
            arg_targetPath: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "addBindMount",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_repoPath", TType::String, 2i16);
                    arg_repoPath.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_targetPath", TType::String, 3i16);
                    arg_targetPath.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::AddBindMountExn::read(p)? {
                                    crate::services::eden_service::AddBindMountExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceAddBindMountError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceAddBindMountError(
                                    crate::services::eden_service::AddBindMountExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn removeBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "removeBindMount",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_repoPath", TType::String, 2i16);
                    arg_repoPath.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::RemoveBindMountExn::read(p)? {
                                    crate::services::eden_service::RemoveBindMountExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceRemoveBindMountError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceRemoveBindMountError(
                                    crate::services::eden_service::RemoveBindMountExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getCurrentJournalPosition(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::JournalPosition>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getCurrentJournalPosition",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<crate::types::JournalPosition> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GetCurrentJournalPositionExn::read(p)? {
                                    crate::services::eden_service::GetCurrentJournalPositionExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGetCurrentJournalPositionError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGetCurrentJournalPositionError(
                                    crate::services::eden_service::GetCurrentJournalPositionExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getFilesChangedSince(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_fromPosition: &crate::types::JournalPosition,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::FileDelta>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getFilesChangedSince",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_fromPosition", TType::Struct, 2i16);
                    arg_fromPosition.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<crate::types::FileDelta> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GetFilesChangedSinceExn::read(p)? {
                                    crate::services::eden_service::GetFilesChangedSinceExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGetFilesChangedSinceError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGetFilesChangedSinceError(
                                    crate::services::eden_service::GetFilesChangedSinceExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn setJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_limit: i64,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "setJournalMemoryLimit",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_limit", TType::I64, 2i16);
                    arg_limit.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::SetJournalMemoryLimitExn::read(p)? {
                                    crate::services::eden_service::SetJournalMemoryLimitExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceSetJournalMemoryLimitError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceSetJournalMemoryLimitError(
                                    crate::services::eden_service::SetJournalMemoryLimitExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getJournalMemoryLimit",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<i64> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GetJournalMemoryLimitExn::read(p)? {
                                    crate::services::eden_service::GetJournalMemoryLimitExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGetJournalMemoryLimitError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGetJournalMemoryLimitError(
                                    crate::services::eden_service::GetJournalMemoryLimitExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn flushJournal(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "flushJournal",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::FlushJournalExn::read(p)? {
                                    crate::services::eden_service::FlushJournalExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceFlushJournalError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceFlushJournalError(
                                    crate::services::eden_service::FlushJournalExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugGetRawJournal(
            &self,
            arg_params: &crate::types::DebugGetRawJournalParams,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::DebugGetRawJournalResponse>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "debugGetRawJournal",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_params", TType::Struct, 1i16);
                    arg_params.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<crate::types::DebugGetRawJournalResponse> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::DebugGetRawJournalExn::read(p)? {
                                    crate::services::eden_service::DebugGetRawJournalExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceDebugGetRawJournalError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceDebugGetRawJournalError(
                                    crate::services::eden_service::DebugGetRawJournalExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getFileInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &Vec<crate::types::PathString>,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::FileInformationOrError>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getFileInformation",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_paths", TType::List, 2i16);
                    arg_paths.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<Vec<crate::types::FileInformationOrError>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GetFileInformationExn::read(p)? {
                                    crate::services::eden_service::GetFileInformationExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGetFileInformationError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGetFileInformationError(
                                    crate::services::eden_service::GetFileInformationExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn glob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_globs: &Vec<String>,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::PathString>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "glob",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_globs", TType::List, 2i16);
                    arg_globs.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<Vec<crate::types::PathString>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GlobExn::read(p)? {
                                    crate::services::eden_service::GlobExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGlobError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGlobError(
                                    crate::services::eden_service::GlobExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn globFiles(
            &self,
            arg_params: &crate::types::GlobParams,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::Glob>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "globFiles",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_params", TType::Struct, 1i16);
                    arg_params.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<crate::types::Glob> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GlobFilesExn::read(p)? {
                                    crate::services::eden_service::GlobFilesExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGlobFilesError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGlobFilesError(
                                    crate::services::eden_service::GlobFilesExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn chown(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_uid: i32,
            arg_gid: i32,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "chown",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_uid", TType::I32, 2i16);
                    arg_uid.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_gid", TType::I32, 3i16);
                    arg_gid.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::ChownExn::read(p)? {
                                    crate::services::eden_service::ChownExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceChownError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceChownError(
                                    crate::services::eden_service::ChownExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getScmStatusV2(
            &self,
            arg_params: &crate::types::GetScmStatusParams,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::GetScmStatusResult>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getScmStatusV2",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_params", TType::Struct, 1i16);
                    arg_params.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<crate::types::GetScmStatusResult> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GetScmStatusV2Exn::read(p)? {
                                    crate::services::eden_service::GetScmStatusV2Exn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGetScmStatusV2Error(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGetScmStatusV2Error(
                                    crate::services::eden_service::GetScmStatusV2Exn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getScmStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_listIgnored: bool,
            arg_commit: &crate::types::BinaryHash,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::ScmStatus>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getScmStatus",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_listIgnored", TType::Bool, 2i16);
                    arg_listIgnored.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_commit", TType::String, 3i16);
                    arg_commit.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<crate::types::ScmStatus> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GetScmStatusExn::read(p)? {
                                    crate::services::eden_service::GetScmStatusExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGetScmStatusError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGetScmStatusError(
                                    crate::services::eden_service::GetScmStatusExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getScmStatusBetweenRevisions(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_oldHash: &crate::types::BinaryHash,
            arg_newHash: &crate::types::BinaryHash,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::ScmStatus>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getScmStatusBetweenRevisions",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_oldHash", TType::String, 2i16);
                    arg_oldHash.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_newHash", TType::String, 3i16);
                    arg_newHash.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<crate::types::ScmStatus> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GetScmStatusBetweenRevisionsExn::read(p)? {
                                    crate::services::eden_service::GetScmStatusBetweenRevisionsExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGetScmStatusBetweenRevisionsError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGetScmStatusBetweenRevisionsError(
                                    crate::services::eden_service::GetScmStatusBetweenRevisionsExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getManifestEntry(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_relativePath: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::ManifestEntry>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getManifestEntry",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_relativePath", TType::String, 2i16);
                    arg_relativePath.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<crate::types::ManifestEntry> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GetManifestEntryExn::read(p)? {
                                    crate::services::eden_service::GetManifestEntryExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGetManifestEntryError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGetManifestEntryError(
                                    crate::services::eden_service::GetManifestEntryExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getDaemonInfo(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::DaemonInfo>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getDaemonInfo",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<crate::types::DaemonInfo> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GetDaemonInfoExn::read(p)? {
                                    crate::services::eden_service::GetDaemonInfoExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGetDaemonInfoError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGetDaemonInfoError(
                                    crate::services::eden_service::GetDaemonInfoExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getPid(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getPid",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<i64> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GetPidExn::read(p)? {
                                    crate::services::eden_service::GetPidExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGetPidError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGetPidError(
                                    crate::services::eden_service::GetPidExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn initiateShutdown(
            &self,
            arg_reason: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "initiateShutdown",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_reason", TType::String, 1i16);
                    arg_reason.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::InitiateShutdownExn::read(p)? {
                                    crate::services::eden_service::InitiateShutdownExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceInitiateShutdownError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceInitiateShutdownError(
                                    crate::services::eden_service::InitiateShutdownExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getConfig(
            &self,
            arg_params: &crate::types::GetConfigParams,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<eden_config::types::EdenConfigData>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getConfig",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_params", TType::Struct, 1i16);
                    arg_params.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<eden_config::types::EdenConfigData> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GetConfigExn::read(p)? {
                                    crate::services::eden_service::GetConfigExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGetConfigError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGetConfigError(
                                    crate::services::eden_service::GetConfigExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn reloadConfig(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "reloadConfig",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::ReloadConfigExn::read(p)? {
                                    crate::services::eden_service::ReloadConfigExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceReloadConfigError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceReloadConfigError(
                                    crate::services::eden_service::ReloadConfigExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugGetScmTree(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: bool,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::ScmTreeEntry>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "debugGetScmTree",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_id", TType::String, 2i16);
                    arg_id.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_localStoreOnly", TType::Bool, 3i16);
                    arg_localStoreOnly.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<Vec<crate::types::ScmTreeEntry>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::DebugGetScmTreeExn::read(p)? {
                                    crate::services::eden_service::DebugGetScmTreeExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceDebugGetScmTreeError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceDebugGetScmTreeError(
                                    crate::services::eden_service::DebugGetScmTreeExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugGetScmBlob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: bool,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<u8>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "debugGetScmBlob",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_id", TType::String, 2i16);
                    arg_id.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_localStoreOnly", TType::Bool, 3i16);
                    arg_localStoreOnly.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<Vec<u8>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::DebugGetScmBlobExn::read(p)? {
                                    crate::services::eden_service::DebugGetScmBlobExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceDebugGetScmBlobError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceDebugGetScmBlobError(
                                    crate::services::eden_service::DebugGetScmBlobExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugGetScmBlobMetadata(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: bool,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::ScmBlobMetadata>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "debugGetScmBlobMetadata",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_id", TType::String, 2i16);
                    arg_id.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_localStoreOnly", TType::Bool, 3i16);
                    arg_localStoreOnly.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<crate::types::ScmBlobMetadata> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::DebugGetScmBlobMetadataExn::read(p)? {
                                    crate::services::eden_service::DebugGetScmBlobMetadataExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceDebugGetScmBlobMetadataError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceDebugGetScmBlobMetadataError(
                                    crate::services::eden_service::DebugGetScmBlobMetadataExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugInodeStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::TreeInodeDebugInfo>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "debugInodeStatus",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_path", TType::String, 2i16);
                    arg_path.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<Vec<crate::types::TreeInodeDebugInfo>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::DebugInodeStatusExn::read(p)? {
                                    crate::services::eden_service::DebugInodeStatusExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceDebugInodeStatusError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceDebugInodeStatusError(
                                    crate::services::eden_service::DebugInodeStatusExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugOutstandingFuseCalls(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::FuseCall>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "debugOutstandingFuseCalls",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<Vec<crate::types::FuseCall>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::DebugOutstandingFuseCallsExn::read(p)? {
                                    crate::services::eden_service::DebugOutstandingFuseCallsExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceDebugOutstandingFuseCallsError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceDebugOutstandingFuseCallsError(
                                    crate::services::eden_service::DebugOutstandingFuseCallsExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugGetInodePath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_inodeNumber: i64,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::InodePathDebugInfo>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "debugGetInodePath",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_inodeNumber", TType::I64, 2i16);
                    arg_inodeNumber.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<crate::types::InodePathDebugInfo> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::DebugGetInodePathExn::read(p)? {
                                    crate::services::eden_service::DebugGetInodePathExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceDebugGetInodePathError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceDebugGetInodePathError(
                                    crate::services::eden_service::DebugGetInodePathExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugSetLogLevel(
            &self,
            arg_category: &str,
            arg_level: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::SetLogLevelResult>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "debugSetLogLevel",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_category", TType::String, 1i16);
                    arg_category.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_level", TType::String, 2i16);
                    arg_level.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<crate::types::SetLogLevelResult> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::DebugSetLogLevelExn::read(p)? {
                                    crate::services::eden_service::DebugSetLogLevelExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceDebugSetLogLevelError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceDebugSetLogLevelError(
                                    crate::services::eden_service::DebugSetLogLevelExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getAccessCounts(
            &self,
            arg_duration: i64,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::GetAccessCountsResult>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getAccessCounts",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_duration", TType::I64, 1i16);
                    arg_duration.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<crate::types::GetAccessCountsResult> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GetAccessCountsExn::read(p)? {
                                    crate::services::eden_service::GetAccessCountsExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGetAccessCountsError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGetAccessCountsError(
                                    crate::services::eden_service::GetAccessCountsExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn clearAndCompactLocalStore(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "clearAndCompactLocalStore",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::ClearAndCompactLocalStoreExn::read(p)? {
                                    crate::services::eden_service::ClearAndCompactLocalStoreExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceClearAndCompactLocalStoreError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceClearAndCompactLocalStoreError(
                                    crate::services::eden_service::ClearAndCompactLocalStoreExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugClearLocalStoreCaches(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "debugClearLocalStoreCaches",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::DebugClearLocalStoreCachesExn::read(p)? {
                                    crate::services::eden_service::DebugClearLocalStoreCachesExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceDebugClearLocalStoreCachesError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceDebugClearLocalStoreCachesError(
                                    crate::services::eden_service::DebugClearLocalStoreCachesExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugCompactLocalStorage(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "debugCompactLocalStorage",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::DebugCompactLocalStorageExn::read(p)? {
                                    crate::services::eden_service::DebugCompactLocalStorageExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceDebugCompactLocalStorageError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceDebugCompactLocalStorageError(
                                    crate::services::eden_service::DebugCompactLocalStorageExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn unloadInodeForPath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
            arg_age: &crate::types::TimeSpec,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "unloadInodeForPath",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_path", TType::String, 2i16);
                    arg_path.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_age", TType::Struct, 3i16);
                    arg_age.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<i64> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::UnloadInodeForPathExn::read(p)? {
                                    crate::services::eden_service::UnloadInodeForPathExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceUnloadInodeForPathError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceUnloadInodeForPathError(
                                    crate::services::eden_service::UnloadInodeForPathExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn flushStatsNow(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "flushStatsNow",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::FlushStatsNowExn::read(p)? {
                                    crate::services::eden_service::FlushStatsNowExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceFlushStatsNowError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceFlushStatsNowError(
                                    crate::services::eden_service::FlushStatsNowExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn invalidateKernelInodeCache(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "invalidateKernelInodeCache",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", TType::String, 1i16);
                    arg_mountPoint.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_path", TType::String, 2i16);
                    arg_path.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::InvalidateKernelInodeCacheExn::read(p)? {
                                    crate::services::eden_service::InvalidateKernelInodeCacheExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceInvalidateKernelInodeCacheError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceInvalidateKernelInodeCacheError(
                                    crate::services::eden_service::InvalidateKernelInodeCacheExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getStatInfo(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::InternalStats>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getStatInfo",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<crate::types::InternalStats> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GetStatInfoExn::read(p)? {
                                    crate::services::eden_service::GetStatInfoExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGetStatInfoError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGetStatInfoError(
                                    crate::services::eden_service::GetStatInfoExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn enableTracing(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "enableTracing",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::EnableTracingExn::read(p)? {
                                    crate::services::eden_service::EnableTracingExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceEnableTracingError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceEnableTracingError(
                                    crate::services::eden_service::EnableTracingExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn disableTracing(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "disableTracing",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::DisableTracingExn::read(p)? {
                                    crate::services::eden_service::DisableTracingExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceDisableTracingError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceDisableTracingError(
                                    crate::services::eden_service::DisableTracingExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getTracePoints(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::TracePoint>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getTracePoints",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<Vec<crate::types::TracePoint>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::GetTracePointsExn::read(p)? {
                                    crate::services::eden_service::GetTracePointsExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceGetTracePointsError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceGetTracePointsError(
                                    crate::services::eden_service::GetTracePointsExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn injectFault(
            &self,
            arg_fault: &crate::types::FaultDefinition,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "injectFault",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_fault", TType::Struct, 1i16);
                    arg_fault.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::InjectFaultExn::read(p)? {
                                    crate::services::eden_service::InjectFaultExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceInjectFaultError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceInjectFaultError(
                                    crate::services::eden_service::InjectFaultExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn removeFault(
            &self,
            arg_fault: &crate::types::RemoveFaultArg,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<bool>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "removeFault",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_fault", TType::Struct, 1i16);
                    arg_fault.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<bool> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::RemoveFaultExn::read(p)? {
                                    crate::services::eden_service::RemoveFaultExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceRemoveFaultError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceRemoveFaultError(
                                    crate::services::eden_service::RemoveFaultExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn unblockFault(
            &self,
            arg_info: &crate::types::UnblockFaultArg,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "unblockFault",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_info", TType::Struct, 1i16);
                    arg_info.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<i64> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::eden_service::UnblockFaultExn::read(p)? {
                                    crate::services::eden_service::UnblockFaultExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::EdenServiceUnblockFaultError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::EdenServiceUnblockFaultError(
                                    crate::services::eden_service::UnblockFaultExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
    }

    pub struct make_EdenService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = BuckGraphService::new(protocol, transport);
    /// ```
    impl dyn EdenService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> Arc<impl EdenService + Send + 'static>
        where
            P: Protocol<Frame = T>,
            T: Transport,
        {
            let _ = protocol;
            Arc::new(EdenServiceImpl::<P, T>::new(transport))
        }
    }

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ClientFactory for make_EdenService {
        type Api = dyn EdenService + Send + Sync + 'static;

        fn new<P, T>(protocol: P, transport: T) -> Arc<Self::Api>
        where
            P: Protocol<Frame = T>,
            T: Transport + Sync,
        {
            EdenService::new(protocol, transport)
        }
    }
}

pub mod server {
    use async_trait::async_trait;
    use fbthrift::*;
    use std::marker::PhantomData;

    #[async_trait]
    pub trait EdenService: Send + Sync + 'static {
        async fn listMounts(
            &self,
        ) -> Result<Vec<crate::types::MountInfo>, crate::services::eden_service::ListMountsExn> {
            Err(crate::services::eden_service::ListMountsExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "listMounts",
                ),
            ))
        }
        async fn mount(
            &self,
            _info: crate::types::MountArgument,
        ) -> Result<(), crate::services::eden_service::MountExn> {
            Err(crate::services::eden_service::MountExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "mount",
                ),
            ))
        }
        async fn unmount(
            &self,
            _mountPoint: crate::types::PathString,
        ) -> Result<(), crate::services::eden_service::UnmountExn> {
            Err(crate::services::eden_service::UnmountExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "unmount",
                ),
            ))
        }
        async fn checkOutRevision(
            &self,
            _mountPoint: crate::types::PathString,
            _snapshotHash: crate::types::BinaryHash,
            _checkoutMode: crate::types::CheckoutMode,
        ) -> Result<Vec<crate::types::CheckoutConflict>, crate::services::eden_service::CheckOutRevisionExn> {
            Err(crate::services::eden_service::CheckOutRevisionExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "checkOutRevision",
                ),
            ))
        }
        async fn resetParentCommits(
            &self,
            _mountPoint: crate::types::PathString,
            _parents: crate::types::WorkingDirectoryParents,
        ) -> Result<(), crate::services::eden_service::ResetParentCommitsExn> {
            Err(crate::services::eden_service::ResetParentCommitsExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "resetParentCommits",
                ),
            ))
        }
        async fn getSHA1(
            &self,
            _mountPoint: crate::types::PathString,
            _paths: Vec<crate::types::PathString>,
        ) -> Result<Vec<crate::types::SHA1Result>, crate::services::eden_service::GetSHA1Exn> {
            Err(crate::services::eden_service::GetSHA1Exn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "getSHA1",
                ),
            ))
        }
        async fn getBindMounts(
            &self,
            _mountPoint: crate::types::PathString,
        ) -> Result<Vec<crate::types::PathString>, crate::services::eden_service::GetBindMountsExn> {
            Err(crate::services::eden_service::GetBindMountsExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "getBindMounts",
                ),
            ))
        }
        async fn addBindMount(
            &self,
            _mountPoint: crate::types::PathString,
            _repoPath: crate::types::PathString,
            _targetPath: crate::types::PathString,
        ) -> Result<(), crate::services::eden_service::AddBindMountExn> {
            Err(crate::services::eden_service::AddBindMountExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "addBindMount",
                ),
            ))
        }
        async fn removeBindMount(
            &self,
            _mountPoint: crate::types::PathString,
            _repoPath: crate::types::PathString,
        ) -> Result<(), crate::services::eden_service::RemoveBindMountExn> {
            Err(crate::services::eden_service::RemoveBindMountExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "removeBindMount",
                ),
            ))
        }
        async fn getCurrentJournalPosition(
            &self,
            _mountPoint: crate::types::PathString,
        ) -> Result<crate::types::JournalPosition, crate::services::eden_service::GetCurrentJournalPositionExn> {
            Err(crate::services::eden_service::GetCurrentJournalPositionExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "getCurrentJournalPosition",
                ),
            ))
        }
        async fn getFilesChangedSince(
            &self,
            _mountPoint: crate::types::PathString,
            _fromPosition: crate::types::JournalPosition,
        ) -> Result<crate::types::FileDelta, crate::services::eden_service::GetFilesChangedSinceExn> {
            Err(crate::services::eden_service::GetFilesChangedSinceExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "getFilesChangedSince",
                ),
            ))
        }
        async fn setJournalMemoryLimit(
            &self,
            _mountPoint: crate::types::PathString,
            _limit: i64,
        ) -> Result<(), crate::services::eden_service::SetJournalMemoryLimitExn> {
            Err(crate::services::eden_service::SetJournalMemoryLimitExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "setJournalMemoryLimit",
                ),
            ))
        }
        async fn getJournalMemoryLimit(
            &self,
            _mountPoint: crate::types::PathString,
        ) -> Result<i64, crate::services::eden_service::GetJournalMemoryLimitExn> {
            Err(crate::services::eden_service::GetJournalMemoryLimitExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "getJournalMemoryLimit",
                ),
            ))
        }
        async fn flushJournal(
            &self,
            _mountPoint: crate::types::PathString,
        ) -> Result<(), crate::services::eden_service::FlushJournalExn> {
            Err(crate::services::eden_service::FlushJournalExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "flushJournal",
                ),
            ))
        }
        async fn debugGetRawJournal(
            &self,
            _params: crate::types::DebugGetRawJournalParams,
        ) -> Result<crate::types::DebugGetRawJournalResponse, crate::services::eden_service::DebugGetRawJournalExn> {
            Err(crate::services::eden_service::DebugGetRawJournalExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugGetRawJournal",
                ),
            ))
        }
        async fn getFileInformation(
            &self,
            _mountPoint: crate::types::PathString,
            _paths: Vec<crate::types::PathString>,
        ) -> Result<Vec<crate::types::FileInformationOrError>, crate::services::eden_service::GetFileInformationExn> {
            Err(crate::services::eden_service::GetFileInformationExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "getFileInformation",
                ),
            ))
        }
        async fn glob(
            &self,
            _mountPoint: crate::types::PathString,
            _globs: Vec<String>,
        ) -> Result<Vec<crate::types::PathString>, crate::services::eden_service::GlobExn> {
            Err(crate::services::eden_service::GlobExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "glob",
                ),
            ))
        }
        async fn globFiles(
            &self,
            _params: crate::types::GlobParams,
        ) -> Result<crate::types::Glob, crate::services::eden_service::GlobFilesExn> {
            Err(crate::services::eden_service::GlobFilesExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "globFiles",
                ),
            ))
        }
        async fn chown(
            &self,
            _mountPoint: crate::types::PathString,
            _uid: i32,
            _gid: i32,
        ) -> Result<(), crate::services::eden_service::ChownExn> {
            Err(crate::services::eden_service::ChownExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "chown",
                ),
            ))
        }
        async fn getScmStatusV2(
            &self,
            _params: crate::types::GetScmStatusParams,
        ) -> Result<crate::types::GetScmStatusResult, crate::services::eden_service::GetScmStatusV2Exn> {
            Err(crate::services::eden_service::GetScmStatusV2Exn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "getScmStatusV2",
                ),
            ))
        }
        async fn getScmStatus(
            &self,
            _mountPoint: crate::types::PathString,
            _listIgnored: bool,
            _commit: crate::types::BinaryHash,
        ) -> Result<crate::types::ScmStatus, crate::services::eden_service::GetScmStatusExn> {
            Err(crate::services::eden_service::GetScmStatusExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "getScmStatus",
                ),
            ))
        }
        async fn getScmStatusBetweenRevisions(
            &self,
            _mountPoint: crate::types::PathString,
            _oldHash: crate::types::BinaryHash,
            _newHash: crate::types::BinaryHash,
        ) -> Result<crate::types::ScmStatus, crate::services::eden_service::GetScmStatusBetweenRevisionsExn> {
            Err(crate::services::eden_service::GetScmStatusBetweenRevisionsExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "getScmStatusBetweenRevisions",
                ),
            ))
        }
        async fn getManifestEntry(
            &self,
            _mountPoint: crate::types::PathString,
            _relativePath: crate::types::PathString,
        ) -> Result<crate::types::ManifestEntry, crate::services::eden_service::GetManifestEntryExn> {
            Err(crate::services::eden_service::GetManifestEntryExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "getManifestEntry",
                ),
            ))
        }
        async fn getDaemonInfo(
            &self,
        ) -> Result<crate::types::DaemonInfo, crate::services::eden_service::GetDaemonInfoExn> {
            Err(crate::services::eden_service::GetDaemonInfoExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "getDaemonInfo",
                ),
            ))
        }
        async fn getPid(
            &self,
        ) -> Result<i64, crate::services::eden_service::GetPidExn> {
            Err(crate::services::eden_service::GetPidExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "getPid",
                ),
            ))
        }
        async fn initiateShutdown(
            &self,
            _reason: String,
        ) -> Result<(), crate::services::eden_service::InitiateShutdownExn> {
            Err(crate::services::eden_service::InitiateShutdownExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "initiateShutdown",
                ),
            ))
        }
        async fn getConfig(
            &self,
            _params: crate::types::GetConfigParams,
        ) -> Result<eden_config::types::EdenConfigData, crate::services::eden_service::GetConfigExn> {
            Err(crate::services::eden_service::GetConfigExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "getConfig",
                ),
            ))
        }
        async fn reloadConfig(
            &self,
        ) -> Result<(), crate::services::eden_service::ReloadConfigExn> {
            Err(crate::services::eden_service::ReloadConfigExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "reloadConfig",
                ),
            ))
        }
        async fn debugGetScmTree(
            &self,
            _mountPoint: crate::types::PathString,
            _id: crate::types::BinaryHash,
            _localStoreOnly: bool,
        ) -> Result<Vec<crate::types::ScmTreeEntry>, crate::services::eden_service::DebugGetScmTreeExn> {
            Err(crate::services::eden_service::DebugGetScmTreeExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugGetScmTree",
                ),
            ))
        }
        async fn debugGetScmBlob(
            &self,
            _mountPoint: crate::types::PathString,
            _id: crate::types::BinaryHash,
            _localStoreOnly: bool,
        ) -> Result<Vec<u8>, crate::services::eden_service::DebugGetScmBlobExn> {
            Err(crate::services::eden_service::DebugGetScmBlobExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugGetScmBlob",
                ),
            ))
        }
        async fn debugGetScmBlobMetadata(
            &self,
            _mountPoint: crate::types::PathString,
            _id: crate::types::BinaryHash,
            _localStoreOnly: bool,
        ) -> Result<crate::types::ScmBlobMetadata, crate::services::eden_service::DebugGetScmBlobMetadataExn> {
            Err(crate::services::eden_service::DebugGetScmBlobMetadataExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugGetScmBlobMetadata",
                ),
            ))
        }
        async fn debugInodeStatus(
            &self,
            _mountPoint: crate::types::PathString,
            _path: crate::types::PathString,
        ) -> Result<Vec<crate::types::TreeInodeDebugInfo>, crate::services::eden_service::DebugInodeStatusExn> {
            Err(crate::services::eden_service::DebugInodeStatusExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugInodeStatus",
                ),
            ))
        }
        async fn debugOutstandingFuseCalls(
            &self,
            _mountPoint: crate::types::PathString,
        ) -> Result<Vec<crate::types::FuseCall>, crate::services::eden_service::DebugOutstandingFuseCallsExn> {
            Err(crate::services::eden_service::DebugOutstandingFuseCallsExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugOutstandingFuseCalls",
                ),
            ))
        }
        async fn debugGetInodePath(
            &self,
            _mountPoint: crate::types::PathString,
            _inodeNumber: i64,
        ) -> Result<crate::types::InodePathDebugInfo, crate::services::eden_service::DebugGetInodePathExn> {
            Err(crate::services::eden_service::DebugGetInodePathExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugGetInodePath",
                ),
            ))
        }
        async fn debugSetLogLevel(
            &self,
            _category: String,
            _level: String,
        ) -> Result<crate::types::SetLogLevelResult, crate::services::eden_service::DebugSetLogLevelExn> {
            Err(crate::services::eden_service::DebugSetLogLevelExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugSetLogLevel",
                ),
            ))
        }
        async fn getAccessCounts(
            &self,
            _duration: i64,
        ) -> Result<crate::types::GetAccessCountsResult, crate::services::eden_service::GetAccessCountsExn> {
            Err(crate::services::eden_service::GetAccessCountsExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "getAccessCounts",
                ),
            ))
        }
        async fn clearAndCompactLocalStore(
            &self,
        ) -> Result<(), crate::services::eden_service::ClearAndCompactLocalStoreExn> {
            Err(crate::services::eden_service::ClearAndCompactLocalStoreExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "clearAndCompactLocalStore",
                ),
            ))
        }
        async fn debugClearLocalStoreCaches(
            &self,
        ) -> Result<(), crate::services::eden_service::DebugClearLocalStoreCachesExn> {
            Err(crate::services::eden_service::DebugClearLocalStoreCachesExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugClearLocalStoreCaches",
                ),
            ))
        }
        async fn debugCompactLocalStorage(
            &self,
        ) -> Result<(), crate::services::eden_service::DebugCompactLocalStorageExn> {
            Err(crate::services::eden_service::DebugCompactLocalStorageExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugCompactLocalStorage",
                ),
            ))
        }
        async fn unloadInodeForPath(
            &self,
            _mountPoint: crate::types::PathString,
            _path: crate::types::PathString,
            _age: crate::types::TimeSpec,
        ) -> Result<i64, crate::services::eden_service::UnloadInodeForPathExn> {
            Err(crate::services::eden_service::UnloadInodeForPathExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "unloadInodeForPath",
                ),
            ))
        }
        async fn flushStatsNow(
            &self,
        ) -> Result<(), crate::services::eden_service::FlushStatsNowExn> {
            Err(crate::services::eden_service::FlushStatsNowExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "flushStatsNow",
                ),
            ))
        }
        async fn invalidateKernelInodeCache(
            &self,
            _mountPoint: crate::types::PathString,
            _path: crate::types::PathString,
        ) -> Result<(), crate::services::eden_service::InvalidateKernelInodeCacheExn> {
            Err(crate::services::eden_service::InvalidateKernelInodeCacheExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "invalidateKernelInodeCache",
                ),
            ))
        }
        async fn getStatInfo(
            &self,
        ) -> Result<crate::types::InternalStats, crate::services::eden_service::GetStatInfoExn> {
            Err(crate::services::eden_service::GetStatInfoExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "getStatInfo",
                ),
            ))
        }
        async fn enableTracing(
            &self,
        ) -> Result<(), crate::services::eden_service::EnableTracingExn> {
            Err(crate::services::eden_service::EnableTracingExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "enableTracing",
                ),
            ))
        }
        async fn disableTracing(
            &self,
        ) -> Result<(), crate::services::eden_service::DisableTracingExn> {
            Err(crate::services::eden_service::DisableTracingExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "disableTracing",
                ),
            ))
        }
        async fn getTracePoints(
            &self,
        ) -> Result<Vec<crate::types::TracePoint>, crate::services::eden_service::GetTracePointsExn> {
            Err(crate::services::eden_service::GetTracePointsExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "getTracePoints",
                ),
            ))
        }
        async fn injectFault(
            &self,
            _fault: crate::types::FaultDefinition,
        ) -> Result<(), crate::services::eden_service::InjectFaultExn> {
            Err(crate::services::eden_service::InjectFaultExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "injectFault",
                ),
            ))
        }
        async fn removeFault(
            &self,
            _fault: crate::types::RemoveFaultArg,
        ) -> Result<bool, crate::services::eden_service::RemoveFaultExn> {
            Err(crate::services::eden_service::RemoveFaultExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "removeFault",
                ),
            ))
        }
        async fn unblockFault(
            &self,
            _info: crate::types::UnblockFaultArg,
        ) -> Result<i64, crate::services::eden_service::UnblockFaultExn> {
            Err(crate::services::eden_service::UnblockFaultExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "EdenService",
                    "unblockFault",
                ),
            ))
        }
    }

    #[derive(Clone, Debug)]
    pub struct EdenServiceProcessor<P, H, R, SS> {
        service: H,
        supa: SS,
        _phantom: PhantomData<(P, H, R)>,
    }

    impl<P, H, R, SS> EdenServiceProcessor<P, H, R, SS>
    where
        P: Protocol + Send + Sync + 'static,
        P::Deserializer: Send,
        H: EdenService,
        SS: ThriftService<P::Frame>,
        SS::Handler: fb303_core::server::BaseService,
        P::Frame: Send + 'static,
    {
        pub fn new(service: H, supa: SS) -> Self {
            Self {
                service,
                supa,
                _phantom: PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        async fn handle_listMounts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.listMounts(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::ListMountsExn::Success(res)
                }
                Err(crate::services::eden_service::ListMountsExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::ListMountsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listMounts",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "listMounts",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_mount<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_info = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Struct, 1) => field_info = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.mount(
                field_info.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "mount",
                        "info",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::MountExn::Success(res)
                }
                Err(crate::services::eden_service::MountExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::MountExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "mount",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "mount",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_unmount<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.unmount(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "unmount",
                        "mountPoint",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::UnmountExn::Success(res)
                }
                Err(crate::services::eden_service::UnmountExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::UnmountExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "unmount",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "unmount",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_checkOutRevision<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_snapshotHash = None;
            let mut field_checkoutMode = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_snapshotHash = Some(Deserialize::read(p)?),
                    (TType::I32, 3) => field_checkoutMode = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.checkOutRevision(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "checkOutRevision",
                        "mountPoint",
                    )
                })?,
                field_snapshotHash.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "checkOutRevision",
                        "snapshotHash",
                    )
                })?,
                field_checkoutMode.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "checkOutRevision",
                        "checkoutMode",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::CheckOutRevisionExn::Success(res)
                }
                Err(crate::services::eden_service::CheckOutRevisionExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::CheckOutRevisionExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "checkOutRevision",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "checkOutRevision",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_resetParentCommits<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_parents = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::Struct, 2) => field_parents = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.resetParentCommits(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "resetParentCommits",
                        "mountPoint",
                    )
                })?,
                field_parents.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "resetParentCommits",
                        "parents",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::ResetParentCommitsExn::Success(res)
                }
                Err(crate::services::eden_service::ResetParentCommitsExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::ResetParentCommitsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "resetParentCommits",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "resetParentCommits",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getSHA1<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_paths = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::List, 2) => field_paths = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getSHA1(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getSHA1",
                        "mountPoint",
                    )
                })?,
                field_paths.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getSHA1",
                        "paths",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GetSHA1Exn::Success(res)
                }
                Err(crate::services::eden_service::GetSHA1Exn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GetSHA1Exn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getSHA1",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getSHA1",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getBindMounts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getBindMounts(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getBindMounts",
                        "mountPoint",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GetBindMountsExn::Success(res)
                }
                Err(crate::services::eden_service::GetBindMountsExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GetBindMountsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getBindMounts",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getBindMounts",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_addBindMount<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_repoPath = None;
            let mut field_targetPath = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_repoPath = Some(Deserialize::read(p)?),
                    (TType::String, 3) => field_targetPath = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.addBindMount(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "addBindMount",
                        "mountPoint",
                    )
                })?,
                field_repoPath.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "addBindMount",
                        "repoPath",
                    )
                })?,
                field_targetPath.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "addBindMount",
                        "targetPath",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::AddBindMountExn::Success(res)
                }
                Err(crate::services::eden_service::AddBindMountExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::AddBindMountExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addBindMount",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "addBindMount",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_removeBindMount<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_repoPath = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_repoPath = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.removeBindMount(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "removeBindMount",
                        "mountPoint",
                    )
                })?,
                field_repoPath.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "removeBindMount",
                        "repoPath",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::RemoveBindMountExn::Success(res)
                }
                Err(crate::services::eden_service::RemoveBindMountExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::RemoveBindMountExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removeBindMount",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "removeBindMount",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getCurrentJournalPosition<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getCurrentJournalPosition(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getCurrentJournalPosition",
                        "mountPoint",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GetCurrentJournalPositionExn::Success(res)
                }
                Err(crate::services::eden_service::GetCurrentJournalPositionExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GetCurrentJournalPositionExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getCurrentJournalPosition",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getCurrentJournalPosition",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getFilesChangedSince<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_fromPosition = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::Struct, 2) => field_fromPosition = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getFilesChangedSince(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getFilesChangedSince",
                        "mountPoint",
                    )
                })?,
                field_fromPosition.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getFilesChangedSince",
                        "fromPosition",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GetFilesChangedSinceExn::Success(res)
                }
                Err(crate::services::eden_service::GetFilesChangedSinceExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GetFilesChangedSinceExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getFilesChangedSince",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getFilesChangedSince",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_setJournalMemoryLimit<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_limit = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::I64, 2) => field_limit = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.setJournalMemoryLimit(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "setJournalMemoryLimit",
                        "mountPoint",
                    )
                })?,
                field_limit.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "setJournalMemoryLimit",
                        "limit",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::SetJournalMemoryLimitExn::Success(res)
                }
                Err(crate::services::eden_service::SetJournalMemoryLimitExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::SetJournalMemoryLimitExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "setJournalMemoryLimit",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "setJournalMemoryLimit",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getJournalMemoryLimit<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getJournalMemoryLimit(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getJournalMemoryLimit",
                        "mountPoint",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GetJournalMemoryLimitExn::Success(res)
                }
                Err(crate::services::eden_service::GetJournalMemoryLimitExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GetJournalMemoryLimitExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getJournalMemoryLimit",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getJournalMemoryLimit",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_flushJournal<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.flushJournal(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "flushJournal",
                        "mountPoint",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::FlushJournalExn::Success(res)
                }
                Err(crate::services::eden_service::FlushJournalExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::FlushJournalExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "flushJournal",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "flushJournal",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_debugGetRawJournal<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_params = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Struct, 1) => field_params = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugGetRawJournal(
                field_params.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugGetRawJournal",
                        "params",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::DebugGetRawJournalExn::Success(res)
                }
                Err(crate::services::eden_service::DebugGetRawJournalExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::DebugGetRawJournalExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugGetRawJournal",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "debugGetRawJournal",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getFileInformation<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_paths = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::List, 2) => field_paths = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getFileInformation(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getFileInformation",
                        "mountPoint",
                    )
                })?,
                field_paths.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getFileInformation",
                        "paths",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GetFileInformationExn::Success(res)
                }
                Err(crate::services::eden_service::GetFileInformationExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GetFileInformationExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getFileInformation",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getFileInformation",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_glob<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_globs = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::List, 2) => field_globs = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.glob(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "glob",
                        "mountPoint",
                    )
                })?,
                field_globs.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "glob",
                        "globs",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GlobExn::Success(res)
                }
                Err(crate::services::eden_service::GlobExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GlobExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "glob",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "glob",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_globFiles<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_params = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Struct, 1) => field_params = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.globFiles(
                field_params.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "globFiles",
                        "params",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GlobFilesExn::Success(res)
                }
                Err(crate::services::eden_service::GlobFilesExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GlobFilesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "globFiles",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "globFiles",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_chown<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_uid = None;
            let mut field_gid = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::I32, 2) => field_uid = Some(Deserialize::read(p)?),
                    (TType::I32, 3) => field_gid = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.chown(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "chown",
                        "mountPoint",
                    )
                })?,
                field_uid.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "chown",
                        "uid",
                    )
                })?,
                field_gid.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "chown",
                        "gid",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::ChownExn::Success(res)
                }
                Err(crate::services::eden_service::ChownExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::ChownExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "chown",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "chown",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getScmStatusV2<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_params = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Struct, 1) => field_params = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getScmStatusV2(
                field_params.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getScmStatusV2",
                        "params",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GetScmStatusV2Exn::Success(res)
                }
                Err(crate::services::eden_service::GetScmStatusV2Exn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GetScmStatusV2Exn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getScmStatusV2",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getScmStatusV2",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getScmStatus<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_listIgnored = None;
            let mut field_commit = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::Bool, 2) => field_listIgnored = Some(Deserialize::read(p)?),
                    (TType::String, 3) => field_commit = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getScmStatus(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getScmStatus",
                        "mountPoint",
                    )
                })?,
                field_listIgnored.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getScmStatus",
                        "listIgnored",
                    )
                })?,
                field_commit.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getScmStatus",
                        "commit",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GetScmStatusExn::Success(res)
                }
                Err(crate::services::eden_service::GetScmStatusExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GetScmStatusExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getScmStatus",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getScmStatus",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getScmStatusBetweenRevisions<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_oldHash = None;
            let mut field_newHash = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_oldHash = Some(Deserialize::read(p)?),
                    (TType::String, 3) => field_newHash = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getScmStatusBetweenRevisions(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getScmStatusBetweenRevisions",
                        "mountPoint",
                    )
                })?,
                field_oldHash.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getScmStatusBetweenRevisions",
                        "oldHash",
                    )
                })?,
                field_newHash.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getScmStatusBetweenRevisions",
                        "newHash",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GetScmStatusBetweenRevisionsExn::Success(res)
                }
                Err(crate::services::eden_service::GetScmStatusBetweenRevisionsExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GetScmStatusBetweenRevisionsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getScmStatusBetweenRevisions",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getScmStatusBetweenRevisions",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getManifestEntry<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_relativePath = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_relativePath = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getManifestEntry(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getManifestEntry",
                        "mountPoint",
                    )
                })?,
                field_relativePath.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getManifestEntry",
                        "relativePath",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GetManifestEntryExn::Success(res)
                }
                Err(crate::services::eden_service::GetManifestEntryExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GetManifestEntryExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getManifestEntry",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getManifestEntry",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getDaemonInfo<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getDaemonInfo(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GetDaemonInfoExn::Success(res)
                }
                Err(crate::services::eden_service::GetDaemonInfoExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GetDaemonInfoExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getDaemonInfo",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getDaemonInfo",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getPid<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getPid(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GetPidExn::Success(res)
                }
                Err(crate::services::eden_service::GetPidExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GetPidExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getPid",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getPid",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_initiateShutdown<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_reason = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_reason = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.initiateShutdown(
                field_reason.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "initiateShutdown",
                        "reason",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::InitiateShutdownExn::Success(res)
                }
                Err(crate::services::eden_service::InitiateShutdownExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::InitiateShutdownExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "initiateShutdown",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "initiateShutdown",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_params = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Struct, 1) => field_params = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getConfig(
                field_params.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getConfig",
                        "params",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GetConfigExn::Success(res)
                }
                Err(crate::services::eden_service::GetConfigExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GetConfigExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getConfig",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getConfig",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_reloadConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.reloadConfig(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::ReloadConfigExn::Success(res)
                }
                Err(crate::services::eden_service::ReloadConfigExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::ReloadConfigExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "reloadConfig",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "reloadConfig",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_debugGetScmTree<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_id = None;
            let mut field_localStoreOnly = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_id = Some(Deserialize::read(p)?),
                    (TType::Bool, 3) => field_localStoreOnly = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugGetScmTree(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugGetScmTree",
                        "mountPoint",
                    )
                })?,
                field_id.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugGetScmTree",
                        "id",
                    )
                })?,
                field_localStoreOnly.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugGetScmTree",
                        "localStoreOnly",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::DebugGetScmTreeExn::Success(res)
                }
                Err(crate::services::eden_service::DebugGetScmTreeExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::DebugGetScmTreeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugGetScmTree",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "debugGetScmTree",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_debugGetScmBlob<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_id = None;
            let mut field_localStoreOnly = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_id = Some(Deserialize::read(p)?),
                    (TType::Bool, 3) => field_localStoreOnly = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugGetScmBlob(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugGetScmBlob",
                        "mountPoint",
                    )
                })?,
                field_id.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugGetScmBlob",
                        "id",
                    )
                })?,
                field_localStoreOnly.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugGetScmBlob",
                        "localStoreOnly",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::DebugGetScmBlobExn::Success(res)
                }
                Err(crate::services::eden_service::DebugGetScmBlobExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::DebugGetScmBlobExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugGetScmBlob",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "debugGetScmBlob",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_debugGetScmBlobMetadata<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_id = None;
            let mut field_localStoreOnly = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_id = Some(Deserialize::read(p)?),
                    (TType::Bool, 3) => field_localStoreOnly = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugGetScmBlobMetadata(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugGetScmBlobMetadata",
                        "mountPoint",
                    )
                })?,
                field_id.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugGetScmBlobMetadata",
                        "id",
                    )
                })?,
                field_localStoreOnly.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugGetScmBlobMetadata",
                        "localStoreOnly",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::DebugGetScmBlobMetadataExn::Success(res)
                }
                Err(crate::services::eden_service::DebugGetScmBlobMetadataExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::DebugGetScmBlobMetadataExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugGetScmBlobMetadata",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "debugGetScmBlobMetadata",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_debugInodeStatus<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_path = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_path = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugInodeStatus(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugInodeStatus",
                        "mountPoint",
                    )
                })?,
                field_path.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugInodeStatus",
                        "path",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::DebugInodeStatusExn::Success(res)
                }
                Err(crate::services::eden_service::DebugInodeStatusExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::DebugInodeStatusExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugInodeStatus",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "debugInodeStatus",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_debugOutstandingFuseCalls<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugOutstandingFuseCalls(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugOutstandingFuseCalls",
                        "mountPoint",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::DebugOutstandingFuseCallsExn::Success(res)
                }
                Err(crate::services::eden_service::DebugOutstandingFuseCallsExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::DebugOutstandingFuseCallsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugOutstandingFuseCalls",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "debugOutstandingFuseCalls",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_debugGetInodePath<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_inodeNumber = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::I64, 2) => field_inodeNumber = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugGetInodePath(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugGetInodePath",
                        "mountPoint",
                    )
                })?,
                field_inodeNumber.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugGetInodePath",
                        "inodeNumber",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::DebugGetInodePathExn::Success(res)
                }
                Err(crate::services::eden_service::DebugGetInodePathExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::DebugGetInodePathExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugGetInodePath",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "debugGetInodePath",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_debugSetLogLevel<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_category = None;
            let mut field_level = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_category = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_level = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugSetLogLevel(
                field_category.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugSetLogLevel",
                        "category",
                    )
                })?,
                field_level.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "debugSetLogLevel",
                        "level",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::DebugSetLogLevelExn::Success(res)
                }
                Err(crate::services::eden_service::DebugSetLogLevelExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::DebugSetLogLevelExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugSetLogLevel",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "debugSetLogLevel",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getAccessCounts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_duration = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::I64, 1) => field_duration = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getAccessCounts(
                field_duration.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getAccessCounts",
                        "duration",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GetAccessCountsExn::Success(res)
                }
                Err(crate::services::eden_service::GetAccessCountsExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GetAccessCountsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getAccessCounts",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getAccessCounts",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_clearAndCompactLocalStore<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.clearAndCompactLocalStore(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::ClearAndCompactLocalStoreExn::Success(res)
                }
                Err(crate::services::eden_service::ClearAndCompactLocalStoreExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::ClearAndCompactLocalStoreExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "clearAndCompactLocalStore",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "clearAndCompactLocalStore",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_debugClearLocalStoreCaches<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugClearLocalStoreCaches(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::DebugClearLocalStoreCachesExn::Success(res)
                }
                Err(crate::services::eden_service::DebugClearLocalStoreCachesExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::DebugClearLocalStoreCachesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugClearLocalStoreCaches",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "debugClearLocalStoreCaches",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_debugCompactLocalStorage<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugCompactLocalStorage(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::DebugCompactLocalStorageExn::Success(res)
                }
                Err(crate::services::eden_service::DebugCompactLocalStorageExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::DebugCompactLocalStorageExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugCompactLocalStorage",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "debugCompactLocalStorage",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_unloadInodeForPath<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_path = None;
            let mut field_age = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_path = Some(Deserialize::read(p)?),
                    (TType::Struct, 3) => field_age = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.unloadInodeForPath(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "unloadInodeForPath",
                        "mountPoint",
                    )
                })?,
                field_path.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "unloadInodeForPath",
                        "path",
                    )
                })?,
                field_age.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "unloadInodeForPath",
                        "age",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::UnloadInodeForPathExn::Success(res)
                }
                Err(crate::services::eden_service::UnloadInodeForPathExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::UnloadInodeForPathExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "unloadInodeForPath",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "unloadInodeForPath",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_flushStatsNow<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.flushStatsNow(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::FlushStatsNowExn::Success(res)
                }
                Err(crate::services::eden_service::FlushStatsNowExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::FlushStatsNowExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "flushStatsNow",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "flushStatsNow",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_invalidateKernelInodeCache<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_mountPoint = None;
            let mut field_path = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_mountPoint = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_path = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.invalidateKernelInodeCache(
                field_mountPoint.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "invalidateKernelInodeCache",
                        "mountPoint",
                    )
                })?,
                field_path.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "invalidateKernelInodeCache",
                        "path",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::InvalidateKernelInodeCacheExn::Success(res)
                }
                Err(crate::services::eden_service::InvalidateKernelInodeCacheExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::InvalidateKernelInodeCacheExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "invalidateKernelInodeCache",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "invalidateKernelInodeCache",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getStatInfo<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getStatInfo(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GetStatInfoExn::Success(res)
                }
                Err(crate::services::eden_service::GetStatInfoExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GetStatInfoExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getStatInfo",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getStatInfo",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_enableTracing<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.enableTracing(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::EnableTracingExn::Success(res)
                }
                Err(crate::services::eden_service::EnableTracingExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::EnableTracingExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "enableTracing",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "enableTracing",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_disableTracing<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.disableTracing(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::DisableTracingExn::Success(res)
                }
                Err(crate::services::eden_service::DisableTracingExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::DisableTracingExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "disableTracing",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "disableTracing",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getTracePoints<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getTracePoints(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::GetTracePointsExn::Success(res)
                }
                Err(crate::services::eden_service::GetTracePointsExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::GetTracePointsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getTracePoints",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getTracePoints",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_injectFault<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_fault = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Struct, 1) => field_fault = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.injectFault(
                field_fault.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "injectFault",
                        "fault",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::InjectFaultExn::Success(res)
                }
                Err(crate::services::eden_service::InjectFaultExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::InjectFaultExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "injectFault",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "injectFault",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_removeFault<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_fault = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Struct, 1) => field_fault = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.removeFault(
                field_fault.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "removeFault",
                        "fault",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::RemoveFaultExn::Success(res)
                }
                Err(crate::services::eden_service::RemoveFaultExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::RemoveFaultExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removeFault",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "removeFault",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_unblockFault<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_info = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Struct, 1) => field_info = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.unblockFault(
                field_info.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "unblockFault",
                        "info",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::eden_service::UnblockFaultExn::Success(res)
                }
                Err(crate::services::eden_service::UnblockFaultExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::eden_service::UnblockFaultExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "unblockFault",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "unblockFault",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }
    }

    #[async_trait]
    impl<P, H, R, SS> fbthrift::ServiceProcessor<P> for EdenServiceProcessor<P, H, R, SS>
    where
        P: Protocol + Send + Sync + 'static,
        P::Deserializer: Send,
        H: EdenService,
        SS: ThriftService<P::Frame>,
        SS::Handler: fb303_core::server::BaseService,
        P::Frame: Send + 'static,
        R: Send + Sync + 'static,
    {
        type RequestContext = R;

        #[inline]
        fn method_idx(&self, name: &[u8]) -> Result<usize, ApplicationException> {
            match name {
                b"listMounts" => Ok(0usize),
                b"mount" => Ok(1usize),
                b"unmount" => Ok(2usize),
                b"checkOutRevision" => Ok(3usize),
                b"resetParentCommits" => Ok(4usize),
                b"getSHA1" => Ok(5usize),
                b"getBindMounts" => Ok(6usize),
                b"addBindMount" => Ok(7usize),
                b"removeBindMount" => Ok(8usize),
                b"getCurrentJournalPosition" => Ok(9usize),
                b"getFilesChangedSince" => Ok(10usize),
                b"setJournalMemoryLimit" => Ok(11usize),
                b"getJournalMemoryLimit" => Ok(12usize),
                b"flushJournal" => Ok(13usize),
                b"debugGetRawJournal" => Ok(14usize),
                b"getFileInformation" => Ok(15usize),
                b"glob" => Ok(16usize),
                b"globFiles" => Ok(17usize),
                b"chown" => Ok(18usize),
                b"getScmStatusV2" => Ok(19usize),
                b"getScmStatus" => Ok(20usize),
                b"getScmStatusBetweenRevisions" => Ok(21usize),
                b"getManifestEntry" => Ok(22usize),
                b"getDaemonInfo" => Ok(23usize),
                b"getPid" => Ok(24usize),
                b"initiateShutdown" => Ok(25usize),
                b"getConfig" => Ok(26usize),
                b"reloadConfig" => Ok(27usize),
                b"debugGetScmTree" => Ok(28usize),
                b"debugGetScmBlob" => Ok(29usize),
                b"debugGetScmBlobMetadata" => Ok(30usize),
                b"debugInodeStatus" => Ok(31usize),
                b"debugOutstandingFuseCalls" => Ok(32usize),
                b"debugGetInodePath" => Ok(33usize),
                b"debugSetLogLevel" => Ok(34usize),
                b"getAccessCounts" => Ok(35usize),
                b"clearAndCompactLocalStore" => Ok(36usize),
                b"debugClearLocalStoreCaches" => Ok(37usize),
                b"debugCompactLocalStorage" => Ok(38usize),
                b"unloadInodeForPath" => Ok(39usize),
                b"flushStatsNow" => Ok(40usize),
                b"invalidateKernelInodeCache" => Ok(41usize),
                b"getStatInfo" => Ok(42usize),
                b"enableTracing" => Ok(43usize),
                b"disableTracing" => Ok(44usize),
                b"getTracePoints" => Ok(45usize),
                b"injectFault" => Ok(46usize),
                b"removeFault" => Ok(47usize),
                b"unblockFault" => Ok(48usize),
                _ => Err(ApplicationException::unknown_method()),
            }
        }

        async fn handle_method(
            &self,
            idx: usize,
            p: &mut P::Deserializer,
            r: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            match idx {
                0usize => self.handle_listMounts(p, r, seqid).await,
                1usize => self.handle_mount(p, r, seqid).await,
                2usize => self.handle_unmount(p, r, seqid).await,
                3usize => self.handle_checkOutRevision(p, r, seqid).await,
                4usize => self.handle_resetParentCommits(p, r, seqid).await,
                5usize => self.handle_getSHA1(p, r, seqid).await,
                6usize => self.handle_getBindMounts(p, r, seqid).await,
                7usize => self.handle_addBindMount(p, r, seqid).await,
                8usize => self.handle_removeBindMount(p, r, seqid).await,
                9usize => self.handle_getCurrentJournalPosition(p, r, seqid).await,
                10usize => self.handle_getFilesChangedSince(p, r, seqid).await,
                11usize => self.handle_setJournalMemoryLimit(p, r, seqid).await,
                12usize => self.handle_getJournalMemoryLimit(p, r, seqid).await,
                13usize => self.handle_flushJournal(p, r, seqid).await,
                14usize => self.handle_debugGetRawJournal(p, r, seqid).await,
                15usize => self.handle_getFileInformation(p, r, seqid).await,
                16usize => self.handle_glob(p, r, seqid).await,
                17usize => self.handle_globFiles(p, r, seqid).await,
                18usize => self.handle_chown(p, r, seqid).await,
                19usize => self.handle_getScmStatusV2(p, r, seqid).await,
                20usize => self.handle_getScmStatus(p, r, seqid).await,
                21usize => self.handle_getScmStatusBetweenRevisions(p, r, seqid).await,
                22usize => self.handle_getManifestEntry(p, r, seqid).await,
                23usize => self.handle_getDaemonInfo(p, r, seqid).await,
                24usize => self.handle_getPid(p, r, seqid).await,
                25usize => self.handle_initiateShutdown(p, r, seqid).await,
                26usize => self.handle_getConfig(p, r, seqid).await,
                27usize => self.handle_reloadConfig(p, r, seqid).await,
                28usize => self.handle_debugGetScmTree(p, r, seqid).await,
                29usize => self.handle_debugGetScmBlob(p, r, seqid).await,
                30usize => self.handle_debugGetScmBlobMetadata(p, r, seqid).await,
                31usize => self.handle_debugInodeStatus(p, r, seqid).await,
                32usize => self.handle_debugOutstandingFuseCalls(p, r, seqid).await,
                33usize => self.handle_debugGetInodePath(p, r, seqid).await,
                34usize => self.handle_debugSetLogLevel(p, r, seqid).await,
                35usize => self.handle_getAccessCounts(p, r, seqid).await,
                36usize => self.handle_clearAndCompactLocalStore(p, r, seqid).await,
                37usize => self.handle_debugClearLocalStoreCaches(p, r, seqid).await,
                38usize => self.handle_debugCompactLocalStorage(p, r, seqid).await,
                39usize => self.handle_unloadInodeForPath(p, r, seqid).await,
                40usize => self.handle_flushStatsNow(p, r, seqid).await,
                41usize => self.handle_invalidateKernelInodeCache(p, r, seqid).await,
                42usize => self.handle_getStatInfo(p, r, seqid).await,
                43usize => self.handle_enableTracing(p, r, seqid).await,
                44usize => self.handle_disableTracing(p, r, seqid).await,
                45usize => self.handle_getTracePoints(p, r, seqid).await,
                46usize => self.handle_injectFault(p, r, seqid).await,
                47usize => self.handle_removeFault(p, r, seqid).await,
                48usize => self.handle_unblockFault(p, r, seqid).await,
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "EdenServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[async_trait]
    impl<P, H, R, SS> ThriftService<P::Frame> for EdenServiceProcessor<P, H, R, SS>
    where
        P: Protocol + Send + Sync + 'static,
        P::Deserializer: Send,
        P::Frame: Send + 'static,
        H: EdenService,
        SS: ThriftService<P::Frame, RequestContext = R>,
        SS::Handler: fb303_core::server::BaseService,
        P::Frame: Send + 'static,
        R: Send + Sync + 'static,
    {
        type Handler = H;
        type RequestContext = R;

        async fn call(
            &self,
            req: ProtocolDecoded<P>,
            req_ctxt: &R,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != MessageType::Call {
                return Err(From::from(ApplicationException::new(
                    ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                Ok(idx) => idx,
                Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt).await;
                }
            };
            let res = self.handle_method(idx, &mut p, req_ctxt, seqid).await;
            p.read_message_end()?;
            match res {
                Ok(bytes) => Ok(bytes),
                Err(err) => match err.downcast_ref::<fbthrift::ProtocolError>() {
                    Some(fbthrift::ProtocolError::ApplicationException(ae)) => {
                        let res = serialize!(P, |p| {
                            fbthrift::protocol::write_message(
                                p,
                                "EdenServiceProcessor",
                                MessageType::Exception,
                                seqid,
                                |p| ae.write(p),
                            )
                        });
                        Ok(res)
                    }
                    _ => Err(err),
                },
            }
        }
    }

    pub fn make_EdenService_server<F, H, R, SMAKE, SS>(
        proto: ProtocolID,
        handler: H,
        supa: SMAKE,
    ) -> Result<Box<dyn ThriftService<F, Handler = H, RequestContext = R> + Send + 'static>, ApplicationException>
    where
        F: Framing + Send + Sync + 'static,
        H: EdenService,
        SMAKE: Fn(ProtocolID) -> Result<SS, ApplicationException>,
        SS: ThriftService<F, RequestContext = R>,
        SS::Handler: fb303_core::server::BaseService,
        R: Send + Sync + 'static,
    {
        match proto {
            ProtocolID::BinaryProtocol => {
                Ok(Box::new(EdenServiceProcessor::<BinaryProtocol<F>, H, R, SS>::new(handler, supa(proto)?)))
            }
            ProtocolID::CompactProtocol => {
                Ok(Box::new(EdenServiceProcessor::<CompactProtocol<F>, H, R, SS>::new(handler, supa(proto)?)))
            }
            bad => Err(ApplicationException::invalid_protocol(bad)),
        }
    }
}

/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
///     service MyService {
///         FunctionResponse myFunction(
///             1: FunctionRequest request,
///         ) throws {
///             1: StorageException s,
///             2: NotFoundException n,
///         ),
///
///         // other functions
///     }
///
///
/// we would end up with this mock object under crate::mock::MyService:
///
///     impl crate::client::MyService for MyService<'mock> {...}
///
///     pub struct MyService<'mock> {
///         pub myFunction: myFunction<'mock>,
///         // ...
///     }
///
///     impl dyn crate::client::MyService {
///         pub fn mock<'mock>() -> MyService<'mock>;
///     }
///
///     impl myFunction<'mock> {
///         // directly return the given success response
///         pub fn ret(&self, value: FunctionResponse);
///
///         // invoke closure to compute success response
///         pub fn mock(
///             &self,
///             mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///         );
///
///         // return one of the function's declared exceptions
///         pub fn throw<E>(&self, exception: E)
///         where
///             E: Clone + Into<crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
///     }
///
///     impl From<StorageException> for MyFunctionExn {...}
///     impl From<NotFoundException> for MyFunctionExn {...}
///
///
/// The intended usage from a test would be:
///
///     use std::sync::Arc;
///     use thrift_if::client::MyService;
///
///     #[test]
///     fn test_my_client() {
///         let mock = Arc::new(MyService::mock());
///
///         // directly return a success response
///         let resp = FunctionResponse {...};
///         mock.myFunction.ret(resp);
///
///         // or give a closure to compute the success response
///         mock.myFunction.mock(|request| FunctionResponse {...});
///
///         // or throw one of the function's exceptions
///         mock.myFunction.throw(StorageException::ItFailed);
///
///         let out = do_the_thing(mock).wait().unwrap();
///         assert!(out.what_i_expected());
///     }
///
///     fn do_the_thing(
///         client: Arc<dyn MyService + Send + Sync + 'static>,
///     ) -> impl Future<Item = Out> {...}
pub mod mock {
    use async_trait::async_trait;
    use std::marker::PhantomData;

    pub struct EdenService<'mock> {
        pub listMounts: eden_service::listMounts<'mock>,
        pub mount: eden_service::mount<'mock>,
        pub unmount: eden_service::unmount<'mock>,
        pub checkOutRevision: eden_service::checkOutRevision<'mock>,
        pub resetParentCommits: eden_service::resetParentCommits<'mock>,
        pub getSHA1: eden_service::getSHA1<'mock>,
        pub getBindMounts: eden_service::getBindMounts<'mock>,
        pub addBindMount: eden_service::addBindMount<'mock>,
        pub removeBindMount: eden_service::removeBindMount<'mock>,
        pub getCurrentJournalPosition: eden_service::getCurrentJournalPosition<'mock>,
        pub getFilesChangedSince: eden_service::getFilesChangedSince<'mock>,
        pub setJournalMemoryLimit: eden_service::setJournalMemoryLimit<'mock>,
        pub getJournalMemoryLimit: eden_service::getJournalMemoryLimit<'mock>,
        pub flushJournal: eden_service::flushJournal<'mock>,
        pub debugGetRawJournal: eden_service::debugGetRawJournal<'mock>,
        pub getFileInformation: eden_service::getFileInformation<'mock>,
        pub glob: eden_service::glob<'mock>,
        pub globFiles: eden_service::globFiles<'mock>,
        pub chown: eden_service::chown<'mock>,
        pub getScmStatusV2: eden_service::getScmStatusV2<'mock>,
        pub getScmStatus: eden_service::getScmStatus<'mock>,
        pub getScmStatusBetweenRevisions: eden_service::getScmStatusBetweenRevisions<'mock>,
        pub getManifestEntry: eden_service::getManifestEntry<'mock>,
        pub getDaemonInfo: eden_service::getDaemonInfo<'mock>,
        pub getPid: eden_service::getPid<'mock>,
        pub initiateShutdown: eden_service::initiateShutdown<'mock>,
        pub getConfig: eden_service::getConfig<'mock>,
        pub reloadConfig: eden_service::reloadConfig<'mock>,
        pub debugGetScmTree: eden_service::debugGetScmTree<'mock>,
        pub debugGetScmBlob: eden_service::debugGetScmBlob<'mock>,
        pub debugGetScmBlobMetadata: eden_service::debugGetScmBlobMetadata<'mock>,
        pub debugInodeStatus: eden_service::debugInodeStatus<'mock>,
        pub debugOutstandingFuseCalls: eden_service::debugOutstandingFuseCalls<'mock>,
        pub debugGetInodePath: eden_service::debugGetInodePath<'mock>,
        pub debugSetLogLevel: eden_service::debugSetLogLevel<'mock>,
        pub getAccessCounts: eden_service::getAccessCounts<'mock>,
        pub clearAndCompactLocalStore: eden_service::clearAndCompactLocalStore<'mock>,
        pub debugClearLocalStoreCaches: eden_service::debugClearLocalStoreCaches<'mock>,
        pub debugCompactLocalStorage: eden_service::debugCompactLocalStorage<'mock>,
        pub unloadInodeForPath: eden_service::unloadInodeForPath<'mock>,
        pub flushStatsNow: eden_service::flushStatsNow<'mock>,
        pub invalidateKernelInodeCache: eden_service::invalidateKernelInodeCache<'mock>,
        pub getStatInfo: eden_service::getStatInfo<'mock>,
        pub enableTracing: eden_service::enableTracing<'mock>,
        pub disableTracing: eden_service::disableTracing<'mock>,
        pub getTracePoints: eden_service::getTracePoints<'mock>,
        pub injectFault: eden_service::injectFault<'mock>,
        pub removeFault: eden_service::removeFault<'mock>,
        pub unblockFault: eden_service::unblockFault<'mock>,
        _marker: PhantomData<&'mock ()>,
    }

    impl dyn super::client::EdenService {
        pub fn mock<'mock>() -> EdenService<'mock> {
            EdenService {
                listMounts: eden_service::listMounts::unimplemented(),
                mount: eden_service::mount::unimplemented(),
                unmount: eden_service::unmount::unimplemented(),
                checkOutRevision: eden_service::checkOutRevision::unimplemented(),
                resetParentCommits: eden_service::resetParentCommits::unimplemented(),
                getSHA1: eden_service::getSHA1::unimplemented(),
                getBindMounts: eden_service::getBindMounts::unimplemented(),
                addBindMount: eden_service::addBindMount::unimplemented(),
                removeBindMount: eden_service::removeBindMount::unimplemented(),
                getCurrentJournalPosition: eden_service::getCurrentJournalPosition::unimplemented(),
                getFilesChangedSince: eden_service::getFilesChangedSince::unimplemented(),
                setJournalMemoryLimit: eden_service::setJournalMemoryLimit::unimplemented(),
                getJournalMemoryLimit: eden_service::getJournalMemoryLimit::unimplemented(),
                flushJournal: eden_service::flushJournal::unimplemented(),
                debugGetRawJournal: eden_service::debugGetRawJournal::unimplemented(),
                getFileInformation: eden_service::getFileInformation::unimplemented(),
                glob: eden_service::glob::unimplemented(),
                globFiles: eden_service::globFiles::unimplemented(),
                chown: eden_service::chown::unimplemented(),
                getScmStatusV2: eden_service::getScmStatusV2::unimplemented(),
                getScmStatus: eden_service::getScmStatus::unimplemented(),
                getScmStatusBetweenRevisions: eden_service::getScmStatusBetweenRevisions::unimplemented(),
                getManifestEntry: eden_service::getManifestEntry::unimplemented(),
                getDaemonInfo: eden_service::getDaemonInfo::unimplemented(),
                getPid: eden_service::getPid::unimplemented(),
                initiateShutdown: eden_service::initiateShutdown::unimplemented(),
                getConfig: eden_service::getConfig::unimplemented(),
                reloadConfig: eden_service::reloadConfig::unimplemented(),
                debugGetScmTree: eden_service::debugGetScmTree::unimplemented(),
                debugGetScmBlob: eden_service::debugGetScmBlob::unimplemented(),
                debugGetScmBlobMetadata: eden_service::debugGetScmBlobMetadata::unimplemented(),
                debugInodeStatus: eden_service::debugInodeStatus::unimplemented(),
                debugOutstandingFuseCalls: eden_service::debugOutstandingFuseCalls::unimplemented(),
                debugGetInodePath: eden_service::debugGetInodePath::unimplemented(),
                debugSetLogLevel: eden_service::debugSetLogLevel::unimplemented(),
                getAccessCounts: eden_service::getAccessCounts::unimplemented(),
                clearAndCompactLocalStore: eden_service::clearAndCompactLocalStore::unimplemented(),
                debugClearLocalStoreCaches: eden_service::debugClearLocalStoreCaches::unimplemented(),
                debugCompactLocalStorage: eden_service::debugCompactLocalStorage::unimplemented(),
                unloadInodeForPath: eden_service::unloadInodeForPath::unimplemented(),
                flushStatsNow: eden_service::flushStatsNow::unimplemented(),
                invalidateKernelInodeCache: eden_service::invalidateKernelInodeCache::unimplemented(),
                getStatInfo: eden_service::getStatInfo::unimplemented(),
                enableTracing: eden_service::enableTracing::unimplemented(),
                disableTracing: eden_service::disableTracing::unimplemented(),
                getTracePoints: eden_service::getTracePoints::unimplemented(),
                injectFault: eden_service::injectFault::unimplemented(),
                removeFault: eden_service::removeFault::unimplemented(),
                unblockFault: eden_service::unblockFault::unimplemented(),
                _marker: PhantomData,
            }
        }
    }

    #[async_trait]
    impl<'mock> super::client::EdenService for EdenService<'mock> {
        fn listMounts(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::MountInfo>>> + Send + 'static>> {
            let mut closure = self.listMounts.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceListMountsError(error),
                ))))
        }
        fn mount(
            &self,
            arg_info: &crate::types::MountArgument,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.mount.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::MountArgument) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_info.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceMountError(error),
                ))))
        }
        fn unmount(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.unmount.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceUnmountError(error),
                ))))
        }
        fn checkOutRevision(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_snapshotHash: &crate::types::BinaryHash,
            arg_checkoutMode: &crate::types::CheckoutMode,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::CheckoutConflict>>> + Send + 'static>> {
            let mut closure = self.checkOutRevision.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, crate::types::BinaryHash, crate::types::CheckoutMode) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_snapshotHash.clone(), arg_checkoutMode.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceCheckOutRevisionError(error),
                ))))
        }
        fn resetParentCommits(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_parents: &crate::types::WorkingDirectoryParents,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.resetParentCommits.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, crate::types::WorkingDirectoryParents) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_parents.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceResetParentCommitsError(error),
                ))))
        }
        fn getSHA1(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &Vec<crate::types::PathString>,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::SHA1Result>>> + Send + 'static>> {
            let mut closure = self.getSHA1.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, Vec<crate::types::PathString>) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_paths.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGetSHA1Error(error),
                ))))
        }
        fn getBindMounts(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::PathString>>> + Send + 'static>> {
            let mut closure = self.getBindMounts.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGetBindMountsError(error),
                ))))
        }
        fn addBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
            arg_targetPath: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.addBindMount.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, crate::types::PathString, crate::types::PathString) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_repoPath.clone(), arg_targetPath.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceAddBindMountError(error),
                ))))
        }
        fn removeBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.removeBindMount.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, crate::types::PathString) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_repoPath.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceRemoveBindMountError(error),
                ))))
        }
        fn getCurrentJournalPosition(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::JournalPosition>> + Send + 'static>> {
            let mut closure = self.getCurrentJournalPosition.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGetCurrentJournalPositionError(error),
                ))))
        }
        fn getFilesChangedSince(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_fromPosition: &crate::types::JournalPosition,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::FileDelta>> + Send + 'static>> {
            let mut closure = self.getFilesChangedSince.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, crate::types::JournalPosition) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_fromPosition.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGetFilesChangedSinceError(error),
                ))))
        }
        fn setJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_limit: i64,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.setJournalMemoryLimit.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, i64) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_limit.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceSetJournalMemoryLimitError(error),
                ))))
        }
        fn getJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>> {
            let mut closure = self.getJournalMemoryLimit.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGetJournalMemoryLimitError(error),
                ))))
        }
        fn flushJournal(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.flushJournal.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceFlushJournalError(error),
                ))))
        }
        fn debugGetRawJournal(
            &self,
            arg_params: &crate::types::DebugGetRawJournalParams,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::DebugGetRawJournalResponse>> + Send + 'static>> {
            let mut closure = self.debugGetRawJournal.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::DebugGetRawJournalParams) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_params.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceDebugGetRawJournalError(error),
                ))))
        }
        fn getFileInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &Vec<crate::types::PathString>,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::FileInformationOrError>>> + Send + 'static>> {
            let mut closure = self.getFileInformation.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, Vec<crate::types::PathString>) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_paths.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGetFileInformationError(error),
                ))))
        }
        fn glob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_globs: &Vec<String>,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::PathString>>> + Send + 'static>> {
            let mut closure = self.glob.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, Vec<String>) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_globs.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGlobError(error),
                ))))
        }
        fn globFiles(
            &self,
            arg_params: &crate::types::GlobParams,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::Glob>> + Send + 'static>> {
            let mut closure = self.globFiles.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::GlobParams) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_params.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGlobFilesError(error),
                ))))
        }
        fn chown(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_uid: i32,
            arg_gid: i32,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.chown.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, i32, i32) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_uid.clone(), arg_gid.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceChownError(error),
                ))))
        }
        fn getScmStatusV2(
            &self,
            arg_params: &crate::types::GetScmStatusParams,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::GetScmStatusResult>> + Send + 'static>> {
            let mut closure = self.getScmStatusV2.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::GetScmStatusParams) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_params.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGetScmStatusV2Error(error),
                ))))
        }
        fn getScmStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_listIgnored: bool,
            arg_commit: &crate::types::BinaryHash,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::ScmStatus>> + Send + 'static>> {
            let mut closure = self.getScmStatus.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, bool, crate::types::BinaryHash) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_listIgnored.clone(), arg_commit.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGetScmStatusError(error),
                ))))
        }
        fn getScmStatusBetweenRevisions(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_oldHash: &crate::types::BinaryHash,
            arg_newHash: &crate::types::BinaryHash,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::ScmStatus>> + Send + 'static>> {
            let mut closure = self.getScmStatusBetweenRevisions.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, crate::types::BinaryHash, crate::types::BinaryHash) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_oldHash.clone(), arg_newHash.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGetScmStatusBetweenRevisionsError(error),
                ))))
        }
        fn getManifestEntry(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_relativePath: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::ManifestEntry>> + Send + 'static>> {
            let mut closure = self.getManifestEntry.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, crate::types::PathString) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_relativePath.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGetManifestEntryError(error),
                ))))
        }
        fn getDaemonInfo(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::DaemonInfo>> + Send + 'static>> {
            let mut closure = self.getDaemonInfo.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGetDaemonInfoError(error),
                ))))
        }
        fn getPid(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>> {
            let mut closure = self.getPid.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGetPidError(error),
                ))))
        }
        fn initiateShutdown(
            &self,
            arg_reason: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.initiateShutdown.closure.lock().unwrap();
            let closure: &mut dyn FnMut(String) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_reason.to_owned())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceInitiateShutdownError(error),
                ))))
        }
        fn getConfig(
            &self,
            arg_params: &crate::types::GetConfigParams,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<eden_config::types::EdenConfigData>> + Send + 'static>> {
            let mut closure = self.getConfig.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::GetConfigParams) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_params.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGetConfigError(error),
                ))))
        }
        fn reloadConfig(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.reloadConfig.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceReloadConfigError(error),
                ))))
        }
        fn debugGetScmTree(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: bool,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::ScmTreeEntry>>> + Send + 'static>> {
            let mut closure = self.debugGetScmTree.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, crate::types::BinaryHash, bool) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_id.clone(), arg_localStoreOnly.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceDebugGetScmTreeError(error),
                ))))
        }
        fn debugGetScmBlob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: bool,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<u8>>> + Send + 'static>> {
            let mut closure = self.debugGetScmBlob.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, crate::types::BinaryHash, bool) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_id.clone(), arg_localStoreOnly.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceDebugGetScmBlobError(error),
                ))))
        }
        fn debugGetScmBlobMetadata(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: bool,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::ScmBlobMetadata>> + Send + 'static>> {
            let mut closure = self.debugGetScmBlobMetadata.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, crate::types::BinaryHash, bool) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_id.clone(), arg_localStoreOnly.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceDebugGetScmBlobMetadataError(error),
                ))))
        }
        fn debugInodeStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::TreeInodeDebugInfo>>> + Send + 'static>> {
            let mut closure = self.debugInodeStatus.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, crate::types::PathString) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_path.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceDebugInodeStatusError(error),
                ))))
        }
        fn debugOutstandingFuseCalls(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::FuseCall>>> + Send + 'static>> {
            let mut closure = self.debugOutstandingFuseCalls.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceDebugOutstandingFuseCallsError(error),
                ))))
        }
        fn debugGetInodePath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_inodeNumber: i64,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::InodePathDebugInfo>> + Send + 'static>> {
            let mut closure = self.debugGetInodePath.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, i64) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_inodeNumber.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceDebugGetInodePathError(error),
                ))))
        }
        fn debugSetLogLevel(
            &self,
            arg_category: &str,
            arg_level: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::SetLogLevelResult>> + Send + 'static>> {
            let mut closure = self.debugSetLogLevel.closure.lock().unwrap();
            let closure: &mut dyn FnMut(String, String) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_category.to_owned(), arg_level.to_owned())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceDebugSetLogLevelError(error),
                ))))
        }
        fn getAccessCounts(
            &self,
            arg_duration: i64,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::GetAccessCountsResult>> + Send + 'static>> {
            let mut closure = self.getAccessCounts.closure.lock().unwrap();
            let closure: &mut dyn FnMut(i64) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_duration.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGetAccessCountsError(error),
                ))))
        }
        fn clearAndCompactLocalStore(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.clearAndCompactLocalStore.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceClearAndCompactLocalStoreError(error),
                ))))
        }
        fn debugClearLocalStoreCaches(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.debugClearLocalStoreCaches.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceDebugClearLocalStoreCachesError(error),
                ))))
        }
        fn debugCompactLocalStorage(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.debugCompactLocalStorage.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceDebugCompactLocalStorageError(error),
                ))))
        }
        fn unloadInodeForPath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
            arg_age: &crate::types::TimeSpec,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>> {
            let mut closure = self.unloadInodeForPath.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, crate::types::PathString, crate::types::TimeSpec) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_path.clone(), arg_age.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceUnloadInodeForPathError(error),
                ))))
        }
        fn flushStatsNow(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.flushStatsNow.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceFlushStatsNowError(error),
                ))))
        }
        fn invalidateKernelInodeCache(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.invalidateKernelInodeCache.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::PathString, crate::types::PathString) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_mountPoint.clone(), arg_path.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceInvalidateKernelInodeCacheError(error),
                ))))
        }
        fn getStatInfo(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::InternalStats>> + Send + 'static>> {
            let mut closure = self.getStatInfo.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGetStatInfoError(error),
                ))))
        }
        fn enableTracing(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.enableTracing.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceEnableTracingError(error),
                ))))
        }
        fn disableTracing(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.disableTracing.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceDisableTracingError(error),
                ))))
        }
        fn getTracePoints(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<Vec<crate::types::TracePoint>>> + Send + 'static>> {
            let mut closure = self.getTracePoints.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceGetTracePointsError(error),
                ))))
        }
        fn injectFault(
            &self,
            arg_fault: &crate::types::FaultDefinition,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.injectFault.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::FaultDefinition) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_fault.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceInjectFaultError(error),
                ))))
        }
        fn removeFault(
            &self,
            arg_fault: &crate::types::RemoveFaultArg,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<bool>> + Send + 'static>> {
            let mut closure = self.removeFault.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::RemoveFaultArg) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_fault.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceRemoveFaultError(error),
                ))))
        }
        fn unblockFault(
            &self,
            arg_info: &crate::types::UnblockFaultArg,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>> {
            let mut closure = self.unblockFault.closure.lock().unwrap();
            let closure: &mut dyn FnMut(crate::types::UnblockFaultArg) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_info.clone())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::EdenServiceUnblockFaultError(error),
                ))))
        }
    }

    mod eden_service {
        use std::sync::Mutex;

        pub struct listMounts<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    Vec<crate::types::MountInfo>,
                    crate::services::eden_service::ListMountsExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> listMounts<'mock> {
            pub fn unimplemented() -> Self {
                listMounts {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "listMounts",
                    ))),
                }
            }

            pub fn ret(&self, value: Vec<crate::types::MountInfo>) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> Vec<crate::types::MountInfo> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::ListMountsExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct mount<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::MountArgument) -> Result<
                    (),
                    crate::services::eden_service::MountExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> mount<'mock> {
            pub fn unimplemented() -> Self {
                mount {
                    closure: Mutex::new(Box::new(|_: crate::types::MountArgument| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "mount",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move |_: crate::types::MountArgument| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::MountArgument) -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |info| Ok(mock(info)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::MountExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::MountArgument| Err(exception.clone().into()));
            }
        }

        pub struct unmount<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString) -> Result<
                    (),
                    crate::services::eden_service::UnmountExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> unmount<'mock> {
            pub fn unimplemented() -> Self {
                unmount {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "unmount",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move |_: crate::types::PathString| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString) -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint| Ok(mock(mountPoint)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::UnmountExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString| Err(exception.clone().into()));
            }
        }

        pub struct checkOutRevision<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, crate::types::BinaryHash, crate::types::CheckoutMode) -> Result<
                    Vec<crate::types::CheckoutConflict>,
                    crate::services::eden_service::CheckOutRevisionExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> checkOutRevision<'mock> {
            pub fn unimplemented() -> Self {
                checkOutRevision {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: crate::types::BinaryHash, _: crate::types::CheckoutMode| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "checkOutRevision",
                    ))),
                }
            }

            pub fn ret(&self, value: Vec<crate::types::CheckoutConflict>) {
                self.mock(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: crate::types::CheckoutMode| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, crate::types::BinaryHash, crate::types::CheckoutMode) -> Vec<crate::types::CheckoutConflict> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, snapshotHash, checkoutMode| Ok(mock(mountPoint, snapshotHash, checkoutMode)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::CheckOutRevisionExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: crate::types::CheckoutMode| Err(exception.clone().into()));
            }
        }

        pub struct resetParentCommits<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, crate::types::WorkingDirectoryParents) -> Result<
                    (),
                    crate::services::eden_service::ResetParentCommitsExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> resetParentCommits<'mock> {
            pub fn unimplemented() -> Self {
                resetParentCommits {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: crate::types::WorkingDirectoryParents| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "resetParentCommits",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move |_: crate::types::PathString, _: crate::types::WorkingDirectoryParents| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, crate::types::WorkingDirectoryParents) -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, parents| Ok(mock(mountPoint, parents)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::ResetParentCommitsExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: crate::types::WorkingDirectoryParents| Err(exception.clone().into()));
            }
        }

        pub struct getSHA1<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, Vec<crate::types::PathString>) -> Result<
                    Vec<crate::types::SHA1Result>,
                    crate::services::eden_service::GetSHA1Exn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getSHA1<'mock> {
            pub fn unimplemented() -> Self {
                getSHA1 {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: Vec<crate::types::PathString>| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "getSHA1",
                    ))),
                }
            }

            pub fn ret(&self, value: Vec<crate::types::SHA1Result>) {
                self.mock(move |_: crate::types::PathString, _: Vec<crate::types::PathString>| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, Vec<crate::types::PathString>) -> Vec<crate::types::SHA1Result> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, paths| Ok(mock(mountPoint, paths)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GetSHA1Exn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: Vec<crate::types::PathString>| Err(exception.clone().into()));
            }
        }

        pub struct getBindMounts<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString) -> Result<
                    Vec<crate::types::PathString>,
                    crate::services::eden_service::GetBindMountsExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getBindMounts<'mock> {
            pub fn unimplemented() -> Self {
                getBindMounts {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "getBindMounts",
                    ))),
                }
            }

            pub fn ret(&self, value: Vec<crate::types::PathString>) {
                self.mock(move |_: crate::types::PathString| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString) -> Vec<crate::types::PathString> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint| Ok(mock(mountPoint)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GetBindMountsExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString| Err(exception.clone().into()));
            }
        }

        pub struct addBindMount<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, crate::types::PathString, crate::types::PathString) -> Result<
                    (),
                    crate::services::eden_service::AddBindMountExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> addBindMount<'mock> {
            pub fn unimplemented() -> Self {
                addBindMount {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: crate::types::PathString, _: crate::types::PathString| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "addBindMount",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move |_: crate::types::PathString, _: crate::types::PathString, _: crate::types::PathString| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, crate::types::PathString, crate::types::PathString) -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, repoPath, targetPath| Ok(mock(mountPoint, repoPath, targetPath)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::AddBindMountExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: crate::types::PathString, _: crate::types::PathString| Err(exception.clone().into()));
            }
        }

        pub struct removeBindMount<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, crate::types::PathString) -> Result<
                    (),
                    crate::services::eden_service::RemoveBindMountExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> removeBindMount<'mock> {
            pub fn unimplemented() -> Self {
                removeBindMount {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: crate::types::PathString| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "removeBindMount",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move |_: crate::types::PathString, _: crate::types::PathString| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, crate::types::PathString) -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, repoPath| Ok(mock(mountPoint, repoPath)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::RemoveBindMountExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: crate::types::PathString| Err(exception.clone().into()));
            }
        }

        pub struct getCurrentJournalPosition<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString) -> Result<
                    crate::types::JournalPosition,
                    crate::services::eden_service::GetCurrentJournalPositionExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getCurrentJournalPosition<'mock> {
            pub fn unimplemented() -> Self {
                getCurrentJournalPosition {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "getCurrentJournalPosition",
                    ))),
                }
            }

            pub fn ret(&self, value: crate::types::JournalPosition) {
                self.mock(move |_: crate::types::PathString| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString) -> crate::types::JournalPosition + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint| Ok(mock(mountPoint)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GetCurrentJournalPositionExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString| Err(exception.clone().into()));
            }
        }

        pub struct getFilesChangedSince<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, crate::types::JournalPosition) -> Result<
                    crate::types::FileDelta,
                    crate::services::eden_service::GetFilesChangedSinceExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getFilesChangedSince<'mock> {
            pub fn unimplemented() -> Self {
                getFilesChangedSince {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: crate::types::JournalPosition| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "getFilesChangedSince",
                    ))),
                }
            }

            pub fn ret(&self, value: crate::types::FileDelta) {
                self.mock(move |_: crate::types::PathString, _: crate::types::JournalPosition| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, crate::types::JournalPosition) -> crate::types::FileDelta + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, fromPosition| Ok(mock(mountPoint, fromPosition)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GetFilesChangedSinceExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: crate::types::JournalPosition| Err(exception.clone().into()));
            }
        }

        pub struct setJournalMemoryLimit<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, i64) -> Result<
                    (),
                    crate::services::eden_service::SetJournalMemoryLimitExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> setJournalMemoryLimit<'mock> {
            pub fn unimplemented() -> Self {
                setJournalMemoryLimit {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: i64| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "setJournalMemoryLimit",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move |_: crate::types::PathString, _: i64| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, i64) -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, limit| Ok(mock(mountPoint, limit)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::SetJournalMemoryLimitExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: i64| Err(exception.clone().into()));
            }
        }

        pub struct getJournalMemoryLimit<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString) -> Result<
                    i64,
                    crate::services::eden_service::GetJournalMemoryLimitExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getJournalMemoryLimit<'mock> {
            pub fn unimplemented() -> Self {
                getJournalMemoryLimit {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "getJournalMemoryLimit",
                    ))),
                }
            }

            pub fn ret(&self, value: i64) {
                self.mock(move |_: crate::types::PathString| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString) -> i64 + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint| Ok(mock(mountPoint)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GetJournalMemoryLimitExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString| Err(exception.clone().into()));
            }
        }

        pub struct flushJournal<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString) -> Result<
                    (),
                    crate::services::eden_service::FlushJournalExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> flushJournal<'mock> {
            pub fn unimplemented() -> Self {
                flushJournal {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "flushJournal",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move |_: crate::types::PathString| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString) -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint| Ok(mock(mountPoint)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::FlushJournalExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString| Err(exception.clone().into()));
            }
        }

        pub struct debugGetRawJournal<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::DebugGetRawJournalParams) -> Result<
                    crate::types::DebugGetRawJournalResponse,
                    crate::services::eden_service::DebugGetRawJournalExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> debugGetRawJournal<'mock> {
            pub fn unimplemented() -> Self {
                debugGetRawJournal {
                    closure: Mutex::new(Box::new(|_: crate::types::DebugGetRawJournalParams| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "debugGetRawJournal",
                    ))),
                }
            }

            pub fn ret(&self, value: crate::types::DebugGetRawJournalResponse) {
                self.mock(move |_: crate::types::DebugGetRawJournalParams| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::DebugGetRawJournalParams) -> crate::types::DebugGetRawJournalResponse + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |params| Ok(mock(params)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::DebugGetRawJournalExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::DebugGetRawJournalParams| Err(exception.clone().into()));
            }
        }

        pub struct getFileInformation<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, Vec<crate::types::PathString>) -> Result<
                    Vec<crate::types::FileInformationOrError>,
                    crate::services::eden_service::GetFileInformationExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getFileInformation<'mock> {
            pub fn unimplemented() -> Self {
                getFileInformation {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: Vec<crate::types::PathString>| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "getFileInformation",
                    ))),
                }
            }

            pub fn ret(&self, value: Vec<crate::types::FileInformationOrError>) {
                self.mock(move |_: crate::types::PathString, _: Vec<crate::types::PathString>| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, Vec<crate::types::PathString>) -> Vec<crate::types::FileInformationOrError> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, paths| Ok(mock(mountPoint, paths)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GetFileInformationExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: Vec<crate::types::PathString>| Err(exception.clone().into()));
            }
        }

        pub struct glob<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, Vec<String>) -> Result<
                    Vec<crate::types::PathString>,
                    crate::services::eden_service::GlobExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> glob<'mock> {
            pub fn unimplemented() -> Self {
                glob {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: Vec<String>| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "glob",
                    ))),
                }
            }

            pub fn ret(&self, value: Vec<crate::types::PathString>) {
                self.mock(move |_: crate::types::PathString, _: Vec<String>| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, Vec<String>) -> Vec<crate::types::PathString> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, globs| Ok(mock(mountPoint, globs)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GlobExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: Vec<String>| Err(exception.clone().into()));
            }
        }

        pub struct globFiles<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::GlobParams) -> Result<
                    crate::types::Glob,
                    crate::services::eden_service::GlobFilesExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> globFiles<'mock> {
            pub fn unimplemented() -> Self {
                globFiles {
                    closure: Mutex::new(Box::new(|_: crate::types::GlobParams| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "globFiles",
                    ))),
                }
            }

            pub fn ret(&self, value: crate::types::Glob) {
                self.mock(move |_: crate::types::GlobParams| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::GlobParams) -> crate::types::Glob + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |params| Ok(mock(params)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GlobFilesExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::GlobParams| Err(exception.clone().into()));
            }
        }

        pub struct chown<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, i32, i32) -> Result<
                    (),
                    crate::services::eden_service::ChownExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> chown<'mock> {
            pub fn unimplemented() -> Self {
                chown {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: i32, _: i32| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "chown",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move |_: crate::types::PathString, _: i32, _: i32| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, i32, i32) -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, uid, gid| Ok(mock(mountPoint, uid, gid)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::ChownExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: i32, _: i32| Err(exception.clone().into()));
            }
        }

        pub struct getScmStatusV2<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::GetScmStatusParams) -> Result<
                    crate::types::GetScmStatusResult,
                    crate::services::eden_service::GetScmStatusV2Exn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getScmStatusV2<'mock> {
            pub fn unimplemented() -> Self {
                getScmStatusV2 {
                    closure: Mutex::new(Box::new(|_: crate::types::GetScmStatusParams| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "getScmStatusV2",
                    ))),
                }
            }

            pub fn ret(&self, value: crate::types::GetScmStatusResult) {
                self.mock(move |_: crate::types::GetScmStatusParams| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::GetScmStatusParams) -> crate::types::GetScmStatusResult + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |params| Ok(mock(params)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GetScmStatusV2Exn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::GetScmStatusParams| Err(exception.clone().into()));
            }
        }

        pub struct getScmStatus<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, bool, crate::types::BinaryHash) -> Result<
                    crate::types::ScmStatus,
                    crate::services::eden_service::GetScmStatusExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getScmStatus<'mock> {
            pub fn unimplemented() -> Self {
                getScmStatus {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: bool, _: crate::types::BinaryHash| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "getScmStatus",
                    ))),
                }
            }

            pub fn ret(&self, value: crate::types::ScmStatus) {
                self.mock(move |_: crate::types::PathString, _: bool, _: crate::types::BinaryHash| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, bool, crate::types::BinaryHash) -> crate::types::ScmStatus + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, listIgnored, commit| Ok(mock(mountPoint, listIgnored, commit)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GetScmStatusExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: bool, _: crate::types::BinaryHash| Err(exception.clone().into()));
            }
        }

        pub struct getScmStatusBetweenRevisions<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, crate::types::BinaryHash, crate::types::BinaryHash) -> Result<
                    crate::types::ScmStatus,
                    crate::services::eden_service::GetScmStatusBetweenRevisionsExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getScmStatusBetweenRevisions<'mock> {
            pub fn unimplemented() -> Self {
                getScmStatusBetweenRevisions {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: crate::types::BinaryHash, _: crate::types::BinaryHash| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "getScmStatusBetweenRevisions",
                    ))),
                }
            }

            pub fn ret(&self, value: crate::types::ScmStatus) {
                self.mock(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: crate::types::BinaryHash| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, crate::types::BinaryHash, crate::types::BinaryHash) -> crate::types::ScmStatus + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, oldHash, newHash| Ok(mock(mountPoint, oldHash, newHash)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GetScmStatusBetweenRevisionsExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: crate::types::BinaryHash| Err(exception.clone().into()));
            }
        }

        pub struct getManifestEntry<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, crate::types::PathString) -> Result<
                    crate::types::ManifestEntry,
                    crate::services::eden_service::GetManifestEntryExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getManifestEntry<'mock> {
            pub fn unimplemented() -> Self {
                getManifestEntry {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: crate::types::PathString| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "getManifestEntry",
                    ))),
                }
            }

            pub fn ret(&self, value: crate::types::ManifestEntry) {
                self.mock(move |_: crate::types::PathString, _: crate::types::PathString| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, crate::types::PathString) -> crate::types::ManifestEntry + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, relativePath| Ok(mock(mountPoint, relativePath)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GetManifestEntryExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: crate::types::PathString| Err(exception.clone().into()));
            }
        }

        pub struct getDaemonInfo<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    crate::types::DaemonInfo,
                    crate::services::eden_service::GetDaemonInfoExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getDaemonInfo<'mock> {
            pub fn unimplemented() -> Self {
                getDaemonInfo {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "getDaemonInfo",
                    ))),
                }
            }

            pub fn ret(&self, value: crate::types::DaemonInfo) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> crate::types::DaemonInfo + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GetDaemonInfoExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct getPid<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    i64,
                    crate::services::eden_service::GetPidExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getPid<'mock> {
            pub fn unimplemented() -> Self {
                getPid {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "getPid",
                    ))),
                }
            }

            pub fn ret(&self, value: i64) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> i64 + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GetPidExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct initiateShutdown<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(String) -> Result<
                    (),
                    crate::services::eden_service::InitiateShutdownExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> initiateShutdown<'mock> {
            pub fn unimplemented() -> Self {
                initiateShutdown {
                    closure: Mutex::new(Box::new(|_: String| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "initiateShutdown",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move |_: String| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(String) -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |reason| Ok(mock(reason)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::InitiateShutdownExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: String| Err(exception.clone().into()));
            }
        }

        pub struct getConfig<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::GetConfigParams) -> Result<
                    eden_config::types::EdenConfigData,
                    crate::services::eden_service::GetConfigExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getConfig<'mock> {
            pub fn unimplemented() -> Self {
                getConfig {
                    closure: Mutex::new(Box::new(|_: crate::types::GetConfigParams| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "getConfig",
                    ))),
                }
            }

            pub fn ret(&self, value: eden_config::types::EdenConfigData) {
                self.mock(move |_: crate::types::GetConfigParams| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::GetConfigParams) -> eden_config::types::EdenConfigData + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |params| Ok(mock(params)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GetConfigExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::GetConfigParams| Err(exception.clone().into()));
            }
        }

        pub struct reloadConfig<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    (),
                    crate::services::eden_service::ReloadConfigExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> reloadConfig<'mock> {
            pub fn unimplemented() -> Self {
                reloadConfig {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "reloadConfig",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::ReloadConfigExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct debugGetScmTree<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, crate::types::BinaryHash, bool) -> Result<
                    Vec<crate::types::ScmTreeEntry>,
                    crate::services::eden_service::DebugGetScmTreeExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> debugGetScmTree<'mock> {
            pub fn unimplemented() -> Self {
                debugGetScmTree {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: crate::types::BinaryHash, _: bool| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "debugGetScmTree",
                    ))),
                }
            }

            pub fn ret(&self, value: Vec<crate::types::ScmTreeEntry>) {
                self.mock(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: bool| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, crate::types::BinaryHash, bool) -> Vec<crate::types::ScmTreeEntry> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, id, localStoreOnly| Ok(mock(mountPoint, id, localStoreOnly)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::DebugGetScmTreeExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: bool| Err(exception.clone().into()));
            }
        }

        pub struct debugGetScmBlob<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, crate::types::BinaryHash, bool) -> Result<
                    Vec<u8>,
                    crate::services::eden_service::DebugGetScmBlobExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> debugGetScmBlob<'mock> {
            pub fn unimplemented() -> Self {
                debugGetScmBlob {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: crate::types::BinaryHash, _: bool| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "debugGetScmBlob",
                    ))),
                }
            }

            pub fn ret(&self, value: Vec<u8>) {
                self.mock(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: bool| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, crate::types::BinaryHash, bool) -> Vec<u8> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, id, localStoreOnly| Ok(mock(mountPoint, id, localStoreOnly)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::DebugGetScmBlobExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: bool| Err(exception.clone().into()));
            }
        }

        pub struct debugGetScmBlobMetadata<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, crate::types::BinaryHash, bool) -> Result<
                    crate::types::ScmBlobMetadata,
                    crate::services::eden_service::DebugGetScmBlobMetadataExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> debugGetScmBlobMetadata<'mock> {
            pub fn unimplemented() -> Self {
                debugGetScmBlobMetadata {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: crate::types::BinaryHash, _: bool| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "debugGetScmBlobMetadata",
                    ))),
                }
            }

            pub fn ret(&self, value: crate::types::ScmBlobMetadata) {
                self.mock(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: bool| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, crate::types::BinaryHash, bool) -> crate::types::ScmBlobMetadata + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, id, localStoreOnly| Ok(mock(mountPoint, id, localStoreOnly)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::DebugGetScmBlobMetadataExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: bool| Err(exception.clone().into()));
            }
        }

        pub struct debugInodeStatus<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, crate::types::PathString) -> Result<
                    Vec<crate::types::TreeInodeDebugInfo>,
                    crate::services::eden_service::DebugInodeStatusExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> debugInodeStatus<'mock> {
            pub fn unimplemented() -> Self {
                debugInodeStatus {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: crate::types::PathString| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "debugInodeStatus",
                    ))),
                }
            }

            pub fn ret(&self, value: Vec<crate::types::TreeInodeDebugInfo>) {
                self.mock(move |_: crate::types::PathString, _: crate::types::PathString| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, crate::types::PathString) -> Vec<crate::types::TreeInodeDebugInfo> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, path| Ok(mock(mountPoint, path)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::DebugInodeStatusExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: crate::types::PathString| Err(exception.clone().into()));
            }
        }

        pub struct debugOutstandingFuseCalls<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString) -> Result<
                    Vec<crate::types::FuseCall>,
                    crate::services::eden_service::DebugOutstandingFuseCallsExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> debugOutstandingFuseCalls<'mock> {
            pub fn unimplemented() -> Self {
                debugOutstandingFuseCalls {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "debugOutstandingFuseCalls",
                    ))),
                }
            }

            pub fn ret(&self, value: Vec<crate::types::FuseCall>) {
                self.mock(move |_: crate::types::PathString| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString) -> Vec<crate::types::FuseCall> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint| Ok(mock(mountPoint)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::DebugOutstandingFuseCallsExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString| Err(exception.clone().into()));
            }
        }

        pub struct debugGetInodePath<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, i64) -> Result<
                    crate::types::InodePathDebugInfo,
                    crate::services::eden_service::DebugGetInodePathExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> debugGetInodePath<'mock> {
            pub fn unimplemented() -> Self {
                debugGetInodePath {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: i64| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "debugGetInodePath",
                    ))),
                }
            }

            pub fn ret(&self, value: crate::types::InodePathDebugInfo) {
                self.mock(move |_: crate::types::PathString, _: i64| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, i64) -> crate::types::InodePathDebugInfo + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, inodeNumber| Ok(mock(mountPoint, inodeNumber)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::DebugGetInodePathExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: i64| Err(exception.clone().into()));
            }
        }

        pub struct debugSetLogLevel<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(String, String) -> Result<
                    crate::types::SetLogLevelResult,
                    crate::services::eden_service::DebugSetLogLevelExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> debugSetLogLevel<'mock> {
            pub fn unimplemented() -> Self {
                debugSetLogLevel {
                    closure: Mutex::new(Box::new(|_: String, _: String| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "debugSetLogLevel",
                    ))),
                }
            }

            pub fn ret(&self, value: crate::types::SetLogLevelResult) {
                self.mock(move |_: String, _: String| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(String, String) -> crate::types::SetLogLevelResult + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |category, level| Ok(mock(category, level)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::DebugSetLogLevelExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: String, _: String| Err(exception.clone().into()));
            }
        }

        pub struct getAccessCounts<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(i64) -> Result<
                    crate::types::GetAccessCountsResult,
                    crate::services::eden_service::GetAccessCountsExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getAccessCounts<'mock> {
            pub fn unimplemented() -> Self {
                getAccessCounts {
                    closure: Mutex::new(Box::new(|_: i64| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "getAccessCounts",
                    ))),
                }
            }

            pub fn ret(&self, value: crate::types::GetAccessCountsResult) {
                self.mock(move |_: i64| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(i64) -> crate::types::GetAccessCountsResult + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |duration| Ok(mock(duration)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GetAccessCountsExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: i64| Err(exception.clone().into()));
            }
        }

        pub struct clearAndCompactLocalStore<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    (),
                    crate::services::eden_service::ClearAndCompactLocalStoreExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> clearAndCompactLocalStore<'mock> {
            pub fn unimplemented() -> Self {
                clearAndCompactLocalStore {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "clearAndCompactLocalStore",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::ClearAndCompactLocalStoreExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct debugClearLocalStoreCaches<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    (),
                    crate::services::eden_service::DebugClearLocalStoreCachesExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> debugClearLocalStoreCaches<'mock> {
            pub fn unimplemented() -> Self {
                debugClearLocalStoreCaches {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "debugClearLocalStoreCaches",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::DebugClearLocalStoreCachesExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct debugCompactLocalStorage<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    (),
                    crate::services::eden_service::DebugCompactLocalStorageExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> debugCompactLocalStorage<'mock> {
            pub fn unimplemented() -> Self {
                debugCompactLocalStorage {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "debugCompactLocalStorage",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::DebugCompactLocalStorageExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct unloadInodeForPath<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, crate::types::PathString, crate::types::TimeSpec) -> Result<
                    i64,
                    crate::services::eden_service::UnloadInodeForPathExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> unloadInodeForPath<'mock> {
            pub fn unimplemented() -> Self {
                unloadInodeForPath {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: crate::types::PathString, _: crate::types::TimeSpec| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "unloadInodeForPath",
                    ))),
                }
            }

            pub fn ret(&self, value: i64) {
                self.mock(move |_: crate::types::PathString, _: crate::types::PathString, _: crate::types::TimeSpec| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, crate::types::PathString, crate::types::TimeSpec) -> i64 + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, path, age| Ok(mock(mountPoint, path, age)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::UnloadInodeForPathExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: crate::types::PathString, _: crate::types::TimeSpec| Err(exception.clone().into()));
            }
        }

        pub struct flushStatsNow<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    (),
                    crate::services::eden_service::FlushStatsNowExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> flushStatsNow<'mock> {
            pub fn unimplemented() -> Self {
                flushStatsNow {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "flushStatsNow",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::FlushStatsNowExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct invalidateKernelInodeCache<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::PathString, crate::types::PathString) -> Result<
                    (),
                    crate::services::eden_service::InvalidateKernelInodeCacheExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> invalidateKernelInodeCache<'mock> {
            pub fn unimplemented() -> Self {
                invalidateKernelInodeCache {
                    closure: Mutex::new(Box::new(|_: crate::types::PathString, _: crate::types::PathString| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "invalidateKernelInodeCache",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move |_: crate::types::PathString, _: crate::types::PathString| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::PathString, crate::types::PathString) -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |mountPoint, path| Ok(mock(mountPoint, path)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::InvalidateKernelInodeCacheExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::PathString, _: crate::types::PathString| Err(exception.clone().into()));
            }
        }

        pub struct getStatInfo<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    crate::types::InternalStats,
                    crate::services::eden_service::GetStatInfoExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getStatInfo<'mock> {
            pub fn unimplemented() -> Self {
                getStatInfo {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "getStatInfo",
                    ))),
                }
            }

            pub fn ret(&self, value: crate::types::InternalStats) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> crate::types::InternalStats + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GetStatInfoExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct enableTracing<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    (),
                    crate::services::eden_service::EnableTracingExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> enableTracing<'mock> {
            pub fn unimplemented() -> Self {
                enableTracing {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "enableTracing",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::EnableTracingExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct disableTracing<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    (),
                    crate::services::eden_service::DisableTracingExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> disableTracing<'mock> {
            pub fn unimplemented() -> Self {
                disableTracing {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "disableTracing",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::DisableTracingExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct getTracePoints<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    Vec<crate::types::TracePoint>,
                    crate::services::eden_service::GetTracePointsExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getTracePoints<'mock> {
            pub fn unimplemented() -> Self {
                getTracePoints {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "getTracePoints",
                    ))),
                }
            }

            pub fn ret(&self, value: Vec<crate::types::TracePoint>) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> Vec<crate::types::TracePoint> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::GetTracePointsExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct injectFault<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::FaultDefinition) -> Result<
                    (),
                    crate::services::eden_service::InjectFaultExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> injectFault<'mock> {
            pub fn unimplemented() -> Self {
                injectFault {
                    closure: Mutex::new(Box::new(|_: crate::types::FaultDefinition| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "injectFault",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move |_: crate::types::FaultDefinition| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::FaultDefinition) -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |fault| Ok(mock(fault)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::InjectFaultExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::FaultDefinition| Err(exception.clone().into()));
            }
        }

        pub struct removeFault<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::RemoveFaultArg) -> Result<
                    bool,
                    crate::services::eden_service::RemoveFaultExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> removeFault<'mock> {
            pub fn unimplemented() -> Self {
                removeFault {
                    closure: Mutex::new(Box::new(|_: crate::types::RemoveFaultArg| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "removeFault",
                    ))),
                }
            }

            pub fn ret(&self, value: bool) {
                self.mock(move |_: crate::types::RemoveFaultArg| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::RemoveFaultArg) -> bool + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |fault| Ok(mock(fault)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::RemoveFaultExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::RemoveFaultArg| Err(exception.clone().into()));
            }
        }

        pub struct unblockFault<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(crate::types::UnblockFaultArg) -> Result<
                    i64,
                    crate::services::eden_service::UnblockFaultExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> unblockFault<'mock> {
            pub fn unimplemented() -> Self {
                unblockFault {
                    closure: Mutex::new(Box::new(|_: crate::types::UnblockFaultArg| panic!(
                        "{}::{} is not mocked",
                        "EdenService",
                        "unblockFault",
                    ))),
                }
            }

            pub fn ret(&self, value: i64) {
                self.mock(move |_: crate::types::UnblockFaultArg| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(crate::types::UnblockFaultArg) -> i64 + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |info| Ok(mock(info)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::eden_service::UnblockFaultExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: crate::types::UnblockFaultArg| Err(exception.clone().into()));
            }
        }
    }
}

pub mod errors {
    use fbthrift::ApplicationException;
    use thiserror::Error;

    #[derive(Debug, Error)]
    pub enum ErrorKind {
        #[error("EdenService::listMounts failed with {0:?}")]
        EdenServiceListMountsError(crate::services::eden_service::ListMountsExn),
        #[error("EdenService::mount failed with {0:?}")]
        EdenServiceMountError(crate::services::eden_service::MountExn),
        #[error("EdenService::unmount failed with {0:?}")]
        EdenServiceUnmountError(crate::services::eden_service::UnmountExn),
        #[error("EdenService::checkOutRevision failed with {0:?}")]
        EdenServiceCheckOutRevisionError(crate::services::eden_service::CheckOutRevisionExn),
        #[error("EdenService::resetParentCommits failed with {0:?}")]
        EdenServiceResetParentCommitsError(crate::services::eden_service::ResetParentCommitsExn),
        #[error("EdenService::getSHA1 failed with {0:?}")]
        EdenServiceGetSHA1Error(crate::services::eden_service::GetSHA1Exn),
        #[error("EdenService::getBindMounts failed with {0:?}")]
        EdenServiceGetBindMountsError(crate::services::eden_service::GetBindMountsExn),
        #[error("EdenService::addBindMount failed with {0:?}")]
        EdenServiceAddBindMountError(crate::services::eden_service::AddBindMountExn),
        #[error("EdenService::removeBindMount failed with {0:?}")]
        EdenServiceRemoveBindMountError(crate::services::eden_service::RemoveBindMountExn),
        #[error("EdenService::getCurrentJournalPosition failed with {0:?}")]
        EdenServiceGetCurrentJournalPositionError(crate::services::eden_service::GetCurrentJournalPositionExn),
        #[error("EdenService::getFilesChangedSince failed with {0:?}")]
        EdenServiceGetFilesChangedSinceError(crate::services::eden_service::GetFilesChangedSinceExn),
        #[error("EdenService::setJournalMemoryLimit failed with {0:?}")]
        EdenServiceSetJournalMemoryLimitError(crate::services::eden_service::SetJournalMemoryLimitExn),
        #[error("EdenService::getJournalMemoryLimit failed with {0:?}")]
        EdenServiceGetJournalMemoryLimitError(crate::services::eden_service::GetJournalMemoryLimitExn),
        #[error("EdenService::flushJournal failed with {0:?}")]
        EdenServiceFlushJournalError(crate::services::eden_service::FlushJournalExn),
        #[error("EdenService::debugGetRawJournal failed with {0:?}")]
        EdenServiceDebugGetRawJournalError(crate::services::eden_service::DebugGetRawJournalExn),
        #[error("EdenService::getFileInformation failed with {0:?}")]
        EdenServiceGetFileInformationError(crate::services::eden_service::GetFileInformationExn),
        #[error("EdenService::glob failed with {0:?}")]
        EdenServiceGlobError(crate::services::eden_service::GlobExn),
        #[error("EdenService::globFiles failed with {0:?}")]
        EdenServiceGlobFilesError(crate::services::eden_service::GlobFilesExn),
        #[error("EdenService::chown failed with {0:?}")]
        EdenServiceChownError(crate::services::eden_service::ChownExn),
        #[error("EdenService::getScmStatusV2 failed with {0:?}")]
        EdenServiceGetScmStatusV2Error(crate::services::eden_service::GetScmStatusV2Exn),
        #[error("EdenService::getScmStatus failed with {0:?}")]
        EdenServiceGetScmStatusError(crate::services::eden_service::GetScmStatusExn),
        #[error("EdenService::getScmStatusBetweenRevisions failed with {0:?}")]
        EdenServiceGetScmStatusBetweenRevisionsError(crate::services::eden_service::GetScmStatusBetweenRevisionsExn),
        #[error("EdenService::getManifestEntry failed with {0:?}")]
        EdenServiceGetManifestEntryError(crate::services::eden_service::GetManifestEntryExn),
        #[error("EdenService::getDaemonInfo failed with {0:?}")]
        EdenServiceGetDaemonInfoError(crate::services::eden_service::GetDaemonInfoExn),
        #[error("EdenService::getPid failed with {0:?}")]
        EdenServiceGetPidError(crate::services::eden_service::GetPidExn),
        #[error("EdenService::initiateShutdown failed with {0:?}")]
        EdenServiceInitiateShutdownError(crate::services::eden_service::InitiateShutdownExn),
        #[error("EdenService::getConfig failed with {0:?}")]
        EdenServiceGetConfigError(crate::services::eden_service::GetConfigExn),
        #[error("EdenService::reloadConfig failed with {0:?}")]
        EdenServiceReloadConfigError(crate::services::eden_service::ReloadConfigExn),
        #[error("EdenService::debugGetScmTree failed with {0:?}")]
        EdenServiceDebugGetScmTreeError(crate::services::eden_service::DebugGetScmTreeExn),
        #[error("EdenService::debugGetScmBlob failed with {0:?}")]
        EdenServiceDebugGetScmBlobError(crate::services::eden_service::DebugGetScmBlobExn),
        #[error("EdenService::debugGetScmBlobMetadata failed with {0:?}")]
        EdenServiceDebugGetScmBlobMetadataError(crate::services::eden_service::DebugGetScmBlobMetadataExn),
        #[error("EdenService::debugInodeStatus failed with {0:?}")]
        EdenServiceDebugInodeStatusError(crate::services::eden_service::DebugInodeStatusExn),
        #[error("EdenService::debugOutstandingFuseCalls failed with {0:?}")]
        EdenServiceDebugOutstandingFuseCallsError(crate::services::eden_service::DebugOutstandingFuseCallsExn),
        #[error("EdenService::debugGetInodePath failed with {0:?}")]
        EdenServiceDebugGetInodePathError(crate::services::eden_service::DebugGetInodePathExn),
        #[error("EdenService::debugSetLogLevel failed with {0:?}")]
        EdenServiceDebugSetLogLevelError(crate::services::eden_service::DebugSetLogLevelExn),
        #[error("EdenService::getAccessCounts failed with {0:?}")]
        EdenServiceGetAccessCountsError(crate::services::eden_service::GetAccessCountsExn),
        #[error("EdenService::clearAndCompactLocalStore failed with {0:?}")]
        EdenServiceClearAndCompactLocalStoreError(crate::services::eden_service::ClearAndCompactLocalStoreExn),
        #[error("EdenService::debugClearLocalStoreCaches failed with {0:?}")]
        EdenServiceDebugClearLocalStoreCachesError(crate::services::eden_service::DebugClearLocalStoreCachesExn),
        #[error("EdenService::debugCompactLocalStorage failed with {0:?}")]
        EdenServiceDebugCompactLocalStorageError(crate::services::eden_service::DebugCompactLocalStorageExn),
        #[error("EdenService::unloadInodeForPath failed with {0:?}")]
        EdenServiceUnloadInodeForPathError(crate::services::eden_service::UnloadInodeForPathExn),
        #[error("EdenService::flushStatsNow failed with {0:?}")]
        EdenServiceFlushStatsNowError(crate::services::eden_service::FlushStatsNowExn),
        #[error("EdenService::invalidateKernelInodeCache failed with {0:?}")]
        EdenServiceInvalidateKernelInodeCacheError(crate::services::eden_service::InvalidateKernelInodeCacheExn),
        #[error("EdenService::getStatInfo failed with {0:?}")]
        EdenServiceGetStatInfoError(crate::services::eden_service::GetStatInfoExn),
        #[error("EdenService::enableTracing failed with {0:?}")]
        EdenServiceEnableTracingError(crate::services::eden_service::EnableTracingExn),
        #[error("EdenService::disableTracing failed with {0:?}")]
        EdenServiceDisableTracingError(crate::services::eden_service::DisableTracingExn),
        #[error("EdenService::getTracePoints failed with {0:?}")]
        EdenServiceGetTracePointsError(crate::services::eden_service::GetTracePointsExn),
        #[error("EdenService::injectFault failed with {0:?}")]
        EdenServiceInjectFaultError(crate::services::eden_service::InjectFaultExn),
        #[error("EdenService::removeFault failed with {0:?}")]
        EdenServiceRemoveFaultError(crate::services::eden_service::RemoveFaultExn),
        #[error("EdenService::unblockFault failed with {0:?}")]
        EdenServiceUnblockFaultError(crate::services::eden_service::UnblockFaultExn),
        #[error("Application exception: {0:?}")]
        ApplicationException(ApplicationException),
    }

    impl From<ApplicationException> for ErrorKind {
        fn from(exn: ApplicationException) -> Self {
            ErrorKind::ApplicationException(exn)
        }
    }
}
